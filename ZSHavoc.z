wha

import "std.zh"
import "string.zh"
import "ZScript Havoc/laser.zh"
import "ZScript Havoc/ffcscript.zh"
import "ZScript Havoc/ghost.zh"

const int RupeeFlower_Item1 = 0; //item IDs of the items that rain down
const int RupeeFlower_Item2 = 1; //use -1 if you only need the first item
const int RupeeFlower_PercentageSecondItem = 15; //chance in percentage for how often the second item falls down instead of the first (ignore this if you only use 1 item)
const int RupeeFlower_RateMin = 15; //the minimum rate in frames at which items rain down
const int RupeeFlower_RateMax = 25; //the maximum rate in frames at which items rain down

int RupeeFlower_ActiveFrames = 0; //global variable required for the rupee flower

int FireStreamActive;
int FireStreamDir;

bool GotRupee1;
bool GotRupee5;
bool GotRupee20;
bool GotHeart;
bool GotFairy;
bool GotKey;
bool GotBombs;
bool GotRupee10;
bool GotArrows;

int LinkHurtFrames;

int MooshPit[16];
const int MP_LASTX = 0;
const int MP_LASTY = 1;
const int MP_LASTDMAP = 2;
const int MP_LASTSCREEN = 3;
const int MP_ENTRYX = 4;
const int MP_ENTRYY = 5;
const int MP_ENTRYDMAP = 6;
const int MP_ENTRYSCREEN = 7;
const int MP_FALLX = 8;
const int MP_FALLY = 9;
const int MP_FALLTIMER = 10;
const int MP_FALLSTATE = 11;
const int MP_DAMAGETYPE = 12;

const int CT_HOLELAVA = 128; //Combo type for pits (No Ground Enemies by default)
const int CF_LAVA = -1; //Combo flag marking pits as lava (Script 1 by default)

const int SPR_FALLHOLE = 99; //Sprite for Link falling in a hole
const int SPR_FALLLAVA = 100; //Sprite for Link falling in lava

const int SFX_FALLHOLE = 38; //Sound for falling in a hole
const int SFX_FALLLAVA = 55; //Sound for falling in lava

const int DAMAGE_FALLHOLE = 8; //How much damage pits deal (1/2 heart default)
const int DAMAGE_FALLLAVA = 8; //How much damage lava deals (1 heart default)

const int FFC_MOOSHPIT_AUTOWARPA = 32; //FFC that turns into an auto side warp combo when you fall in a pit
const int CMB_MOOSHPIT_AUTOWARPA = 888; //Combo number of an invisible Auto Side Warp A combo
const int SF_MISC_MOOSHPITWARP = 2; //Number of the screen flag under the Misc. section that makes pits warp (Script 1 by default)
									//All pit warps use Side Warp A
								
//Width and height of Link's hitbox for colliding with pits
const int MOOSHPIT_LINKHITBOXWIDTH = 2;
const int MOOSHPIT_LINKHITBOXHEIGHT = 2;

//Width and height of Link's hitbox for colliding with pits/lava in sideview
const int MOOSHPIT_SIDEVIEW_LINKHITBOXWIDTH = 2;
const int MOOSHPIT_SIDEVIEW_LINKHITBOXHEIGHT = 2;

//Three colors used for the lasers
const int C_EZB_LASER1 = 0x03;
const int C_EZB_LASER2 = 0x04;
const int C_EZB_LASER3 = 0x01;

const int SFX_EZB_TELEPORT = 62; //Sound when a boss teleports
const int SFX_EZB_LASER = 63; //Sound when a laser is fired


const int EZBF_4WAY		 = 00000001b;
const int EZBF_8WAY		 = 00000010b;
const int EZBF_FLYING	   = 00000100b;
const int EZBF_AQUATIC	  = 00001000b;
const int EZBF_NOFALL	   = 00010000b;
const int EZBF_EXPLODEEATH  = 00100000b;
const int EZBF_FACELINK	 = 01000000b;
const int EZBF_UNBLOCKABLE  = 10000000b;

int TakeABreak = 0;

bool EntryMessage[4];

int GibdosCurse = -1;

//Better Stone of Agony
const int BetterAgony_ID = 157; //item ID
const int BetterAgony_DetectionRadius = 500; //the secret detection radius in pixels
const int BetterAgony_DetectionFlag = 98; //script flag number to use for secret detection
const int BetterAgony_Vibrate = 0; //wether or not it makes link vibrate. 0 = no, 1 = yes
const int BetterAgony_SFX = 64; //sound effect to play. leave as 0 if unneeded
const int BetterAgony_SFXRepeatRate = 30; //how fast to repeat the sound effect, in frames
const int BetterAgony_ComboID = 883; //combo to draw above links head as an indicator. leave as 0 if unneeded.
const int BetterAgony_ComboCSet = 7; //cset to use for the combo

const int LIGHT_FLAG = 98;
const int BLACK_COLOR = 0x07;
const int DARK_ROOM_SLOT = 31;
bool ActiveLastFrame = false;
int LightX[200];
int LightY[200];
int LightSize[200];
bool LightPerm[200];

int SilverRupees;

int PowerColour;

int TriforcePieces;

int GlobalVars[255];
const int LinkMoving0 = 0;
const int LinkMoving1 = 1;
const int LinkMoving2 = 2;
const int L4MultiTrigger1 = 3;
const int L4MultiTrigger2 = 4;
const int L4MultiTrigger3 = 5;
const int L4MultiTrigger4 = 6;
const int Challenge1 = 7;
const int Challenge2 = 8;
const int Challenge3 = 9;
const int Challenge4 = 10;
const int GauntletIntro = 11;
const int Ascension = 12;
const int AvosIntro = 13;
const int NoActionFix = 14;
const int HurtCSet = 15;
const int HurtCSetTimer = 16;
const int HurtCSetFrames = 17;

global script Startup{
	void run(){
		for (int i = 0; i <= 6; i++) {
			Screen->SetRenderTarget(i);
			for (int j = 0; j <= 7; j++) {
				Screen->Rectangle(j, 0, 0, 512, 512, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
			}
		}
		TakeABreak = 0;
	}
}

float Detect_250_2_Jump(){
	Link->Jump = 10;
	return Link->Jump;
}

global script ActiveScript{
	void run(){
		if ( Detect_250_2_Jump() != 10 ) {
			Link->Jump = 0;
			if ( Game->GetCurMap() == 1 && Game->GetCurScreen() == 0x75 ) {
				Screen->ComboD[51] = 889;
				WaitNoAction();
			}
			Screen->Message(90); //"wrong version detected. please use 2.50.2 or higher"
			WaitNoAction();
			Game->End();
		}
		Link->Jump = 0;
		for (int i = 0; i <= 6; i++) {
			Screen->SetRenderTarget(i);
			for (int j = 0; j <= 7; j++) {
				Screen->Rectangle(j, 0, 0, 512, 512, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
			}
		}
		Screen->SetRenderTarget(-1);
		LinkMovement_Init();
		for (int i = 0; i <= 27; i++) {
			Game->SetComboType(1, 0x2F, i, CT_NOFLYZONE);
			Game->SetComboInherentFlag(1, 0x2F, i, 0);
			Game->SetComboSolid(0, 0x2F, i, 1111b);
			Game->SetComboSolid(1, 0x2F, i, 1111b);
		}
		PowerColour = 0;
		for (int i = 0; i <= 27; i++) {
			Game->SetComboType(1, 0x2F, i, CT_NOGROUNDENEMY);
			Game->SetComboInherentFlag(1, 0x2F, i, 0);
			Game->SetComboSolid(0, 0x2F, i, 1111b);
			Game->SetComboSolid(1, 0x2F, i, 1111b);
		}
		if ( Link->Item[160] ) { //refilling potion
			Link->Item[161] = true;
			Link->Item[162] = true;
		}
		LinkHurtFrames = 0;
		RupeeFlower_ActiveFrames = 0; //these 3 lines go between void run(){ and while(true){
		int RupeeFlower_RateCounter = 0;
		int RupeeFlower_Rate = 0;
		MooshPit_Init();
		StartGhostZH();
		if ( TakeABreak > 72000 )
			TakeABreak = 72000;
		FireStreamActive = 0;
		FireStreamDir = 0;
		int rotating;
		bool HelloDarknessMyOldFriend = false;
		
		int DrunkEffect;
		
		int LastFrameLinkX;
		int LastFrameLinkY;
		while(true){
			if ( Link->Drunk > 0 ) {
				Link->Drunk = 0;
				DrunkEffect = 120;
			}
			
			if ( DrunkEffect > 0 ) {
				Screen->Wavy = 8;
				if ( Link->InputUp ) {
					Link->InputUp = false;
					Link->InputDown = true;
				}
				else if ( Link->InputDown ) {
					Link->InputDown = false;
					Link->InputUp = true;
				}
				if ( Link->InputLeft ) {
					Link->InputLeft = false;
					Link->InputRight = true;
				}
				else if ( Link->InputRight ) {
					Link->InputRight = false;
					Link->InputLeft = true;
				}
				DrunkEffect --;
			}
			
			UpdateGhostZH1();
			MooshPit_Update();
			
			LinkMovement_Update1();
			
			if ( CountFFCsRunning(1) == 0 ) //the global ffc
				RunFFCScript(1, 0);

			if ( RupeeFlower_ActiveFrames > 0 ) { //rupee flower active script
				RupeeFlower_RateCounter ++;
				if ( RupeeFlower_RateCounter >= RupeeFlower_Rate ) {
					RupeeFlower_RateCounter = 0;
					RupeeFlower_Rate = Rand(RupeeFlower_RateMin, RupeeFlower_RateMax);
					item itemdrop;
					int randomchance = Rand(1, 100);
					if ( RupeeFlower_Item2 >= 0 && randomchance <= RupeeFlower_PercentageSecondItem )
						itemdrop = Screen->CreateItem(RupeeFlower_Item2);
					else
						itemdrop = Screen->CreateItem(RupeeFlower_Item1);
					SetItemPickup(itemdrop, IP_TIMEOUT, true);
					itemdrop->X = Rand(240); itemdrop->Y = Rand(160);
					while(Distance(itemdrop->X+8,itemdrop->Y+8,Link->X,Link->Y) > 50) {
						itemdrop->X = Rand(240); itemdrop->Y = Rand(160);
					}
					itemdrop->Z = 120;
				}
				RupeeFlower_ActiveFrames --;
			}

			if ( Game->Counter[CR_BOMBS] == 0 && Link->Item[145] )
				Link->Item[145] = false;
			if ( Game->Counter[CR_BOMBS] > 0 && !Link->Item[145] )
				Link->Item[145] = true;

			LREx1Ex2ItemSwitch();
			
			DarkRoomGlobal(HelloDarknessMyOldFriend);

			Waitdraw();
			UpdateGhostZH2();
			
			LinkMovement_Update2();
			
			if ( Link->Action == LA_GOTHURTLAND ) {
				if ( LinkHurtFrames != -1 )
					LinkHurtFrames ++;
			}
			else
				LinkHurtFrames = 0;
			if ( FireStreamActive > 0 )
				Link->Dir = FireStreamDir;
			
			if ( Game->GetCurScreen() == 0x0F && Game->GetCurMap() == 1 ) {
				if ( Link->Action == LA_HOLD1LAND ) {
					Screen->FastTile(2, Link->X, Link->Y, 32072, 6, OP_OPAQUE);
				}
				else {
					Screen->SetRenderTarget(3);
					Screen->DrawScreen(0, 1, 0x0F, 0, 0, 0);
					Screen->DrawTile(0, Link->X, Link->Y, Link->Tile, 1, 1, 6, -1, -1, 0, 0, 0, Link->Flip, true, OP_OPAQUE);
					for (int i = 1; i <= Screen->NumItems(); i++) { //for all items
						item itm = Screen->LoadItem(i);
						itm->DrawXOffset = -1000;
						Screen->FastTile(0, itm->X, itm->Y, itm->Tile, itm->CSet, OP_OPAQUE);
					}
					Screen->SetRenderTarget(RT_SCREEN);
					Screen->Rectangle(2, 0, 0, 255, 175, 0x07, 1, 0, 0, 0, true, OP_OPAQUE);
					Screen->DrawBitmap(2, 3, 0, 0, 256, 176, 0, 0, 256, 176, rotating, true);
					rotating += 1.5;
					if(rotating < -360)rotating+=360; //Wrap if below -360. ???? i dont know
					else if(rotating > 360)rotating-=360; //Wrap if above 360. ???? i dont know
				}
			}
			else
				rotating = 0;
			
			for(int i=1; i<=32; i++){ //Cycle through every FFC
				ffc f = Screen->LoadFFC(i);
				if(f->Script == 6){
					if ( PowerColour == 4 && RectCollision(Link->X+4, Link->Y+9, Link->X+11, Link->Y+14, f->X, f->Y, f->X+f->EffectWidth-1, f->Y+f->EffectHeight-1) ){
						Link->X = LastFrameLinkX;
						Link->Y = LastFrameLinkY;
					}
				}
			}
			
			LastFrameLinkX = Link->X;
			LastFrameLinkY = Link->Y;
			Waitframe();
		}
	}
}

ffc script TheGlobalFFC{
	void run(){
		GlobalVars[LinkMoving0] = 0;
		GlobalVars[LinkMoving1] = 0;
		GlobalVars[LinkMoving2] = 0;
		Link->Invisible = false;
		Link->CollDetection = true;
		Link->DrawXOffset = 0;
		Screen->D[0] = 0;
		Game->Counter[CR_MAGIC] = Game->MCounter[CR_MAGIC];
		int MagicRegen;

		lweapon GreatSpinA[12];
		lweapon GreatSpinB[12];
		lweapon GreatSpinC[12];
		int GreatSpinActive;
		int GreatSpinDegree;
		int GreatSpinDegreeN;
		int GreatSpinMDrain;

		FireStreamActive = 0;
		FireStreamDir = 0;

		int BombFlightActive;
		int BombFlightBombX[60];
		int BombFlightBombY[60];
		int BombFlightBombTimer[60];
		for (int i = 0; i < 60; i++) {
			BombFlightBombX[i] = -1;
			BombFlightBombY[i] = -1;
			BombFlightBombTimer[i] = -1;
		}
		int CurrentBombFlightBombTimer;

		int ArrowLineActive;
		int ArrowLineX;
		int ArrowLineY;
		int ArrowLineDestX;
		int ArrowLineDestY;
		int ArrowLineDir;
		float ArrowLineAngle;
		int ArrowLineSpeed;

		int MagicAttackActive;
		int MagicAttackTimer;
		int MagicAttackDegree;
		int MagicAttackCenterX[20];
		int MagicAttackCenterY[20];
		for (int i = 0; i < 20; i++) {
			MagicAttackCenterX[i] = -1;
			MagicAttackCenterY[i] = -1;
		}
		int MagicAttackRadius[20];
		int MagicAttackDir[20];
		lweapon MagicAttack[150];
		int MagicAttackAttachedTo[150];
		int MagicAttackNum[150];
		
		int MegaWhistleActive;
		int MegaWhistleDDBonus;
		if ( (Game->GetCurDMap() == 6 && Game->GetCurScreen() == 0x43) || (Game->GetCurMap() == 13 && Game->GetCurScreen() == 0x10) )
			MegaWhistleDDBonus = 8;
		
		bool CursorDungeon;
		if ( Game->GetCurDMap() == 6 || Game->GetCurDMap() == 15 || Game->GetCurDMap() == 20 ) {
			CursorDungeon = true;
			Game->ClickToFreezeEnabled = false;
		}
		else
			Game->ClickToFreezeEnabled = true;
			
		int Layer2Flag[175];
		int Layer2FlagNew[175];
		for (int i = 0; i < 175; i++) {
			Layer2Flag[i] = GetLayerComboF(3, i);
		}
		bool HoldLeftMB;
		int DungeonHoldPiece;
		int DungeonHoldPos;
		int DungeonPieceCombo[175];
		int DungeonPieceCSet[175];
		int DungeonPieceFlag[175];
		int DungeonPieceSlideX;
		int DungeonPieceSlideY;
		int DungeonPieceSlideDir = -1;
		int DungeonMovePiece;
		
		int triggerOff = 557;
		int triggerOn = 558;
		int numberOfTriggers = 0;
		bool roomHasTriggers;
		for(int i = 0; i < 175; i++){
			if ( Screen->ComboD[i] == triggerOff || Screen->ComboD[i] == 1006 || Screen->ComboD[i] == 725 ) {
				numberOfTriggers ++;
				roomHasTriggers = true;
			}
		}
		int numberOfCrystals = 0;
		bool roomHasCrystals;
		for(int i = 0; i < 175; i++){
			if ( Screen->ComboD[i] == 664 ) {
				numberOfCrystals ++;
				roomHasCrystals = true;
			}
		}
		int that1crystaltimer;
		
		int ArrowShooterCounter;
		
		int GibdosCurseX[10];
		int GibdosCurseY[10];
		
		if ( GibdosCurse > 0 )
			Link->HP += GibdosCurse;
		GibdosCurse = -1;
		if ( Link->HP > Link->MaxHP )
			Link->HP = Link->MaxHP;
		
		int CurrentFramesCounter;
		int BoomerangSFX;
		
		bool LinkInWall;
		lweapon ColourSparkle[10];
		int ColourSparkleTimer;
		
		for (int i = 0; i <= 175; i++) {
			if ( Screen->ComboD[i] >= 584 && Screen->ComboD[i] <= 587 ) {
				ffc PCStatue = Screen->LoadFFC(RunFFCScript(36, 0));
				PCStatue->X = ComboX(i);
				PCStatue->Y = ComboY(i);
			}
		}
		
		if ( (Game->GetCurDMap() != 8 && Game->GetCurDMap() != 18) || (Game->GetCurDMap() == 8 && Game->GetCurScreen() == 0x33) ) {
			PowerColour = 0;
			for (int i = 0; i <= 27; i++) {
				Game->SetComboType(1, 0x2F, i, CT_NOGROUNDENEMY);
				Game->SetComboInherentFlag(1, 0x2F, i, 0);
				Game->SetComboSolid(0, 0x2F, i, 1111b);
				Game->SetComboSolid(1, 0x2F, i, 1111b);
			}
		}
		
		int extrapush = 1;
		while(true){
			if ( TakeABreak >= 72001 ) {
				TakeABreak = 0;
			}
			if ( TakeABreak == 72000 )
				Screen->Message(3);
			TakeABreak ++;
		
			if ( MooshPit[MP_FALLSTATE] == 1 )
				NoAction();
			
			if ( PowerColour == 3 && Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] >= 1545 && Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] <= 1586 ) {
				LinkInWall = true;
				Link->Invisible = true;
			}
			else if ( LinkInWall ) {
				Link->Invisible = false;
				LinkInWall = false;
			}
			if ( LinkInWall ) {
				Screen->FastCombo(3, Link->X, Link->Y, 76, 10, OP_OPAQUE);
				Link->InputA = false;
				Link->InputB = false;
			}
			
			bool LeftClick;
			int CurrentMousePos = ComboAt(Link->InputMouseX, Link->InputMouseY);
			if ( InputLeftClick() && !HoldLeftMB ) {
				LeftClick = true;
				HoldLeftMB = true;
				if ( (Layer2Flag[ComboAt(Link->InputMouseX, Link->InputMouseY)] == 98
				|| Layer2Flag[ComboAt(Link->InputMouseX, Link->InputMouseY)] == 99
				|| Layer2Flag[ComboAt(Link->InputMouseX, Link->InputMouseY)] == 100
				|| Layer2Flag[ComboAt(Link->InputMouseX, Link->InputMouseY)] == 101
				|| Layer2Flag[ComboAt(Link->InputMouseX, Link->InputMouseY)] == 102
				|| Layer2Flag[ComboAt(Link->InputMouseX, Link->InputMouseY)] == 103
				|| Layer2Flag[ComboAt(Link->InputMouseX, Link->InputMouseY)] == 8
				|| Layer2Flag[ComboAt(Link->InputMouseX, Link->InputMouseY)] == 12)
				&& (!Screen->State[ST_SECRET] || Screen->ComboD[102] != 1044) ) {
					if ( Layer2Flag[ComboAt(Link->X+8, Link->Y+12)] == Layer2Flag[CurrentMousePos] )
						Game->PlaySound(61);
					else {
						DungeonHoldPiece = Layer2Flag[CurrentMousePos];
						DungeonHoldPos = CurrentMousePos;
					}
				}
			}
			if ( !InputLeftClick() || MooshPit[MP_FALLSTATE] == 1 || !CursorDungeon ) {
				HoldLeftMB = false;
				DungeonHoldPiece = 0;
				DungeonHoldPos = 0;
				CurrentMousePos = 0;
			}
			if ( Layer2Flag[ComboAt(Link->X+8, Link->Y+12)] == DungeonHoldPiece && DungeonHoldPiece != 0 ) {
				DungeonHoldPiece = 0;
				DungeonHoldPos = 0;
				CurrentMousePos = 0;
			}
			
			if ( ComboX(CurrentMousePos) > ComboX(DungeonHoldPos) && DungeonPieceSlideDir == -1 ) {
				DungeonPieceSlideDir = DIR_RIGHT;
				for (int i = 0; i < 175; i++) {
					if ( Layer2Flag[i] == DungeonHoldPiece ) {
						if ( Screen->ComboD[i+1] != 721 && Layer2Flag[i+1] != DungeonHoldPiece )
							DungeonPieceSlideDir = -1;
					}
				}
			}
			if ( ComboX(CurrentMousePos) < ComboX(DungeonHoldPos) && DungeonPieceSlideDir == -1 ) {
				DungeonPieceSlideDir = DIR_LEFT;
				for (int i = 0; i < 175; i++) {
					if ( Layer2Flag[i] == DungeonHoldPiece ) {
						if ( Screen->ComboD[i-1] != 721 && Layer2Flag[i-1] != DungeonHoldPiece )
							DungeonPieceSlideDir = -1;
					}
				}
			}
			if ( ComboY(CurrentMousePos) > ComboY(DungeonHoldPos) && DungeonPieceSlideDir == -1 ) {
				DungeonPieceSlideDir = DIR_DOWN;
				for (int i = 0; i < 175; i++) {
					if ( Layer2Flag[i] == DungeonHoldPiece ) {
						if ( Screen->ComboD[i+16] != 721 && Layer2Flag[i+16] != DungeonHoldPiece )
							DungeonPieceSlideDir = -1;
					}
				}
			}
			if ( ComboY(CurrentMousePos) < ComboY(DungeonHoldPos) && DungeonPieceSlideDir == -1 ) {
				DungeonPieceSlideDir = DIR_UP;
				for (int i = 0; i < 175; i++) {
					if ( Layer2Flag[i] == DungeonHoldPiece ) {
						if ( Screen->ComboD[i-16] != 721 && Layer2Flag[i-16] != DungeonHoldPiece )
							DungeonPieceSlideDir = -1;
					}
				}
			}
			if ( (DungeonPieceSlideDir == DIR_UP && DungeonPieceSlideY == 0) || (DungeonPieceSlideDir == DIR_RIGHT && DungeonPieceSlideX == 0)
			|| (DungeonPieceSlideDir == DIR_DOWN && DungeonPieceSlideY == 0) || (DungeonPieceSlideDir == DIR_LEFT && DungeonPieceSlideX == 0) ) {
				DungeonMovePiece = DungeonHoldPiece;
				if ( DungeonPieceSlideDir == DIR_UP ) DungeonPieceSlideY = -2;
				if ( DungeonPieceSlideDir == DIR_RIGHT ) DungeonPieceSlideX = 2;
				if ( DungeonPieceSlideDir == DIR_DOWN ) DungeonPieceSlideY = 2;
				if ( DungeonPieceSlideDir == DIR_LEFT ) DungeonPieceSlideX = -2;
				for (int i = 0; i < 175; i++) {
					if ( Layer2Flag[i] == DungeonMovePiece ) {
						DungeonPieceCombo[i] = Screen->ComboD[i];
						DungeonPieceCSet[i] = Screen->ComboC[i];
						DungeonPieceFlag[i] = Screen->ComboF[i];
						Screen->ComboD[i] = 721;
						Screen->ComboC[i] = 2;
						Screen->ComboF[i] = 0;
					}
				}
			}
			else {
				if ( DungeonPieceSlideX > 0 )
					DungeonPieceSlideX += 2;
				if ( DungeonPieceSlideY > 0 )
					DungeonPieceSlideY += 2;
				if ( DungeonPieceSlideX < 0 )
					DungeonPieceSlideX -= 2;
				if ( DungeonPieceSlideY < 0 )
					DungeonPieceSlideY -= 2;
			}
			if ( DungeonPieceSlideX == 16 || DungeonPieceSlideY == 16 || DungeonPieceSlideX == -16 || DungeonPieceSlideY == -16 ) {
				if ( DungeonHoldPos != 0 )
					DungeonHoldPos = ComboAt(ComboX(DungeonHoldPos)+DungeonPieceSlideX, ComboY(DungeonHoldPos)+DungeonPieceSlideY);
				for (int i = 0; i < 175; i++) {
					if ( Layer2Flag[i] == DungeonMovePiece ) {
						Screen->ComboD[ComboAt(ComboX(i)+DungeonPieceSlideX, ComboY(i)+DungeonPieceSlideY)] = DungeonPieceCombo[i];
						Screen->ComboC[ComboAt(ComboX(i)+DungeonPieceSlideX, ComboY(i)+DungeonPieceSlideY)] = DungeonPieceCSet[i];
						Screen->ComboF[ComboAt(ComboX(i)+DungeonPieceSlideX, ComboY(i)+DungeonPieceSlideY)] = DungeonPieceFlag[i];
						DungeonPieceCombo[i] = 0;
						DungeonPieceCSet[i] = 0;
						DungeonPieceFlag[i] = 0;
						Layer2Flag[i] = 0;
						Layer2FlagNew[ComboAt(ComboX(i)+DungeonPieceSlideX, ComboY(i)+DungeonPieceSlideY)] = DungeonMovePiece;
					}
				}
				for (int i = 0; i < 175; i++) {
					if ( Layer2Flag[i] == 0 )
						Layer2Flag[i] = Layer2FlagNew[i];
					Layer2FlagNew[i] = 0;
				}
				DungeonPieceSlideX = 0;
				DungeonPieceSlideY = 0;
				DungeonPieceSlideDir = -1;
			}
			if ( DungeonPieceSlideDir != -1 ) {
				for (int i = 0; i < 175; i++) {
					if ( Layer2Flag[i] == DungeonMovePiece )
						Screen->FastCombo(2, ComboX(i)+DungeonPieceSlideX, ComboY(i)+DungeonPieceSlideY, DungeonPieceCombo[i], DungeonPieceCSet[i], OP_OPAQUE);
				}
			}
			
			if ( GlobalVars[NoActionFix] > 0 ) {
				NoAction();
				GlobalVars[NoActionFix] --;
			}
		
			for (int i = 0; i < 12; i++) {
				GreatSpinA[i]->DeadState = 0;
				GreatSpinB[i]->DeadState = 0;
				GreatSpinC[i]->DeadState = 0;
			}
			if ( ((((GetEquipmentA() == 143 && Link->InputA) || (GetEquipmentB() == 143 && Link->InputB)) && GreatSpinActive > 0)
			|| (((GetEquipmentA() == 143 && Link->PressA) || (GetEquipmentB() == 143 && Link->PressB)) && GreatSpinActive == 0))
			&& ((Game->Counter[CR_MAGIC] >= 72 && GreatSpinActive == 0) || (Game->Counter[CR_MAGIC] >= 8 && GreatSpinActive > 0)) ) { //GreatSpin
				if ( GreatSpinActive == 0 ) {
					Game->PlaySound(54);
					Game->Counter[CR_MAGIC] -= 64;
					MagicRegen --;
					GreatSpinMDrain = 20;
					GreatSpinActive ++;
				}

				GreatSpinDegree += 3;
				if(GreatSpinDegree < -360)GreatSpinDegree+=360; //Wrap if below -360. ???? i dont know
				else if(GreatSpinDegree > 360)GreatSpinDegree-=360; //Wrap if above 360. ???? i dont know
				GreatSpinDegreeN -= 3;
				if(GreatSpinDegreeN < -360)GreatSpinDegreeN+=360; //Wrap if below -360. ???? i dont know
				else if(GreatSpinDegreeN > 360)GreatSpinDegreeN-=360; //Wrap if above 360. ???? i dont know

				for (int i = 0; i < 12; i++) {
					GreatSpinA[i] = CreateLWeaponAt(LW_BEAM, Link->X, Link->Y);
					GreatSpinA[i]->UseSprite(88);
					GreatSpinA[i]->Damage = 2+GlobalVars[Ascension];
					GreatSpinB[i] = CreateLWeaponAt(LW_BEAM, Link->X, Link->Y);
					GreatSpinB[i]->UseSprite(88);
					GreatSpinB[i]->Damage = 2+GlobalVars[Ascension];
					GreatSpinC[i] = CreateLWeaponAt(LW_BEAM, Link->X, Link->Y);
					GreatSpinC[i]->UseSprite(88);
					GreatSpinC[i]->Damage = 2+GlobalVars[Ascension];
					GreatSpinA[i]->Dir = Link->Dir;
					GreatSpinB[i]->Dir = Link->Dir;
					GreatSpinC[i]->Dir = Link->Dir;
					GreatSpinA[i]->X = Link->X + GreatSpinActive*Cos(GreatSpinDegree+360/12*i);
					GreatSpinA[i]->Y = Link->Y + GreatSpinActive*Sin(GreatSpinDegree+360/12*i);
					Screen->DrawTile(2, GreatSpinA[i]->X, GreatSpinA[i]->Y, 20362, 1, 1, 7, -1, -1, GreatSpinA[i]->X, GreatSpinA[i]->Y, GreatSpinDegree+360/12*i, 0, true, OP_OPAQUE);
					GreatSpinB[i]->X = Link->X + (GreatSpinActive+16)*Cos(GreatSpinDegreeN+360/12*i);
					GreatSpinB[i]->Y = Link->Y + (GreatSpinActive+16)*Sin(GreatSpinDegreeN+360/12*i);
					Screen->DrawTile(2, GreatSpinB[i]->X, GreatSpinB[i]->Y, 20362, 1, 1, 7, -1, -1, GreatSpinB[i]->X, GreatSpinB[i]->Y, GreatSpinDegreeN+360/12*i, 0, true, OP_OPAQUE);
					GreatSpinC[i]->X = Link->X + (GreatSpinActive+32)*Cos(GreatSpinDegree+360/12*i);
					GreatSpinC[i]->Y = Link->Y + (GreatSpinActive+32)*Sin(GreatSpinDegree+360/12*i);
					Screen->DrawTile(2, GreatSpinC[i]->X, GreatSpinC[i]->Y, 20362, 1, 1, 7, -1, -1, GreatSpinC[i]->X, GreatSpinC[i]->Y, GreatSpinDegree+360/12*i, 0, true, OP_OPAQUE);
				}

				if ( GreatSpinMDrain > 0 )
					GreatSpinMDrain --;
				else {
					Game->Counter[CR_MAGIC] -= 8;
					GreatSpinMDrain = 20;
				}
				if ( GreatSpinActive < 48 )
					GreatSpinActive += 2;
			}
			else if ( GreatSpinActive > 0 ) {
				for (int i = 0; i < 12; i++) {
					GreatSpinA[i]->DeadState = 0;
					GreatSpinB[i]->DeadState = 0;
					GreatSpinC[i]->DeadState = 0;
				}
				MagicRegen ++;
				GreatSpinActive = 0;
			}

			if ( ((GetEquipmentA() == 144 && Link->PressA) || (GetEquipmentB() == 144 && Link->PressB)) ) { //FireStream
				if ( FireStreamActive == 0 && Game->Counter[CR_MAGIC] >= 128 ) {
					Game->PlaySound(37);
					Game->Counter[CR_MAGIC] -= 128;
					MagicRegen --;
					FireStreamActive = 240;
					FireStreamDir = Link->Dir;
				}
			}
			if ( FireStreamActive > 0 ) {
				lweapon FireStream = CreateLWeaponAt(LW_FIRE, Link->X, Link->Y);
				FireStream->Z = Link->Z;
				FireStream->Dir = FireStreamDir;
				FireStream->Angular = true;
				if ( FireStreamDir == DIR_UP ) { FireStream->UseSprite(89); FireStream->Angle = DegtoRad(270+Rand(-20, 20)); }
				if ( FireStreamDir == DIR_RIGHT ) { FireStream->UseSprite(90); FireStream->Angle = DegtoRad(0+Rand(-20, 20)); }
				if ( FireStreamDir == DIR_DOWN ) { FireStream->UseSprite(91); FireStream->Angle = DegtoRad(90+Rand(-20, 20)); }
				if ( FireStreamDir == DIR_LEFT ) { FireStream->UseSprite(92); FireStream->Angle = DegtoRad(180+Rand(-20, 20)); }
				FireStream->Damage = 2+GlobalVars[Ascension];
				FireStream->Step = Rand(440, 460);
				FireStreamActive --;
				if ( FireStreamActive == 0 )
					MagicRegen ++;
			}

			if ( ((GetEquipmentA() == 145 && Link->PressA) || (GetEquipmentB() == 145 && Link->PressB)) ) { //BombFlight
				if ( BombFlightActive == 0 && Game->Counter[CR_MAGIC] >= 96 && Game->Counter[CR_BOMBS] > 0 ) {
					Game->PlaySound(21);
					Game->Counter[CR_MAGIC] -= 96;
					Game->Counter[CR_BOMBS] --;
					MagicRegen --;
					BombFlightActive = 240;
					CurrentBombFlightBombTimer = 0;
				}
			}
			if ( BombFlightActive > 0 ) {
				if ( CurrentBombFlightBombTimer == 0 ) {
					int i;
					while(i != -1){
						if ( BombFlightBombX[i] == -1 ) {
							BombFlightBombX[i] = Link->X + Rand(-2, 2);
							BombFlightBombY[i] = Link->Y + Rand(-2, 2);
							BombFlightBombTimer[i] = 0;
							i = -1;
						}
						else
							i ++;
					}
					CurrentBombFlightBombTimer = 4;
				}
				else
					CurrentBombFlightBombTimer --;

				BombFlightActive --;
				if ( BombFlightActive == 0 )
					MagicRegen ++;
			}
			for (int i = 0; i < 60; i++) {
				if ( BombFlightBombX[i] != -1 ) {
					BombFlightBombTimer[i] ++;
					if ( BombFlightBombTimer[i] < 60 ) {
						Screen->DrawTile(2, BombFlightBombX[i], BombFlightBombY[i], 21691, 1, 1, 7, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
					}
					else {
						Game->PlaySound(3);
						lweapon Explosion = CreateLWeaponAt(LW_SBOMBBLAST, BombFlightBombX[i], BombFlightBombY[i]);
						Explosion->Damage = 3+GlobalVars[Ascension];
						BombFlightBombX[i] = -1;
						BombFlightBombY[i] = -1;
						BombFlightBombTimer[i] = -1;
					}
				}
			}

			if ( ((GetEquipmentA() == 147 && Link->PressA) || (GetEquipmentB() == 147 && Link->PressB)) ) { //ArrowLine
				if ( ArrowLineActive == 0 && Game->Counter[CR_MAGIC] >= 16 && Game->Counter[CR_ARROWS] > 0 ) {
					Game->Counter[CR_MAGIC] -= 16;
					Game->Counter[CR_ARROWS] --;
					ArrowLineActive = 16;
					ArrowLineX = Link->X;
					ArrowLineY = Link->Y;
					ArrowLineDir = Link->Dir;
					if ( ArrowLineDir == DIR_UP ) {
						ArrowLineDestX = 120; ArrowLineDestY = 175+64;
					}
					if ( ArrowLineDir == DIR_RIGHT ) {
						ArrowLineDestX = -64; ArrowLineDestY = 80;
					}
					if ( ArrowLineDir == DIR_DOWN ) {
						ArrowLineDestX = 120; ArrowLineDestY = -64;
					}
					if ( ArrowLineDir == DIR_LEFT ) {
						ArrowLineDestX = 255+64; ArrowLineDestY = 80;
					}
					ArrowLineAngle = Angle(ArrowLineX, ArrowLineY, ArrowLineDestX, ArrowLineDestY);
					ArrowLineSpeed = Distance(ArrowLineX, ArrowLineY, ArrowLineDestX, ArrowLineDestY) / 35;
				}
			}
			if ( ArrowLineActive > 0 ) {
				ArrowLineX += VectorX(ArrowLineSpeed, ArrowLineAngle);
				ArrowLineY += VectorY(ArrowLineSpeed, ArrowLineAngle);
				if ( ArrowLineDir == DIR_UP )
					Screen->DrawTile(5, ArrowLineX+8-ArrowLineActive/2, ArrowLineY+8-ArrowLineActive/2, 21954, 1, 1, 6, ArrowLineActive, ArrowLineActive, 0, 0, 0, 0, true, OP_OPAQUE);
				if ( ArrowLineDir == DIR_RIGHT )
					Screen->DrawTile(5, ArrowLineX+8-ArrowLineActive/2, ArrowLineY+8-ArrowLineActive/2, 21955, 1, 1, 6, ArrowLineActive, ArrowLineActive, 0, 0, 0, 0, true, OP_OPAQUE);
				if ( ArrowLineDir == DIR_DOWN )
					Screen->DrawTile(5, ArrowLineX+8-ArrowLineActive/2, ArrowLineY+8-ArrowLineActive/2, 21956, 1, 1, 6, ArrowLineActive, ArrowLineActive, 0, 0, 0, 0, true, OP_OPAQUE);
				if ( ArrowLineDir == DIR_LEFT )
					Screen->DrawTile(5, ArrowLineX+8-ArrowLineActive/2, ArrowLineY+8-ArrowLineActive/2, 21957, 1, 1, 6, ArrowLineActive, ArrowLineActive, 0, 0, 0, 0, true, OP_OPAQUE);
				ArrowLineActive += 8;
				if ( ArrowLineActive == 256 ) {
					Game->PlaySound(1);
					if ( ArrowLineDir == DIR_UP ) {
						for (int i = 0; i < 16; i++) {
							lweapon ArrowLine = CreateLWeaponAt(LW_ARROW, i*16, 160);
							ArrowLine->Dir = ArrowLineDir;
							ArrowLine->Damage = 2+GlobalVars[Ascension];
							ArrowLine->Step = 150;
							ArrowLine->UseSprite(94);
						}
					}
					if ( ArrowLineDir == DIR_RIGHT ) {
						for (int i = 0; i < 11; i++) {
							lweapon ArrowLine = CreateLWeaponAt(LW_ARROW, 0, i*16);
							ArrowLine->Dir = ArrowLineDir;
							ArrowLine->Damage = 2+GlobalVars[Ascension];
							ArrowLine->Step = 150;
							ArrowLine->UseSprite(95);
						}
					}
					if ( ArrowLineDir == DIR_DOWN ) {
						for (int i = 0; i < 16; i++) {
							lweapon ArrowLine = CreateLWeaponAt(LW_ARROW, i*16, 0);
							ArrowLine->Dir = ArrowLineDir;
							ArrowLine->Damage = 2+GlobalVars[Ascension];
							ArrowLine->Step = 150;
							ArrowLine->UseSprite(96);
						}
					}
					if ( ArrowLineDir == DIR_LEFT ) {
						for (int i = 0; i < 11; i++) {
							lweapon ArrowLine = CreateLWeaponAt(LW_ARROW, 240, i*16);
							ArrowLine->Dir = ArrowLineDir;
							ArrowLine->Damage = 2+GlobalVars[Ascension];
							ArrowLine->Step = 150;
							ArrowLine->UseSprite(97);
						}
					}
					ArrowLineActive = 0;
				}
			}

			if ( ((GetEquipmentA() == 148 && Link->PressA) || (GetEquipmentB() == 148 && Link->PressB)) ) { //MagicAttack
				if ( MagicAttackActive == 0 && Game->Counter[CR_MAGIC] >= 160 ) {
					Game->Counter[CR_MAGIC] -= 160;
					MagicRegen --;
					MagicAttackActive = 240;
					MagicAttackTimer = 0;
				}
			}
			if ( MagicAttackActive > 0 ) {
				if ( MagicAttackTimer == 0 ) {
					MagicAttackTimer = 30;
					Game->PlaySound(32);
					int i;
					int mnum;
					while(mnum < 4) {
						if ( MagicAttackCenterX[i] == -1 && MagicAttackCenterY[i] == -1 ) {
							MagicAttackCenterX[i] = Link->X;
							MagicAttackCenterY[i] = Link->Y+2;
							MagicAttackRadius[i] = 8;
							if ( mnum == 0 )
								MagicAttackDir[i] = DIR_UP;
							if ( mnum == 1 )
								MagicAttackDir[i] = DIR_RIGHT;
							if ( mnum == 2 )
								MagicAttackDir[i] = DIR_DOWN;
							if ( mnum == 3 )
								MagicAttackDir[i] = DIR_LEFT;
							for (int j = 0; j < 12; j++) {
								int k;
								while(k != -1) {
									if ( !MagicAttack[k]->isValid() ) {
										MagicAttack[k] = CreateLWeaponAt(LW_MAGIC, Link->X, Link->Y);
										MagicAttack[k]->Dir = MagicAttackDir[i];
										MagicAttack[k]->UseSprite(98);
										MagicAttack[k]->Damage = 2+GlobalVars[Ascension];
										MagicAttack[k]->Step = 0;
										MagicAttackNum[k] = j;
										MagicAttackAttachedTo[k] = i;
										k = -1;
									}
									else
										k ++;
								}
							}
							mnum ++;
						}
						i ++;
					}
				}
				else
					MagicAttackTimer --;
				MagicAttackActive --;
				if ( MagicAttackActive == 0 )
					MagicRegen ++;
			}
			MagicAttackDegree += 3;
			if(MagicAttackDegree < -360)MagicAttackDegree+=360; //Wrap if below -360. ???? i dont know
			else if(MagicAttackDegree > 360)MagicAttackDegree-=360; //Wrap if above 360. ???? i dont know
			for (int i = 0; i < 20; i++) {
				if ( MagicAttackCenterX[i] <= -70 || MagicAttackCenterY[i] <= -70 || MagicAttackCenterX[i] >= 255+70 || MagicAttackCenterY[i] >= 175+70 ) {
					MagicAttackCenterX[i] = -1;
					MagicAttackCenterY[i] = -1;
				}
				if ( MagicAttackCenterX[i] != -1 || MagicAttackCenterY[i] != -1 ) {
					if ( MagicAttackRadius[i] < 32 )
						MagicAttackRadius[i] += 2;
					else if ( MagicAttackDir[i] == DIR_UP )
						MagicAttackCenterY[i] -= 3;
					else if ( MagicAttackDir[i] == DIR_RIGHT )
						MagicAttackCenterX[i] += 3;
					else if ( MagicAttackDir[i] == DIR_DOWN )
						MagicAttackCenterY[i] += 3;
					else if ( MagicAttackDir[i] == DIR_LEFT )
						MagicAttackCenterX[i] -= 3;
				}
			}
			for (int i = 0; i < 150; i++) {
				if ( MagicAttack[i]->isValid() ) {
					if (-16 <= MagicAttack[i]->X && MagicAttack[i]->X < 272 && -16 <= MagicAttack[i]->Y && MagicAttack[i]->Y < 192)
						MagicAttack[i]->DeadState = WDS_ALIVE;
					int attached = MagicAttackAttachedTo[i];
					MagicAttack[i]->X = MagicAttackCenterX[attached] + MagicAttackRadius[attached]*Cos(MagicAttackDegree+360/12*MagicAttackNum[i]);
					MagicAttack[i]->Y = MagicAttackCenterY[attached] + MagicAttackRadius[attached]*Sin(MagicAttackDegree+360/12*MagicAttackNum[i]);
				}
			}
			
			if ( ((GetEquipmentA() == 156 && Link->PressA) || (GetEquipmentB() == 156 && Link->PressB)) ) { //MegaWhistle
				if ( MegaWhistleActive == 0 && Game->Counter[CR_MAGIC] >= 64 ) {
					Game->Counter[CR_MAGIC] -= 64;
					MagicRegen --;
					Game->PlaySound(33);
					MegaWhistleActive = 120;
				}
			}
			if ( MegaWhistleActive > 0 ) {
				if ( MegaWhistleActive == 120 || MegaWhistleActive == 100 || MegaWhistleActive == 80 ||
				MegaWhistleActive == 40 || MegaWhistleActive == 30 || MegaWhistleActive == 20) {
					int randomangle = Rand(0, 11);
					for (int i = 0; i < 24; i++) {
						lweapon Note = CreateLWeaponAt(LW_BEAM, Link->X, Link->Y);
						Note->Angular = true;
						Note->Angle = DegtoRad(360/24*i+randomangle);
						Note->Dir = RadianAngleDir8(WrapAngle(Note->Angle));
						Note->Damage = 2 + MegaWhistleDDBonus +GlobalVars[Ascension];
						Note->Step = 250;
						Note->UseSprite(Choose(102, 103, 104));
					}
				}
				MegaWhistleActive --;
				if ( MegaWhistleActive == 0 )
					MagicRegen ++;
			}

			if ( MagicRegen == 0 && Link->Z == 0 ) {
				Game->Counter[CR_MAGIC] += 1;
				if ( Game->Counter[CR_MAGIC] > Game->MCounter[CR_MAGIC] )
					Game->Counter[CR_MAGIC] = Game->MCounter[CR_MAGIC];
			}
			
			if ( CursorDungeon && DungeonHoldPiece == 0 )
				Screen->FastTile(6, Link->InputMouseX-6, Link->InputMouseY-2, 23500, 7, OP_OPAQUE);
			if ( CursorDungeon && DungeonHoldPiece != 0 )
				Screen->FastTile(6, Link->InputMouseX-6, Link->InputMouseY-2, 23501, 7, OP_OPAQUE);
			
			if ( (Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] == triggerOff || Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] == 1006 || Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] == 725) && Link->Z == 0 && Link->CollDetection ) {
				Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] ++;
				numberOfTriggers --;
			}
			if ( numberOfTriggers == 0 && roomHasTriggers ) {
				Game->PlaySound(27);
				Screen->TriggerSecrets();
				if ( Game->GetCurScreen() != 0x42 || Game->GetCurDMap() != 16 )
					Screen->State[ST_SECRET] = true;
				roomHasTriggers = false;
			}
			if ( Screen->ComboD[CurrentMousePos] == 664 && LeftClick ) {
				if ( numberOfCrystals != 1 )
					Game->PlaySound(66);
				Screen->ComboD[CurrentMousePos] = 665;
				numberOfCrystals --;
			}
			if ( numberOfCrystals == 0 && roomHasCrystals ) {
				Game->PlaySound(27);
				Screen->TriggerSecrets();
				Screen->State[ST_SECRET] = true;
				roomHasCrystals = false;
			}
			
			if ( (((Screen->ComboD[CurrentMousePos] == 671 || Screen->ComboD[CurrentMousePos] == 675) && CurrentMousePos == 141)
			|| (Screen->ComboD[CurrentMousePos] == 671 && CurrentMousePos == 133)) && LeftClick ) {
				Game->PlaySound(66);
				if ( Screen->ComboD[CurrentMousePos] == 671 )
					Screen->ComboD[CurrentMousePos] = 675;
				else
					Screen->ComboD[CurrentMousePos] = 671;
				for (int i = 0; i < 175; i++) {
					if ( Screen->ComboD[i] == 625 && Screen->ComboC[i] == 5 )
						Screen->ComboD[i] = 979;
					else if ( Screen->ComboD[i] == 979 )
						Screen->ComboD[i] = 625;
				}
			}
			if ( Screen->ComboD[133] == 675 ) {
				if ( that1crystaltimer == 60 ) {
					Screen->ComboD[133] = 671;
					for (int i = 0; i < 175; i++) {
						if ( Screen->ComboD[i] == 625 && Screen->ComboC[i] == 5 )
							Screen->ComboD[i] = 979;
					}
					that1crystaltimer = 0;
				}
				else
					that1crystaltimer ++;
			}
			
			if ( !EntryMessage[0] && Game->GetCurLevel() == 1 ) {
				EntryMessage[0] = true;
				Screen->Message(33);
			}
			if ( !EntryMessage[1] && Game->GetCurLevel() == 2 ) {
				EntryMessage[1] = true;
				Screen->Message(34);
			}
			if ( !EntryMessage[2] && Game->GetCurLevel() == 3 ) {
				EntryMessage[2] = true;
				Screen->Message(35);
			}
			if ( !EntryMessage[3] && Game->GetCurLevel() == 4 ) {
				EntryMessage[3] = true;
				Screen->Message(60);
			}
			
			if ( CursorDungeon ) {
				for (int i = 0; i < 175; i++) {
					if ( Screen->ComboD[i] >= 668 && Screen->ComboD[i] <= 674 ) {
						if ( Screen->ComboD[i] <= 670 && Distance(ComboX(i)+8, ComboY(i)+8, Link->InputMouseX, Link->InputMouseY) <= 40 )
							Screen->ComboD[i] = 673;
						if ( Screen->ComboD[i] >= 672 && Distance(ComboX(i)+8, ComboY(i)+8, Link->InputMouseX, Link->InputMouseY) > 40 )
							Screen->ComboD[i] = 669;
					}
					
				}			
			}
			
			if ( ArrowShooterCounter == 45 ) {
				ArrowShooterCounter = 0;
				for (int i = 0; i < 175; i++) {
					if ( Screen->ComboD[i] >= 982 && Screen->ComboD[i] <= 987 ) {
						lweapon ArrowShot = CreateLWeaponAt(LW_ARROW, ComboX(i), ComboY(i));
						ArrowShot->Dir = DIR_DOWN;
						ArrowShot->CollDetection = false;
						ArrowShot->Step = 150;
						ArrowShot->UseSprite(96);
					}
					if ( Screen->ComboD[i] >= 988 && Screen->ComboD[i] <= 993 ) {
						lweapon ArrowShot = CreateLWeaponAt(LW_ARROW, ComboX(i), ComboY(i));
						ArrowShot->Dir = DIR_LEFT;
						ArrowShot->CollDetection = false;
						ArrowShot->Step = 150;
						ArrowShot->UseSprite(97);
					}
					if ( Screen->ComboD[i] >= 994 && Screen->ComboD[i] <= 999 ) {
						lweapon ArrowShot = CreateLWeaponAt(LW_ARROW, ComboX(i), ComboY(i));
						ArrowShot->Dir = DIR_UP;
						ArrowShot->CollDetection = false;
						ArrowShot->Step = 150;
						ArrowShot->UseSprite(94);
					}
					if ( Screen->ComboD[i] >= 1000 && Screen->ComboD[i] <= 1005 ) {
						lweapon ArrowShot = CreateLWeaponAt(LW_ARROW, ComboX(i), ComboY(i));
						ArrowShot->Dir = DIR_RIGHT;
						ArrowShot->CollDetection = false;
						ArrowShot->Step = 150;
						ArrowShot->UseSprite(95);
					}
				}
			}
			else
				ArrowShooterCounter ++;
			
			for (int i = 1; i <= Screen->NumLWeapons(); i++) {
				lweapon wpn = Screen->LoadLWeapon(i);
				if ( !wpn->CollDetection ) {
					if ( wpn->ID == LW_ARROW ) {
						if ( RectCollision(wpn->X+5, wpn->Y+5, wpn->X+10, wpn->Y+10, Link->X, Link->Y+2, Link->X+15, Link->Y+15) ) {
							eweapon e = FireEWeapon(EW_SCRIPT10, Link->X+InFrontX(Link->Dir, 12), Link->Y+InFrontY(Link->Dir, 12), 0, 0, 4, -1, -1, EWF_UNBLOCKABLE);
							e->Dir = Link->Dir;
							e->DrawYOffset = -1000;
							SetEWeaponLifespan(e, EWL_TIMER, 1);
							SetEWeaponDeathEffect(e, EWD_VANISH, 0);
						}
					}
				}
				if ( wpn->ID == LW_SCRIPT9 ) { //mouse click
					if ( wpn->DrawXOffset == -1000 )
						wpn->DrawXOffset = -999;
					else
						wpn->DeadState = 0;
				}
				//if ( wpn->DeadState == WDS_BEAMSHARDS-1 )
				//	wpn->DeadState = 0;
			}
			
			bool playbrangsfx;
			for (int i = 1; i <= Screen->NumEWeapons(); i++) {
				eweapon wpn = Screen->LoadEWeapon(i);
				if ( wpn->OriginalTile == 21340 ) {
					if ( BoomerangSFX == 8 )
						playbrangsfx = true;
				}
			}
			
			if ( playbrangsfx )
				Game->PlaySound(68);
			if ( BoomerangSFX > 8 )
				BoomerangSFX = 0;
			else
				BoomerangSFX ++;
			
			for (int i = 1; i <= Screen->NumItems(); i++) { //for all items
				item itm = Screen->LoadItem(i);
				if ( itm->ID == 2 ) {
					if ( Link->Item[158] ) {
						item newheart = CreateItemAt(159, itm->X, itm->Y);
						itm->X = -1000;
						SetItemPickup(newheart, IP_TIMEOUT, true);
					}
				}
			}
			
			for (int i = 0; i < 10; i++) {
				if ( GibdosCurseX[i] > 0 && GibdosCurseY[i] > 0 ) {
					float angle = Angle(GibdosCurseX[i], GibdosCurseY[i], Link->X, Link->Y);
					GibdosCurseX[i] += VectorX(1, angle);
					GibdosCurseY[i] += VectorY(1, angle);
					if ( RectCollision(GibdosCurseX[i]+4, GibdosCurseY[i]+4, GibdosCurseX[i]+11, GibdosCurseY[i]+11, Link->X, Link->Y, Link->X+15, Link->Y+15) ) {
						GibdosCurseX[i] = 0;
						GibdosCurseY[i] = 0;
						if ( GibdosCurse == -1 && Link->HP > 4 ) {
							Game->PlaySound(67);
							GibdosCurse = Link->HP - 4;
							Link->HP -= GibdosCurse;
						}
					}
					else
						Screen->FastTile(2, GibdosCurseX[i], GibdosCurseY[i], 1958, 7, OP_TRANS);
				}
			}
			
			if ( CurrentFramesCounter == 5 ) {
				for (int i = 1; i <= Screen->NumNPCs(); i++) {
					npc enem = Screen->LoadNPC(i);
					if ( enem->ID == 54 ) { //gibdo
						int gibdook;
						while(gibdook!=-1){
							if ( GibdosCurseX[gibdook] <= 0 && GibdosCurseY[gibdook] <= 0 ) {
								GibdosCurseX[gibdook] = GetEnemyProperty(enem, ENPROP_X);
								GibdosCurseY[gibdook] = GetEnemyProperty(enem, ENPROP_Y);
								gibdook = -1;
							}
							else
								gibdook ++;
						}
					}
				}
			}
			
			bool theresagibdo;
			for (int i = 1; i <= Screen->NumNPCs(); i++) {
				npc enem = Screen->LoadNPC(i);
				if ( enem->ID == 54 )
					theresagibdo = true;
			}
			
			if ( GibdosCurse > 0 && !theresagibdo ) {
				Link->HP += GibdosCurse;
				GibdosCurse = 0;
				if ( Link->HP > Link->MaxHP )
					Link->HP = Link->MaxHP;
			}
			
			if ( GibdosCurse > 0 )
				Screen->FastTile(4, Link->X, Link->Y, 1958, 7, OP_TRANS);
			
			if ( CursorDungeon && LeftClick ) {
				lweapon ClickHit = CreateLWeaponAt(LW_SCRIPT9, Link->InputMouseX-2, Link->InputMouseY-2);
				ClickHit->Damage = 1;
				ClickHit->Dir = -1;
				ClickHit->HitWidth = 4;
				ClickHit->HitHeight = 4;
				ClickHit->DrawXOffset = -1000;
			}
			
			if ( PowerColour > 0 ) {
				if ( ColourSparkleTimer >= 12 ) {
					ColourSparkleTimer = Rand(0, 5);
					int done;
					while(done != -1){
						if ( ColourSparkle[done]->isValid() )
							done ++;
						else {
							ColourSparkle[done] = CreateLWeaponAt(LW_SPARKLE, Link->X+Rand(-8, 8), Link->Y+Rand(-8, 8));
							ColourSparkle[done]->UseSprite(109);
							done = -1;
						}
						if ( done == 10 )
							done = -1;
					}
				}
				else
					ColourSparkleTimer ++;
				
				for (int i = 0; i < 10; i++) {
					if ( ColourSparkle[i]->isValid() )
						Screen->FastTile(4, ColourSparkle[i]->X+(GlobalVars[LinkMoving0]*GlobalVars[LinkMoving2]), ColourSparkle[i]->Y+(GlobalVars[LinkMoving1]*GlobalVars[LinkMoving2]), 27544+((PowerColour-1)*4)+ColourSparkle[i]->Tile-20, 8, OP_OPAQUE);
				}
			}
			
			if ( PowerColour == 4 ) {
				LinkMovement_SetLinkSpeedBoost(2);
			}
			
			if ( !MooshPit_OnFFC(Link->X, Link->Y) && Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] >= 704 && Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] <= 707 && Link->Z == 0 ) {
				if ( Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] == 704 )
					LinkMovement_Push(0, -1.5*extrapush);
				if ( Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] == 705 )
					LinkMovement_Push(1.5*extrapush, 0);
				if ( Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] == 706 )
					LinkMovement_Push(0, 1.5*extrapush);
				if ( Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] == 707 )
					LinkMovement_Push(-1.5*extrapush, 0);
			}
			
			if ( Link->Action == LA_GOTHURTLAND )
				extrapush = 3;
			else if ( extrapush > 1 )
				extrapush -= 0.1;
			
			if ( Game->GetCurMap() == 13 && Game->GetCurScreen() == 0x22 && !Link->Item[165] ) {
				Game->SetScreenState(13, 0x13, ST_SECRET, false);
				Game->SetScreenState(13, 0x12, ST_SECRET, false);
			}
			
			CurrentFramesCounter ++;
			Waitframe();
		}
	}
}

item script HeartPotion{
	void run(){
		for (int i = 0; i < 12; i++) {
			item Fairy = Screen->CreateItem(2);
			SetItemPickup(Fairy, IP_TIMEOUT, true);
			Fairy->X = Link->X + 48*Cos(360/12*i);
			Fairy->Y = Link->Y + 48*Sin(360/12*i);
		}
	}
}

//D0 is the time in frames for how long the item rain effect lasts
item script RupeeFlowerPickup{
	void run(int d0){
		RupeeFlower_ActiveFrames = d0;
	}
}
item script SwordPickup{
	void run(){
		if ( Game->Counter[CR_BOMBS] == 0 ) {
			Link->Item[149] = true;
			Link->Item[150] = true;
			if ( GetEquipmentB() == 143 )
				Link->SelectBWeapon(DIR_LEFT);
			if ( GetEquipmentA() != 143 )
				Link->SelectAWeapon(DIR_LEFT);
			Link->Item[149] = false;
			Link->Item[150] = false;
			Screen->Message(26);
		}
	}
}
item script RefillingPotionPickup{
	void run(){
		Link->Item[160] = true;
		Link->Item[161] = true;
		Link->Item[29] = false;
		Link->Item[30] = false;
		Screen->Message(56);
	}
}
item script AscensionRingPickup{
	void run(){
		GlobalVars[Ascension] = 1;
		Screen->Message(73);
	}
}

item script PlaySound{
	void run(){
		Game->PlaySound(61);
	}
}

item script GotRupee1{
	void run(){
		GotRupee1 = true;
	}
}
item script GotRupee5{
	void run(){
		GotRupee5 = true;
	}
}
item script GotRupee20{
	void run(){
		GotRupee20 = true;
	}
}
item script GotHeart{
	void run(){
		GotHeart = true;
	}
}
item script GotFairy{
	void run(){
		GotFairy = true;
	}
}
item script GotKey{
	void run(){
		int rngmessage;
		while ( rngmessage == 0 || (rngmessage >= 10 && rngmessage <= 11) )
			rngmessage = Rand(4, 25);
		if ( rngmessage == 18 && Game->Counter[CR_RUPEES] > Game->MCounter[CR_RUPEES] - 50 )
			Game->DCounter[CR_RUPEES] += Game->MCounter[CR_RUPEES] - Game->Counter[CR_RUPEES];
		else if ( rngmessage == 18 )
			Game->DCounter[CR_RUPEES] += 50;
		Screen->Message(rngmessage);
	}
}
item script GotBombs{
	void run(){
		GotBombs = true;
	}
}
item script GotRupee10{
	void run(){
		GotRupee10 = true;
	}
}
item script GotArrows{
	void run(){
		GotArrows = true;
	}
}
item script Message{
	void run(int m){
		Screen->Message(m);
	}
}

item script SilverRupee{
	void run(){
		SilverRupees ++;
		if ( SilverRupees == 1 )
			Game->PlaySound(70);
		if ( SilverRupees == 2 )
			Game->PlaySound(71);
		if ( SilverRupees == 3 )
			Game->PlaySound(72);
		if ( SilverRupees == 4 )
			Game->PlaySound(73);
		if ( SilverRupees == 5 ) {
			Game->PlaySound(27);
			Game->SetScreenState(1, 0x1A, ST_SECRET, true);
		}
	}
}

ffc script TrippyFloor //by Mero
{
	void run(int bitmap, float step, int combo, int cset)
	{
		if ( Game->GetCurMap() == 3 && Game->GetCurScreen() == 0x73 && Link->Y > 80 )
			Waitframe();
		int radius = 40;
		int speed = 2;
		int angle = -1;
		int radius2 = 24;
		int angle2 = 45;
		if(radius2 == 0) radius2 = radius; //Circle
		if(angle < 0) angle = Rand(360); //Random Start
		int cx = this->X;
		int cy = this->Y;
		Screen->SetRenderTarget(bitmap);
		//Screen->Rectangle(0, 0, 0, 255, 175, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
		for(int i; i < 16; i++)
			for(int j; j < 16; j++)
				Screen->FastCombo(3, 16*i, 16*j, combo, cset, OP_OPAQUE);
		Screen->DrawBitmap(3, bitmap, 0, 0, 256, 256, 256, 0, 256, 256, 0, false);
		Screen->DrawBitmap(3, bitmap, 0, 0, 512, 256, 0, 256, 512, 256, 0, false);
		Screen->SetRenderTarget(RT_SCREEN);
		float tangle = Randf(360);

		int LinkTripTimer = Rand(30, 180);
		int LinkTrip;
		while(true)
		{
			if ( Link->Z == 0 && LinkTrip == 0 && (Link->InputUp || Link->InputRight || Link->InputDown || Link->InputLeft)
			&& (Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] == 0 || Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] == 1) ) {
				if ( LinkTripTimer == 0 ) {
					Game->PlaySound(60);
					LinkTrip = 31;
					LinkTripTimer = Rand(30, 180);
				}
				LinkTripTimer --;
			}
			if ( LinkTrip > 0 ) {
				Link->Invisible = true;
				NoAction();
				Screen->DrawTile(2, Link->X, Link->Y, 31823, 1, 1, 6, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
				LinkTrip --;
			}
			else
				Link->Invisible = false;

			angle += speed;
			if(angle < -360)angle+=360; //Wrap if below -360.
			else if(angle > 360)angle-=360; //Wrap if above 360.
			if(angle2==0)
			{
				this->X = cx + radius*Cos(angle);
				this->Y = cy + radius2*Sin(angle);
			}
			else //Rotate at center.
			{
				this->X = cx + radius*Cos(angle)*Cos(angle2) - radius2*Sin(angle)*Sin(angle2);
				this->Y = cy + radius2*Sin(angle)*Cos(angle2) + radius*Cos(angle)*Sin(angle2);
			}
			Screen->DrawBitmap(3, bitmap, 0, 0, 512, 512, this->X-128, this->Y-168, 512, 512, tangle, false);
			tangle += step;
			if(tangle<-360) tangle+=360;
			else if(tangle>=360) tangle-=360;
			Waitframe();
		}
	}
}

ffc script Words{
	void run(int SpecialRoom){
		LinkHurtFrames = 0;
		GotRupee1 = false;
		GotRupee5 = false;
		GotRupee20 = false;
		GotHeart = false;
		GotFairy = false;
		GotBombs = false;
		GotRupee10 = false;
		GotArrows = false;

		int WordsNumber[100];
		int WordsX[100];
		int WordsY[100];
		int Words1[] = "Link got 1 rupee!";
		int Words2[] = "Link got 5 rupees!";
		int Words3[] = "Link got 20 rupees!";
		int Words4[] = "Link got a heart!";
		int Words5[] = "Link got a fairy!";
		
		int Words7[] = "Link took damage.";
		int Words8[] = "Welcome!";
		int Words9[] = "Careful!";
		int Words10[] = "hi eddy";
		int Words11[] = "Link got 4 bombs!";
		int Words12[] = "Link got 10 rupees!";
		int Words13[] = "Link got 10 arrows!";
		int Words14[] = "Link is terrified!";
		int Words15[] = "Link fell...";
		int Words16[] = "One";
		int Words17[] = "Two";
		int Words18[] = "Three";
		int Words19[] = "Four";
		int Words20[] = "Five";
		int Words21[] = "Six";

		int LinkHurtCooldown;

		int Careful = Rand(1, 100);
		if ( Careful <= 30 )
			Careful = Choose(Rand(60, 300), Rand(900, 1140));
		else
			Careful = -1;

		int HiEddy = Rand(1, 100);
		if ( HiEddy <= 15 )
			HiEddy = Choose(Rand(60, 300), Rand(900, 1140));
		else
			HiEddy = -1;

		if ( SpecialRoom == 1 && Link->Y > 136 ) {
			Careful = -1;
			HiEddy = -1;
			WordsNumber[0] = 8;
			WordsX[0] = 258;
			WordsY[0] = 64;
		}
		
		int Terrifying = -1;
		if ( SpecialRoom == 2 ) {
			Careful = -1;
			HiEddy = -1;
			Terrifying = 60;
		}
		
		int WordHints = -1;
		if ( SpecialRoom == 3 ) {
			Careful = -1;
			HiEddy = -1;
			WordHints = 0;
		}
		
		bool Fallin;
		while(true){
			if ( GotRupee1 ) {
				GotRupee1 = false;
				int i;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 1;
						WordsX[i] = 256;
						WordsY[i] = Rand(32, 128);
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( GotRupee5 ) {
				GotRupee5 = false;
				int i;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 2;
						WordsX[i] = 256;
						WordsY[i] = Rand(32, 128);
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( GotRupee20 ) {
				GotRupee20 = false;
				int i;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 3;
						WordsX[i] = 256;
						WordsY[i] = Rand(32, 128);
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( GotHeart ) {
				GotHeart = false;
				int i;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 4;
						WordsX[i] = 256;
						WordsY[i] = Rand(32, 128);
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( GotFairy ) {
				GotFairy = false;
				int i;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 5;
						WordsX[i] = 256;
						WordsY[i] = Rand(32, 128);
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( GotBombs ) {
				GotBombs = false;
				int i;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 11;
						WordsX[i] = 256;
						WordsY[i] = Rand(32, 128);
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( GotRupee10 ) {
				GotRupee10 = false;
				int i;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 12;
						WordsX[i] = 256;
						WordsY[i] = Rand(32, 128);
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( GotArrows ) {
				GotArrows = false;
				int i;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 13;
						WordsX[i] = 256;
						WordsY[i] = Rand(32, 128);
						i = -1;
					}
					else
						i ++;
				}
			}

			if ( LinkHurtFrames == 1 && LinkHurtCooldown == 0 ) {
				LinkHurtCooldown = 120;
				int i;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 7;
						WordsX[i] = 256;
						WordsY[i] = Rand(32, 128);
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( LinkHurtCooldown > 0 )
				LinkHurtCooldown --;

			if ( Careful == 0 ) {
				Careful = -1;
				int i;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 9;
						WordsX[i] = 256;
						WordsY[i] = Rand(32, 128);
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( Careful > 0 )
				Careful --;
			if ( HiEddy == 0 ) {
				HiEddy = -1;
				int i;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 10;
						WordsX[i] = 256;
						WordsY[i] = Rand(32, 128);
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( HiEddy > 0 )
				HiEddy --;
			
			if ( MooshPit[MP_FALLSTATE] > 0 && !Fallin ) {
				Fallin = true;
				int i;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 15;
						WordsX[i] = 256;
						WordsY[i] = Rand(32, 128);
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( MooshPit[MP_FALLSTATE] == 0 && Fallin )
				Fallin = false;
			
			if ( Terrifying == 0 ) {
				int i;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 14;
						WordsX[i] = 256;
						WordsY[i] = 48+4;
						i = -1;
					}
					else
						i ++;
				}
				i = 0;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 14;
						WordsX[i] = 256;
						WordsY[i] = 64+4;
						i = -1;
					}
					else
						i ++;
				}
				i = 0;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 14;
						WordsX[i] = 256;
						WordsY[i] = 80+4;
						i = -1;
					}
					else
						i ++;
				}
				i = 0;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 14;
						WordsX[i] = 256;
						WordsY[i] = 96+4;
						i = -1;
					}
					else
						i ++;
				}
				i = 0;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 14;
						WordsX[i] = 256;
						WordsY[i] = 112+4;
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( Terrifying >= 0 )
				Terrifying --;
			
			if ( WordHints == 60 ) {
				int i = 0;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 16;
						WordsX[i] = 256;
						WordsY[i] = 48+4;
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( WordHints == 120 ) {
				int i = 0;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 17;
						WordsX[i] = 256;
						WordsY[i] = 112+4;
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( WordHints == 180 ) {
				int i = 0;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 18;
						WordsX[i] = 256;
						WordsY[i] = 80+4;
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( WordHints == 240 ) {
				int i = 0;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 19;
						WordsX[i] = 256;
						WordsY[i] = 112+4;
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( WordHints == 300 ) {
				int i = 0;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 21;
						WordsX[i] = 256;
						WordsY[i] = 80+4;
						i = -1;
					}
					else
						i ++;
				}
			}
			if ( WordHints == 360 ) {
				int i = 0;
				while(i != -1){
					if ( WordsNumber[i] == 0 ) {
						WordsNumber[i] = 20;
						WordsX[i] = 256;
						WordsY[i] = 48+4;
						i = -1;
					}
					else
						i ++;
				}
				WordHints = -1;
			}
			if ( WordHints >= 0 )
				WordHints ++;

			for (int i = 1; i <= Screen->NumEWeapons(); i++) { //for all eweapons
				eweapon wpn = Screen->LoadEWeapon(i);
				if ( wpn->ID == EW_SCRIPT1 && wpn->Tile == 21 ) { //words
					if ( wpn->CSet == 0 )
						wpn->CSet = 1;
					else
						wpn->DeadState = 0;
				}
			}

			for (int i = 0; i < 100; i++) {
				if ( WordsNumber[i] > 0 ) {
					WordsX[i] --;
					if ( WordsX[i] < -160 )
						WordsNumber[i] = 0;
				}
				if ( WordsNumber[i] == 1 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words1, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words1, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 8);
				}
				if ( WordsNumber[i] == 2 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words2, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words2, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 9);
				}
				if ( WordsNumber[i] == 3 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words3, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words3, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 9);
				}
				if ( WordsNumber[i] == 4 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words4, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words4, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 8);
				}
				if ( WordsNumber[i] == 5 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words5, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words5, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 8);
				}
				
				if ( WordsNumber[i] == 7 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words7, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words7, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 8);
				}
				if ( WordsNumber[i] == 8 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words8, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words8, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 4);
				}
				if ( WordsNumber[i] == 9 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words9, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words9, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 4);
				}
				if ( WordsNumber[i] == 10 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words10, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words10, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 3);
				}
				if ( WordsNumber[i] == 11 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words11, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words11, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 8);
				}
				if ( WordsNumber[i] == 12 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words12, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words12, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 9);
				}
				if ( WordsNumber[i] == 13 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words13, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words13, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 9);
				}
				if ( WordsNumber[i] == 14 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words14, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words14, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 9);
					WordsHitbox(WordsX[i], WordsY[i]-8, 9);
				}
				if ( WordsNumber[i] == 15 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words15, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words15, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 5);
				}
				if ( WordsNumber[i] == 16 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words16, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words16, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 2);
				}
				if ( WordsNumber[i] == 17 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words17, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words17, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 2);
				}
				if ( WordsNumber[i] == 18 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words18, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words18, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 3);
				}
				if ( WordsNumber[i] == 19 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words19, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words19, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 2);
				}
				if ( WordsNumber[i] == 20 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words20, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words20, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 2);
				}
				if ( WordsNumber[i] == 21 ) {
					Screen->DrawString(6, WordsX[i]+1, WordsY[i]+1, FONT_Z1, 7, -1, TF_NORMAL, Words21, OP_OPAQUE);
					Screen->DrawString(6, WordsX[i], WordsY[i], FONT_Z1, 1, -1, TF_NORMAL, Words21, OP_OPAQUE);
					WordsHitbox(WordsX[i], WordsY[i], 2);
				}
			}
			Waitframe();
		}
	}
}

void WordsHitbox(int x, int y, int num){
	while (num > 0){
		eweapon wpn = Screen->CreateEWeapon(EW_SCRIPT1);
		wpn->X = x - 16 + num * 16;
		wpn->Y = y;
		wpn->Damage = 4;
		wpn->HitHeight = 8;
		wpn->UseSprite(93);
		wpn->Dir = DIR_LEFT;
		num --;
	}
}

void LREx1Ex2ItemSwitch()
{
	if (Link->PressL && Link->Action != LA_SCROLLING)
	{
		Link->SelectBWeapon(DIR_LEFT);
	}
	if (Link->PressR && Link->Action != LA_SCROLLING)
	{
		Link->SelectBWeapon(DIR_RIGHT);
	}
	if (Link->PressEx1 && Link->Action != LA_SCROLLING)
	{
		Link->SelectAWeapon(DIR_LEFT);
	}
	if (Link->PressEx2 && Link->Action != LA_SCROLLING)
	{
		Link->SelectAWeapon(DIR_RIGHT);
	}
}

bool MooshPit_OnPit(int LinkX, int LinkY){
	if(MooshPit_OnFFC(LinkX, LinkY)){
		return false;
	}
	
	bool sideview;
	if(Screen->Flags[SF_ROOMTYPE]&100b)
		sideview = true;
	//wew lad
	int width = MOOSHPIT_LINKHITBOXWIDTH;
	int height = MOOSHPIT_LINKHITBOXHEIGHT;
	for(int x=0; x<=1; x++){
		for(int y=0; y<=1; y++){
			int X; int Y;
			if(sideview){ //Hitbox functions differently in sideview
				width = MOOSHPIT_SIDEVIEW_LINKHITBOXWIDTH;
				height = MOOSHPIT_SIDEVIEW_LINKHITBOXHEIGHT;
				X = LinkX+7-width/2+width;
				Y = LinkY+7-height/2+height;
			}
			else{
				X = LinkX+7-width/2+width;
				Y = LinkY+11-height/2+height;
			}
			
			//If one corner of Link's hitbox isn't on a pit, return false
			if(Screen->ComboT[ComboAt(X, Y)]!=CT_HOLELAVA && Screen->ComboT[ComboAt(X, Y)]!=CT_WATER){
				return false;
			}
		}
	}
	return true;
}

bool MooshPit_OnFFC(int LinkX, int LinkY){
	for(int i=1; i<=32; i++){ //Cycle through every FFC
		ffc f = Screen->LoadFFC(i);
		//Check if the FFC is solid
		if(f->Data>0&&!f->Flags[FFCF_CHANGER]&&!f->Flags[FFCF_ETHEREAL]){
			//Check if Link collides with the FFC
			if(RectCollision(LinkX+4, LinkY+9, LinkX+11, LinkY+14, f->X, f->Y, f->X+f->EffectWidth-1, f->Y+f->EffectHeight-1)){
				return true;
			}
		}
	}
	//If Link doesn't collide with any FFC, return false
	return false;
}

void MooshPit_Init(){
	MooshPit[MP_LASTX] = Link->X;
	MooshPit[MP_LASTY] = Link->Y;
	MooshPit[MP_LASTDMAP] = Game->GetCurDMap();
	MooshPit[MP_LASTSCREEN] = Game->GetCurDMapScreen();
	MooshPit[MP_ENTRYX] = Link->X;
	MooshPit[MP_ENTRYY] = Link->Y;
	MooshPit[MP_ENTRYDMAP] = Game->GetCurDMap();
	MooshPit[MP_ENTRYSCREEN] = Game->GetCurDMapScreen();
	MooshPit[MP_FALLSTATE] = 0;
	MooshPit[MP_FALLTIMER] = 0;
	Link->CollDetection = true;
	Link->Invisible = false;
}

void MooshPit_Update(){
	bool isWarp;
	if(Screen->Flags[SF_MISC]&(1<<SF_MISC_MOOSHPITWARP))
		isWarp = true;
	
	bool sideview;
	if(Screen->Flags[SF_ROOMTYPE]&100b)
		sideview = true;
	
	if(Link->Action!=LA_SCROLLING){
		//Update the entry point whenever the screen changes
		if(MooshPit[MP_ENTRYDMAP]!=Game->GetCurDMap()||MooshPit[MP_ENTRYSCREEN]!=Game->GetCurDMapScreen()){
			MooshPit[MP_ENTRYX] = Link->X;
			MooshPit[MP_ENTRYY] = Link->Y;
			MooshPit[MP_ENTRYDMAP] = Game->GetCurDMap();
			MooshPit[MP_ENTRYSCREEN] = Game->GetCurDMapScreen();
		}
		
		if(MooshPit[MP_FALLSTATE]==0){ //Not falling in pit
			if(Link->Z<=0&&MooshPit_OnPit(Link->X, Link->Y)){ //If Link steps on a pit
				int underLink;
				if(!sideview)
					underLink = ComboAt(Link->X+8, Link->Y+12);
				else
					underLink = ComboAt(Link->X+8, Link->Y+8);
			
				lweapon fall;
				
				Link->X = ComboX(underLink);
				Link->Y = ComboY(underLink);
				
				//Check if the combo is lava
				if(Screen->ComboT[underLink] == CT_WATER){
					//Play sound and display animation
					Game->PlaySound(SFX_FALLLAVA);
					fall = CreateLWeaponAt(LW_SCRIPT10, Link->X, Link->Y);
					fall->UseSprite(SPR_FALLLAVA);
					fall->CollDetection = false;
					fall->DeadState = fall->ASpeed*fall->NumFrames;
				
					//Mark as lava damage
					MooshPit[MP_DAMAGETYPE] = 1;
				}
				//Otherwise it's a pit
				else{
					//Play sound and display animation
					Game->PlaySound(SFX_FALLHOLE);
					fall = CreateLWeaponAt(LW_SCRIPT10, Link->X, Link->Y);
					fall->UseSprite(SPR_FALLHOLE);
					fall->CollDetection = false;
					fall->DeadState = fall->ASpeed*fall->NumFrames;
				
					//Mark as hole damage
					MooshPit[MP_DAMAGETYPE] = 0;
				}
				
				MooshPit[MP_FALLX] = Link->X;
				MooshPit[MP_FALLY] = Link->Y;
				
				//Cooldown should last as long as the fall animation
				MooshPit[MP_FALLSTATE] = 1;
				MooshPit[MP_FALLTIMER] = fall->DeadState;
				
				//Render Link invisible and intangible
				Link->Invisible = true;
				Link->CollDetection = false;
				
				NoAction();
			}
			else{ //All other times, while Link is on solid ground, record Link's last position
				if(sideview){
					//Link has no Z value in sideview, so we check if he's on a platform instead
					if(OnSidePlatform(Link->X, Link->Y)){
						MooshPit[MP_LASTDMAP] = Game->GetCurDMap();
						MooshPit[MP_LASTSCREEN] = Game->GetCurDMapScreen();
						MooshPit[MP_LASTX] = Link->X;
						MooshPit[MP_LASTY] = Link->Y;
					}
				}
				else{
					if(Link->Z<=0){
						MooshPit[MP_LASTDMAP] = Game->GetCurDMap();
						MooshPit[MP_LASTSCREEN] = Game->GetCurDMapScreen();
						MooshPit[MP_LASTX] = Link->X;
						MooshPit[MP_LASTY] = Link->Y;
					}
				}
			}
		}
		else if(MooshPit[MP_FALLSTATE]==1){ //Falling animation
			if(MooshPit[MP_FALLTIMER]>0)
				MooshPit[MP_FALLTIMER]--;
		
			Link->Jump = 0;
			Link->Z = 0;
			
			//Keep Link invisible just in case
			Link->Invisible = true;
			Link->CollDetection = false;
			NoAction();
			if(MooshPit[MP_FALLTIMER]==0){
				if(!isWarp||MooshPit[MP_DAMAGETYPE]==1){ //If the pit isn't a warp, deal damage and move Link back to the return point
					//If the entry would dump Link back in the pit, dump him out at the failsafe position
					if(MooshPit_OnPit(MooshPit[MP_ENTRYX], MooshPit[MP_ENTRYY])){
						Link->X = MooshPit[MP_LASTX];
						Link->Y = MooshPit[MP_LASTY];
						//If the failsafe position was on a different screen, warp there
						if(Game->GetCurDMap()!=MooshPit[MP_LASTDMAP]||Game->GetCurDMapScreen()!=MooshPit[MP_LASTSCREEN]){
							Link->PitWarp(MooshPit[MP_LASTDMAP], MooshPit[MP_LASTSCREEN]);
						}
				
						Link->Invisible = false;
						Link->CollDetection = true;
					}
					else{
						//Move Link to the start and make him visible
						Link->X = MooshPit[MP_ENTRYX];
						Link->Y = MooshPit[MP_ENTRYY];
						
						Link->Invisible = false;
						Link->CollDetection = true;
					}
					
					//Subtract HP based on damage type
					if(MooshPit[MP_DAMAGETYPE]==1)
						Link->HP -= DAMAGE_FALLLAVA;
					else
						Link->HP -= DAMAGE_FALLHOLE;
					//Play hurt sound and animation
					Link->Action = LA_GOTHURTLAND;
					Link->HitDir = -1;
					Game->PlaySound(SFX_OUCH);
					LinkHurtFrames = -1;
					
					MooshPit[MP_FALLSTATE] = 0;
				}
				else{
					MooshPit[MP_FALLSTATE] = 2;
					MooshPit[MP_FALLTIMER] = 1;
					ffc warp = Screen->LoadFFC(FFC_MOOSHPIT_AUTOWARPA);
					warp->Data = CMB_MOOSHPIT_AUTOWARPA;
					warp->Flags[FFCF_CARRYOVER] = false;
				}
			}
		}
		else if(MooshPit[MP_FALLSTATE]==2){ //Just warped
			if(sideview){
				Link->X = MooshPit[MP_FALLX];
				Link->Y = 0;
			}
			else{
				Link->X = MooshPit[MP_FALLX];
				Link->Y = MooshPit[MP_FALLY];
				Link->Z = 176;
			}
			Link->Invisible = false;
			Link->CollDetection = true;
			
			MooshPit[MP_FALLSTATE] = 0;
			MooshPit[MP_FALLTIMER] = 0;
		}
	}
}

ffc script EZBoss{
	void run(int enemyid){
		int i; int j; int k; int angle; int dist; int x; int y;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		if ( ghost->ID != 177 ) //zora
			Ghost_SpawnAnimationPuff(this, ghost);
		
		if ( ghost->ID == 177 ) //zora
			Ghost_X = -32;
		
		int movementStyle = ghost->Attributes[0];
		int attack1 = ghost->Attributes[1];
		int attack2 = ghost->Attributes[2];
		int attack3 = ghost->Attributes[3];
		int special = ghost->Attributes[5];
		int size = ghost->Attributes[6];
		int fireSFX = ghost->Attributes[7];
		int fireSPR = ghost->Attributes[8];
		int flags = ghost->Attributes[9];
		
		int w = size&1111b;
		int h = (size>>4)&1111b;
		if(h==0)
			h = w;
		w = Clamp(w, 1, 4);
		h = Clamp(h, 1, 4);
			
		int combo = ghost->Attributes[10];
		Ghost_Transform(this, ghost, -1, -1, w, h);
		
		if(flags&EZBF_8WAY)
			Ghost_SetFlag(GHF_8WAY);
		else if(flags&EZBF_4WAY)
			Ghost_SetFlag(GHF_4WAY);
		if(flags&EZBF_NOFALL)
			Ghost_SetFlag(GHF_NO_FALL);
		if(flags&EZBF_FLYING){
			Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
			Ghost_SetFlag(GHF_FLYING_ENEMY);
		}
		else if(flags&EZBF_AQUATIC){
			Ghost_SetFlag(GHF_WATER_ONLY);
		}
		
		if ( ghost->ID == 177 || ghost->ID == 38 || ghost->ID == 183 ) //zora and keese and peahat
			Ghost_SetFlag(GHF_IGNORE_NO_ENEMY);
		
		int stepCounter = -1;
		int attackCooldown = ghost->Haltrate*10;
		int stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
		int vX; int vY;
		
		if(movementStyle==4){
			angle = Rand(360);
			vX = VectorX(ghost->Step/100, angle);
			vY = VectorY(ghost->Step/100, angle);
		}
		
		if ( ghost->ID == 54 ) { //gibdo
			for(i=0; i<=24; i++)
				Ghost_Waitframe(this, ghost);
		}
		
		while(true){
			bool attackCond = false;
			//Handle Movement
			if(movementStyle==0){ //4 Way Halting Walk
				stepCounter = Ghost_HaltingWalk4(stepCounter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger, ghost->Haltrate, 48);
				if(stepCounter==16)
					attackCond = true;
			}
			else if(movementStyle==1){ //4 Way Constant Walk
				stepCounter = Ghost_ConstantWalk4(stepCounter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==2){ //8 Way Constant Walk
				stepCounter = Ghost_ConstantWalk8(stepCounter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==3){ //Homing in on Link
				if(Distance(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())>8){
					EZB_FaceLink(this, ghost);
					Ghost_MoveAtAngle(Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), ghost->Step/100, 0);
				}
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==4){ //Wall Bounce
				Ghost_MoveXY(vX, vY, 0);
				if((vX<0&&!Ghost_CanMove(DIR_LEFT, 1, 0)) || (vX>0&&!Ghost_CanMove(DIR_RIGHT, 1, 0)))
					vX = -vX;
				if((vY<0&&!Ghost_CanMove(DIR_UP, 1, 0)) || (vY>0&&!Ghost_CanMove(DIR_DOWN, 1, 0)))
					vY = -vY;
					
				Ghost_Dir = EZB_AngleDir(this, ghost, Angle(0, 0, vX*10, vY*10));
				if(flags&EZBF_FACELINK)
					EZB_FaceLink(this, ghost);
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==5){ //Periodic Reaim
				Ghost_MoveAtAngle(stepAngle, ghost->Step/100, 0);
				Ghost_Dir = EZB_AngleDir(this, ghost, stepAngle);
				if(flags&EZBF_FACELINK)
					EZB_FaceLink(this, ghost);
					
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
					
				stepCounter++;
				if(stepCounter>80&&Rand(10)==0){
					stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					stepCounter = 0;
				}
			}
			else if(movementStyle==6){ //Lazy chase
				float homing = ghost->Homing*0.001;
				float topSpeed = ghost->Step*0.01;
				vX = Clamp(vX+Sign(CenterLinkX()-CenterX(ghost))*homing, -topSpeed, topSpeed);
				vY = Clamp(vY+Sign(CenterLinkY()-CenterY(ghost))*homing, -topSpeed, topSpeed);
				Ghost_MoveXY(vX, vY, 0);
				if((vX<0&&!Ghost_CanMove(DIR_LEFT, 1, 0)) || (vX>0&&!Ghost_CanMove(DIR_RIGHT, 1, 0)))
					vX = -vX;
				if((vY<0&&!Ghost_CanMove(DIR_UP, 1, 0)) || (vY>0&&!Ghost_CanMove(DIR_DOWN, 1, 0)))
					vY = -vY;
					
				Ghost_Dir = EZB_AngleDir(this, ghost, Angle(0, 0, vX*10, vY*10));
				if(flags&EZBF_FACELINK)
					EZB_FaceLink(this, ghost);
				if(attackCooldown>0)
					attackCooldown--;
				else if(Rand(24)==0)
					attackCond = true;
			}
			else if(movementStyle==7){ //Hopping
				EZB_Waitframes(this, ghost, Choose(24, 32, 48));
				stepAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+Rand(-30, 30);
				Game->PlaySound(SFX_JUMP);
				if ( ghost->ID == 42 || ghost->ID == 43 )
					Ghost_Jump = 2;
				else if ( ghost->ID == 55 )
					Ghost_Jump = 4;
				else
					Ghost_Jump = 2.6;
				while(Ghost_Jump>0||Ghost_Z>0){
					Ghost_Dir = EZB_AngleDir(this, ghost, stepAngle);
					Ghost_MoveAtAngle(stepAngle, ghost->Step/100, 0);
					if(flags&EZBF_FACELINK)
						EZB_FaceLink(this, ghost);
					EZB_Waitframe(this, ghost);
				}
				if(Rand(ghost->Rate)==0)
					attackCond = true;
			}
			else if(movementStyle==8){ //Teleport
				EZB_Waitframes(this, ghost, Choose(96, 144));
				EZB_Teleport(this, ghost);
				if ( ghost->ID != 107 ) //batrobe
					EZB_Waitframes(this, ghost, 16);
				if(Rand(ghost->Rate)==0)
					attackCond = true;
			}
			
			if(attackCond&&attack1){
				//Select an attack
				int attack;
				if(attack2==0)
					attack = attack1;
				else if(attack3==0)
					attack = Choose(attack1, attack2);
				else
					attack = Choose(attack1, attack2, attack3);
			
				if(attack==1){ //Dash
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_FaceLink(this, ghost);
					EZB_Waitframes(this, ghost, 30);
					while(EZB_CanMoveAngle(angle)){
						Ghost_MoveAtAngle(angle, 5, 0);
						EZB_Trail(this, ghost);
						EZB_Waitframe(this, ghost);
					}
				}
				if(attack==2){ //Shoot (Directional)
					EZB_FiringAnim(this, ghost);
					EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir), 150);
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==3){ //Shoot (Angular)
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 150);
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==4){ //Tri Shot (Directional)
					EZB_FiringAnim(this, ghost);
					for(i=-1; i<=1; i++){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir)+30*i, 250);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==5){ //Tri Shot (Angular)
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					for(i=-1; i<=1; i++){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+30*i, 200);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==6){ //Stream (Directional)
					EZB_FiringAnim(this, ghost);
					angle = EZB_DirAngle(Ghost_Dir);
					EZB_Waitframes(this, ghost, 12);
					for(i=0; i<10; i++){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle, 350);
						EZB_Waitframes(this, ghost, 8);
					}
					EZB_Waitframes(this, ghost, 12);
				}
				if(attack==7){ //Stream (Angular)
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, 12);
					for(i=0; i<10; i++){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle, 350);
						EZB_Waitframes(this, ghost, 8);
					}
					EZB_Waitframes(this, ghost, 12);
				}
				if(attack==8){ //Breath (Directional)
					EZB_FiringAnim(this, ghost);
					angle = EZB_DirAngle(Ghost_Dir);
					EZB_Waitframes(this, ghost, 24);
					for(i=0; i<24; i++){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle+Rand(-30, 30), 250);
						EZB_Waitframes(this, ghost, 4);
					}
				}
				if(attack==9){ //Breath (Angular)
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					EZB_Waitframes(this, ghost, 24);
					for(i=0; i<24; i++){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle+Rand(-30, 30), 250);
						EZB_Waitframes(this, ghost, 4);
					}
				}
				if(attack==10){ //Sweep (Directional)
					EZB_FiringAnim(this, ghost);
					k = Choose(-1, 1);
					angle = EZB_DirAngle(Ghost_Dir)-45*k;
					for(i=0; i<18; i+=2){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle, 250);
						angle += k*10;
						EZB_Waitframes(this, ghost, 4);
					}
				}
				if(attack==11){ //Sweep (Angular)
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					k = Choose(-1, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())-45*k;
					for(i=0; i<18; i+=2){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle, 250);
						angle += k*10;
						EZB_Waitframes(this, ghost, 4);
					}
				}
				if(attack==12){ //Bullet Barrage
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())-45*k;
					for(i=0; i<3; i++){
						for(j=-4; j<=4; j+=2){
							EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle+16*j, 150);
						}
						EZB_Waitframes(this, ghost, 16);
						for(j=-5; j<=5; j+=2){
							EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle+16*j, 150);
						}
						EZB_Waitframes(this, ghost, 24);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==13){ //Bullet swirl
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					k = Choose(-1, 1);
					angle = Rand(360);
					for(i=0; i<15; i++){
						for(j=0; j<5; j++){
							EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle+72*j, 150);
						}
						angle += 4*k;
						EZB_Waitframes(this, ghost, 4);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==14){ //Random bullet burst
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					for(i=0; i<25; i++){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, Rand(360), 250);
						EZB_Waitframes(this, ghost, 3);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==15){ //Laser
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=0; i<30; i++){
						if(i%4<2){
							DrawLaser(4, CenterX(ghost), CenterY(ghost), 8, angle, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost);
					}
					Game->PlaySound(SFX_EZB_LASER);
					for(i=0; i<20; i++){
						Laser3Color(4, CenterX(ghost), CenterY(ghost), 8, angle, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						EZB_Waitframe(this, ghost);
					}
				}
				if(attack==16){ //Big Laser
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=0; i<60; i++){
						if(i%4<2){
							DrawLaser(4, CenterX(ghost), CenterY(ghost), 40, angle, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost);
					}
					Game->PlaySound(SFX_EZB_LASER);
					for(i=0; i<40; i++){
						Laser3Color(4, CenterX(ghost), CenterY(ghost), 40, angle, ghost->WeaponDamage*2, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						EZB_Waitframe(this, ghost);
					}
				}
				if(attack==17){ //Laser Spread
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(i=0; i<40; i++){
						for(j=-2; j<=2; j++){
							if(i%4<2){
								DrawLaser(4, CenterX(ghost), CenterY(ghost), 6, angle+30*j, C_EZB_LASER3);
							}
						}
						EZB_Waitframe(this, ghost);
					}
					Game->PlaySound(SFX_EZB_LASER);
					for(i=0; i<20; i++){
						for(j=-2; j<=2; j++){
							Laser3Color(4, CenterX(ghost), CenterY(ghost), 6, angle+30*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost);
					}
				}
				if(attack==18){ //Laser Spin
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					k = Choose(-1, 1);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+45;
					for(i=0; i<30; i++){
						if(i%4<2){
							for(j=0; j<4; j++){
								DrawLaser(4, CenterX(ghost), CenterY(ghost), 6, angle+90*j, C_EZB_LASER3);
							}
						}
						EZB_Waitframe(this, ghost);
					}
					Game->PlaySound(SFX_EZB_LASER);
					for(i=0; i<20; i++){
						for(j=0; j<4; j++){
							Laser3Color(4, CenterX(ghost), CenterY(ghost), 6, angle+90*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						EZB_Waitframe(this, ghost);
					}
					for(i=0; i<20; i++){
						for(j=0; j<4; j++){
							Laser3Color(4, CenterX(ghost), CenterY(ghost), 6, angle+90*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						angle += k;
						EZB_Waitframe(this, ghost);
					}
					for(i=0; i<20; i++){
						for(j=0; j<4; j++){
							Laser3Color(4, CenterX(ghost), CenterY(ghost), 6, angle+90*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						angle += k*1.5;
						EZB_Waitframe(this, ghost);
					}
					for(i=0; i<20; i++){
						for(j=0; j<4; j++){
							Laser3Color(4, CenterX(ghost), CenterY(ghost), 6, angle+90*j, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
						}
						angle += k;
						EZB_Waitframe(this, ghost);
					}
				}
				if(attack==19){ //Rotating Stream
					angle = EZB_DirAngle(Ghost_Dir);
					for(i=0; i<20; i++){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle, 250);
						if ( angle == 0 )
							angle = 90;
						else if ( angle == 90 )
							angle = 180;
						else if ( angle == 180 )
							angle = -90;
						else if ( angle == -90 )
							angle = 0;
						EZB_Waitframes(this, ghost, 4);
					}
				}
				if(attack==20){ //Triple Tri Shot (Directional)
					EZB_FiringAnim(this, ghost);
					for(i=-1; i<=1; i++){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir)+30*i, 250);
					}
					EZB_Waitframes(this, ghost, 16);
					for(i=-1; i<=1; i+= 2){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir)+15*i, 200);
					}
					EZB_Waitframes(this, ghost, 16);
					EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir), 150);
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==21){ //Spawn gel
					EZB_FiringAnim(this, ghost);
					if ( Screen->NumNPCs() < 20 )
						npc gel=CreateNPCAt(42, Ghost_X, Ghost_Y);
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==22){ //Uno Duo Shots (Angular)
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 200);
					EZB_Waitframes(this, ghost, 16);
					for(i=-1; i<=1; i+=2){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+20*i, 200);
					}
					EZB_Waitframes(this, ghost, 16);
					EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 200);
					EZB_Waitframes(this, ghost, 16);
					for(i=-1; i<=1; i+=2){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY())+20*i, 200);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==23){ //Aimed shots with delays
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 250);
					EZB_Waitframes(this, ghost, 45);
					EZB_FaceLink(this, ghost);
					EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 250);
					EZB_Waitframes(this, ghost, 45);
					EZB_FaceLink(this, ghost);
					EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 250);
					EZB_Waitframes(this, ghost, 45);
					EZB_FaceLink(this, ghost);
					EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 250);
					EZB_Waitframes(this, ghost, 45);
					EZB_FaceLink(this, ghost);
					EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()), 250);
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==24){ //Random SHORTER bullet burst
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					for(i=0; i<16; i++){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, Rand(360), 250);
						EZB_Waitframes(this, ghost, 2);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==25){ //Spiral shots
					EZB_FiringAnim(this, ghost);
					int angle = EZB_DirAngle(Ghost_Dir);
					int spiraldir = Choose (-1, 1);
					for(i=-360; i<360; i+= 30){
						if ( i == 0 )
							i = 15;
						if ( ghost->ID == 99 )
							EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle-i*spiraldir, 125);
						else
							EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle-i*spiraldir, 200);
						EZB_Waitframes(this, ghost, 2);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==26){ //Uno Duo Stream (Angular)
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					int angltolink = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					int anglchangestate;
					int anglchange;
					for(i=0; i<120; i+=2){
						for(j=-1; j<=1; j+=2)
							EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angltolink+anglchange*j, 200);
						if ( anglchangestate == 0 )
							anglchange += 2;
						else
							anglchange -= 2;
						if ( anglchange == 14 )
							anglchangestate = 1;
						if ( anglchange == 0 )
							anglchangestate = 0;
						EZB_Waitframes(this, ghost, 2);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==27){ //Spawn digdogger kids
					EZB_FiringAnim(this, ghost);
					Game->PlaySound(56);
					if ( Screen->NumNPCs() < 20 )
						npc digkid1=CreateNPCAt(180, Ghost_X, Ghost_Y);
					if ( Screen->NumNPCs() < 20 )
						npc digkid2=CreateNPCAt(180, Ghost_X, Ghost_Y);
					if ( Screen->NumNPCs() < 20 )
						npc digkid3=CreateNPCAt(180, Ghost_X, Ghost_Y);
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==28){ //Uno Duo Shots (Directional)
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir), 200);
					EZB_Waitframes(this, ghost, 16);
					for(i=-1; i<=1; i+=2){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir)+20*i, 200);
					}
					EZB_Waitframes(this, ghost, 16);
					EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir), 200);
					EZB_Waitframes(this, ghost, 16);
					for(i=-1; i<=1; i+=2){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, EZB_DirAngle(Ghost_Dir)+20*i, 200);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==29){ //Firy Line
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					int firyangle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					//EZB_Waitframes(this, ghost, 24);
					for(i=30; i<450; i+=30){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, firyangle, i);
						EZB_Waitframes(this, ghost, 2);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==30){ //Spawn keese
					EZB_FiringAnim(this, ghost);
					Game->PlaySound(56);
					if ( Screen->NumNPCs() < 20 )
						npc keese1=CreateNPCAt(38, Ghost_X, Ghost_Y);
					EZB_Waitframes(this, ghost, 16);
					if ( Screen->NumNPCs() < 20 )
						npc keese2=CreateNPCAt(38, Ghost_X, Ghost_Y);
					EZB_Waitframes(this, ghost, 16);
					if ( Screen->NumNPCs() < 20 )
						npc keese3=CreateNPCAt(38, Ghost_X, Ghost_Y);
					EZB_Waitframes(this, ghost, 16);
					if ( Screen->NumNPCs() < 20 )
						npc keese4=CreateNPCAt(38, Ghost_X, Ghost_Y);
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==31){ //Keese Storm
					EZB_FiringAnim(this, ghost);
					Game->PlaySound(56);
					int keesestormangle = 180;
					Ghost_Dir = DIR_LEFT;
					if ( ghost->X < 120 ) {
						keesestormangle = 0;
						Ghost_Dir = DIR_RIGHT;
					}
					for(i=0; i<32; i++){
						if ( keesestormangle == 0 )
							EZB_Fire(this, ghost, 0, Rand(8, 152), keesestormangle, 250);
						else
							EZB_Fire(this, ghost, 240, Rand(8, 152), keesestormangle, 250);
						EZB_Waitframes(this, ghost, 8);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==32){ //Consecutive Aimed Streams
					EZB_FaceLink(this, ghost);
					EZB_FiringAnim(this, ghost);
					int angle1 = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					int angle2;
					int angle3;
					int angle4;
					for(i=0; i<10; i++){
						if ( i == 5 )
							angle2 = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle1, 350);
						if ( i >= 5 )
							EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle2, 350);
						EZB_Waitframes(this, ghost, 4);
					}
					for(i=0; i<10; i++){
						if ( i == 5 )
							angle3 = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle2, 350);
						if ( i >= 5 )
							EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle3, 350);
						EZB_Waitframes(this, ghost, 4);
					}
					for(i=0; i<15; i++){
						if ( i == 5 )
							angle4 = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
						if ( i < 10 )
							EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle3, 350);
						if ( i >= 5 )
							EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle4, 350);
						EZB_Waitframes(this, ghost, 4);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==33){ //Tri Stream (Directional)
					EZB_FiringAnim(this, ghost);
					angle = EZB_DirAngle(Ghost_Dir);
					EZB_Waitframes(this, ghost, 12);
					for(i=0; i<10; i++){
						for(j=-1; j<=1; j++){
							EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle+30*j, 350);
						}
						EZB_Waitframes(this, ghost, 8);
					}
					EZB_Waitframes(this, ghost, 12);
				}
				if(attack==34){ //Wave Stream (Directional)
					EZB_FiringAnim(this, ghost);
					int angle = EZB_DirAngle(Ghost_Dir);
					int waveangle = -20;
					bool waveup;
					for(i=0; i<100; i++){
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle+waveangle, 250);
						EZB_Fire(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, angle-waveangle/2, 250);
						if ( waveup )
							waveangle += 5;
						else
							waveangle -= 5;
						if ( waveangle >= 20 )
							waveup = false;
						if ( waveangle <= -20 )
							waveup = true;
						EZB_Waitframes(this, ghost, 2);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				if(attack==35){ //Explosion Circle
					EZB_FiringAnim(this, ghost);
					for(i=1; i<=12; i++){
						EZB_FireSlowToBoom(this, ghost, CenterX(ghost)-8, CenterY(ghost)-8, 360/12*i, 250);
					}
					EZB_Waitframes(this, ghost, 24);
				}
				
				Ghost_Data = combo;
				
				attackCooldown = ghost->Haltrate*10;
				if(movementStyle==4){ //Wall bounce
					angle = Rand(360);
					vX = VectorX(ghost->Step/100, angle);
					vY = VectorY(ghost->Step/100, angle);
				}
			}
			EZB_Waitframe(this, ghost);
		}
	}
	bool EZB_CanMoveAngle(int angle){
		int vx = VectorX(10, angle);
		int vy = VectorY(10, angle);
		if((vx<0&&!Ghost_CanMove(DIR_LEFT, 1, 0))||(vx>0&&!Ghost_CanMove(DIR_RIGHT, 1, 0)))
			return false;
		if((vy<0&&!Ghost_CanMove(DIR_UP, 1, 0))||(vy>0&&!Ghost_CanMove(DIR_DOWN, 1, 0)))
			return false;
		return true;
	}
	void EZB_FiringAnim(ffc this, npc ghost){
		int flags = ghost->Attributes[9];
		int combo = ghost->Attributes[10];
		if(flags&EZBF_8WAY)
			Ghost_Data = combo+8;
		else if(flags&EZBF_4WAY)
			Ghost_Data = combo+4;
		else
			Ghost_Data = combo+1;
	}
	void EZB_Trail(ffc this, npc ghost){
		int flags = ghost->Attributes[9];
		int tile = Game->ComboTile(Ghost_Data);
		if(flags&EZBF_4WAY||flags&EZBF_8WAY)
			tile = Game->ComboTile(Ghost_Data+Ghost_Dir);
		lweapon trail = CreateLWeaponAt(LW_SCRIPT10, ghost->X+ghost->DrawXOffset, ghost->Y+ghost->DrawYOffset);
		trail->Extend = 3;
		trail->TileWidth = ghost->TileWidth;
		trail->TileHeight = ghost->TileHeight;
		trail->DrawYOffset = 0;
		trail->CSet = this->CSet;
		trail->Tile = tile;
		trail->OriginalTile = tile;
		trail->DrawStyle = DS_PHANTOM;
		trail->DeadState = 8;
	}
	int EZB_DirAngle(int dir){
		if(dir==DIR_UP)
			return -90;
		else if(dir==DIR_DOWN)
			return 90;
		else if(dir==DIR_LEFT)
			return 180;
		else if(dir==DIR_LEFTUP)
			return -135;
		else if(dir==DIR_RIGHTUP)
			return -45;
		else if(dir==DIR_LEFTDOWN)
			return 135;
		else if(dir==DIR_RIGHTDOWN)
			return 45;
		else
			return 0;
	}
	eweapon EZB_Fire(ffc this, npc ghost, int x, int y, int angle, int step){
		int flags = ghost->Attributes[9];
		int type = WeaponTypeToID(ghost->Weapon);
		int wflags;
		if(flags&EZBF_UNBLOCKABLE)
			wflags |= EWF_UNBLOCKABLE;
		if(type==EW_BEAM||type==EW_ARROW||type==EW_MAGIC||type==EW_BOMB||type==EW_SBOMB)
			wflags |= EWF_ROTATE;
			
		int fireSFX = ghost->Attributes[7];
		int fireSPR = ghost->Attributes[8];
		int sfx = fireSFX;
		if(fireSFX<=0)
			sfx = -1;
		int spr = fireSPR;
		if(fireSPR<=0)
			spr = -1;

		eweapon e = FireEWeapon(type, x, y, DegtoRad(angle), step, ghost->WeaponDamage, spr, sfx, wflags);
		return e;
	}
	eweapon EZB_FireSlowToBoom(ffc this, npc ghost, int x, int y, int angle, int step){
		int flags = ghost->Attributes[9];
		int type = WeaponTypeToID(ghost->Weapon);
		int wflags;
		if(flags&EZBF_UNBLOCKABLE)
			wflags |= EWF_UNBLOCKABLE;
		if(type==EW_BEAM||type==EW_ARROW||type==EW_MAGIC||type==EW_BOMB||type==EW_SBOMB)
			wflags |= EWF_ROTATE;
			
		int fireSFX = ghost->Attributes[7];
		int fireSPR = ghost->Attributes[8];
		int sfx = fireSFX;
		if(fireSFX<=0)
			sfx = -1;
		int spr = fireSPR;
		if(fireSPR<=0)
			spr = -1;

		eweapon e = FireEWeapon(type, x, y, DegtoRad(angle), step, ghost->WeaponDamage, spr, sfx, wflags);
		SetEWeaponLifespan(e, EWL_SLOW_TO_HALT, 10);
		SetEWeaponDeathEffect(e, EWD_EXPLODE, 8);
		return e;
	}
	void EZB_Teleport(ffc this, npc ghost){
		int size = ghost->Attributes[6];
		int w = size&1111b;
		int h = (size>>4)&1111b;
		if(h==0)
			h = w;
		w = Clamp(w, 1, 4);
		h = Clamp(h, 1, 4);
		
		if ( ghost->ID != 177 ) //zora
			Game->PlaySound(SFX_EZB_TELEPORT);
		int tc;
		ghost->CollDetection = false;
		for(int i=0; i<16; i++){
			if(i%2==0)
				ghost->DrawYOffset = -1000;
			else
				ghost->DrawYOffset = -2;
			EZB_Waitframe(this, ghost);
		}
		ghost->DrawYOffset = -1000;
		tc = Rand(176);
		for(int i=0; i<352&&(!EZB_CanPlace(this, ghost, ComboX(tc), ComboY(tc))||Distance(ComboX(tc)+ghost->HitWidth/2, ComboY(tc)+ghost->HitHeight/2, CenterLinkX(), CenterLinkY())<((w+h)/2)*8+32); i++){
			if(i>=176)
				tc = i-176;
			else
				tc = Rand(176);
		}
		Ghost_X = ComboX(tc);
		Ghost_Y = ComboY(tc);
		EZB_Waitframe(this, ghost);
		EZB_FaceLink(this, ghost);
		for(int i=0; i<16; i++){
			if(i%2==0)
				ghost->DrawYOffset = -1000;
			else
				ghost->DrawYOffset = -2;
			EZB_Waitframe(this, ghost);
		}
		ghost->DrawYOffset = -2;
		ghost->CollDetection = true;
	}	
	int EZB_AngleDir(ffc this, npc ghost, int angle){
		int flags = ghost->Attributes[9];
		if(flags&EZBF_8WAY)
			return AngleDir8(angle);
		else
			return AngleDir4(angle);
	}
	void EZB_FaceLink(ffc this, npc ghost){
		int flags = ghost->Attributes[9];
		if(flags&EZBF_8WAY)
			Ghost_Dir = AngleDir8(Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()));
		else
			Ghost_Dir = AngleDir4(Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY()));
	}
	bool EZB_CanPlace(ffc this, npc ghost, int X, int Y){
		for(int x=ghost->HitXOffset; x<=ghost->HitXOffset+ghost->HitWidth-1; x=Min(x+8, ghost->HitXOffset+ghost->HitWidth-1)){
			for(int y=ghost->HitYOffset; y<=ghost->HitYOffset+ghost->HitHeight-1; y=Min(y+8, ghost->HitYOffset+ghost->HitHeight-1)){
				if(!Ghost_CanMovePixel(X+x, Y+y))
					return false;
				if(y==ghost->HitYOffset+ghost->HitHeight-1)
					break;
			}
			if(x==ghost->HitXOffset+ghost->HitWidth-1)
				break;
		}
		return true;
	}
	void EZB_Waitframes(ffc this, npc ghost, int frames){
		for(int i=0; i<frames; i++){
			EZB_Waitframe(this, ghost);
		}
	}
	void EZB_Waitframe(ffc this, npc ghost){
		int flags = ghost->Attributes[9];
		if(flags&EZBF_EXPLODEEATH)
			Ghost_Waitframe(this, ghost, 1, true);
		else
			Ghost_Waitframe(this, ghost);
	}
}

const int COLOR_WIND = 0x01;
const int SUCK_STRENGTH = 1.3;
const int BLOW_STRENGTH = 1.3;

// ENEMY EDITOR MISC ATTRIBUTES
// Attr. 1: CSet for suck, -1 to disable suck
// Attr. 2: CSet for blow, -1 to disable blow
// Attr. 3: CSet for wind, -1 to disable wind
// Attr. 4: 1 to cycle through non-disabled attacks instead of randomizing
// Attr. 5: 1 to render enemy immobile
// Attr. 6: 1 to turn off collision detection (enemy is invincible and unable to damage player)
// Attr. 7: lower bound for random attack interval timer, defaults to 90 when Attributes 7 and 8 are both 0
// Attr. 8: upper bound for random attack interval timer, defaults to 150 when Attributes 7 and 8 are both 0
// Attr. 9: continuous attack mode, attack interval timers are ignored, no CSet flash warning, non-disabled attacks are continuously used (pair with immobile recommended)

ffc script SuckToBlow
{
	void run(int enemyID)
	{
		npc ghost = Ghost_InitAutoGhost(this, enemyID);
		int counter = -1;
		int cset_default = Ghost_CSet;
		int cset_index = -1;
		int cset1 = ghost->CSet;
		int cset2 = -1;
		int cset3 = -1;
		int csets[3] = {cset1, cset2, cset3};
		int non_random = 0;
		int non_moving = 0;
		int no_collision = 0;
		int timer_attack_lower_bound = 0;
		int timer_attack_upper_bound = 0;
		int continuous = 0;
		int store_def[18];
		Ghost_StoreDefenses(ghost, store_def);
		int timer_attack = 120;
		int direct_shot;
		int wind_lines[48];
		float angle;
		float x_step;
		float y_step;
		float x_dir;
		float y_dir;
		if (non_moving)
		{
			ghost->DrawYOffset = 0;
			ghost->HitYOffset = 0;
		}
		if (no_collision)
		{
			ghost->CollDetection = false;
		}
		if (timer_attack_lower_bound == 0 && timer_attack_upper_bound == 0)
		{
			timer_attack_lower_bound = 90;
			timer_attack_upper_bound = 150;
		}
		
		while (true)
		{
			if (!non_moving)
			{
				counter = Ghost_ConstantWalk4(counter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
			}
			
			if (timer_attack <= 0)
			{
				cset_index = SuckToBlowRandomCSet(csets, cset_index, non_random);
				if (cset_index >= 0)
				{
					if (!continuous)
					{
						SuckToBlowFlashCSet(this, ghost, wind_lines, cset_default, csets[cset_index], 60);
					}
					else
					{
						Ghost_CSet = csets[cset_index];
					}
					if (cset_index == 0)
					{
						//Ghost_SetAllDefenses(ghost, NPCDT_BLOCK);
						this->Misc[0] = -90;
						SuckToBlow_WindLinesRandomize(this, ghost, wind_lines, true);
						Game->PlaySound(65);
						while (this->Misc[0] < 0)
						{
							SuckToBlow_Waitframe(this, ghost, wind_lines);
						}
					}
					else if (cset_index == 1)
					{
						this->Misc[0] = 90;
						SuckToBlow_WindLinesRandomize(this, ghost, wind_lines, false);
						Game->PlaySound(49);
						while (this->Misc[0] > 0)
						{
							SuckToBlow_Waitframe(this, ghost, wind_lines);
						}
					}
					else
					{
						SuckToBlow_Waitframes(this, ghost, wind_lines, 10);
						direct_shot = Rand(10);
						for (int i = 0; i < 10; i++)
						{
							if (i == direct_shot)
							{
								angle = Angle(Ghost_X + (0.5 * 16 * ghost->TileWidth), Ghost_Y + (0.5 * 16 * ghost->TileHeight), Link->X + 8, Link->Y + 8);
							}
							else
							{
								angle = Angle(Ghost_X + (0.5 * 16 * ghost->TileWidth), Ghost_Y + (0.5 * 16 * ghost->TileHeight), Link->X + 8, Link->Y + 8);
								angle += Rand(-45, 45);
							}
							SuckToBlow_Wind(angle, Rand(200, 400));
							SuckToBlow_Waitframes(this, ghost, wind_lines, 6);
						}
					}
					if (!continuous)
					{
						SuckToBlowFlashCSet(this, ghost, wind_lines, csets[cset_index], cset_default, 30);
					}
					//Ghost_SetDefenses(ghost, store_def);
				}
				if (!continuous)
				{
					timer_attack = Rand(timer_attack_lower_bound, timer_attack_upper_bound);
				}
				else
				{
					timer_attack = 0;
				}
			}
			
			if (timer_attack)
			{
				timer_attack--;
			}
			SuckToBlow_Waitframe(this, ghost, wind_lines);
		}
	}
}

int SuckToBlowRandomCSet(int csets, int cset_index, int non_random)
{
	int temp[3];
	int valid_csets;
	
	if (!non_random)
	{
		for (int i = 0; i < SizeOfArray(csets); i++)
		{
			if (csets[i] >= 0)
			{
				temp[valid_csets] = i;
				valid_csets++;
			}
		}
		if (valid_csets > 0)
		{
			return temp[Rand(valid_csets)];
		}
		else
		{
			return -1;
		}
	}
	else
	{
		for (int i = 0; i < SizeOfArray(csets); i++)
		{
			cset_index++;
			cset_index % SizeOfArray(csets);
			if (csets[cset_index] >= 0)
			{
				return cset_index;
			}
		}
		return -1;
	}
}

void SuckToBlowFlashCSet(ffc this, npc ghost, int wind_lines, int cset1, int cset2, int duration)
{
	for (int i = 0; i < duration; i++)
	{
		if (i % 2 == 0)
		{
			Ghost_CSet = cset1;
		}
		else
		{
			Ghost_CSet = cset2;
		}
		SuckToBlow_Waitframe(this, ghost, wind_lines);
	}
	Ghost_CSet = cset2;
}

void SuckToBlow_Wind(int angle, int step)
{
	eweapon wind = FireEWeapon(EW_SCRIPT1, Ghost_X, Ghost_Y, DegtoRad(angle), step, 0, 36, 59, EWF_NO_COLLISION);
	wind->Misc[0] = 23999;
	SetEWeaponLifespan(wind, EWL_SLOW_TO_HALT, step / 60);
	SetEWeaponDeathEffect(wind, EWD_VANISH, 0);
	wind->CollDetection = false;
}

void SuckToBlow_Waitframe(ffc this, npc ghost, int wind_lines)
{
	eweapon wind;

	for (int i = 1; i <= Screen->NumEWeapons(); i++)
	{
		wind = Screen->LoadEWeapon(i);
		if (wind->ID == EW_SCRIPT1 && wind->Misc[0] == 23999 && LinkCollisionMod(wind))
		{
			Link->Jump = 4;
			this->Misc[1] = 1;
			this->Misc[4] = RadtoDeg(wind->Angle);
		}
	}
	
	SuckToBlow_WindPush(this, ghost, wind_lines);
	Ghost_Waitframe(this, ghost);
}

void SuckToBlow_Waitframes(ffc this, npc ghost, int wind_lines, int num)
{
	for (int i = 0; i < num; i++)
	{
		SuckToBlow_Waitframe(this, ghost, wind_lines);
	}
}

void SuckToBlow_WindPush(ffc this, npc ghost, int wind_lines)
{
	int strength;
	float angle;
	float x_step;
	float y_step;
	float x = this->Misc[2];
	float y = this->Misc[3];
	float x_dir;
	float y_dir;
	bool suck;
	
	if (this->Misc[0] != 0 || this->Misc[1] > 0)
	{
		// SUCK
		if (this->Misc[0] < 0 && this->Misc[1] == 0)
		{
			angle = Angle(Link->X + 8, Link->Y + 8, Ghost_X + (0.5 * 16 * ghost->TileWidth), Ghost_Y + (0.5 * 16 * ghost->TileHeight));
			suck = true;
			strength = SUCK_STRENGTH;
		}
		// BLOW
		else if (this->Misc[0] > 0 && this->Misc[1] == 0)
		{
			angle = Angle(Ghost_X + (0.5 * 16 * ghost->TileWidth), Ghost_Y + (0.5 * 16 * ghost->TileHeight), Link->X + 8, Link->Y + 8);
			suck = false;
			strength = BLOW_STRENGTH;
		}
		else
		{
			angle = this->Misc[4];
			strength = BLOW_STRENGTH;
		}
		x_step = VectorX(strength, angle);
		y_step = VectorY(strength, angle);
		if (x_step > 0)
		{
			x_dir = DIR_RIGHT;
		}
		else
		{
			x_dir = DIR_LEFT;
		}
		if (y_step > 0)
		{
			y_dir = DIR_DOWN;
		}
		else
		{
			y_dir = DIR_UP;
		}
		if (CanWalk(Link->X, Link->Y, x_dir, x_step, false))
		{
			x += x_step;
			if (x >= 1 || x <= -1)
			{
				Link->X += x << 0;
				x -= x << 0;
			}
		}
		if (CanWalk(Link->X, Link->Y, y_dir, y_step, false))
		{
			y += y_step;
			if (y >= 1 || y <= -1)
			{
				Link->Y += y << 0;
				y -= y << 0;
			}
		}
		SuckToBlow_WindLines(this, ghost, wind_lines, suck);
	}
	
	if (this->Misc[0] > 0)
	{
		this->Misc[0]--;
	}
	if (this->Misc[0] < 0)
	{
		this->Misc[0]++;
	}
	if (this->Misc[1] > 0 && Link->Jump <= 0 && Link->Z == 0)
	{
		this->Misc[1] = 0;
	}
	this->Misc[2] = x;
	this->Misc[3] = y;
}

void SuckToBlow_WindLines(ffc this, npc ghost, int wind_lines, bool suck)
{
	int line_x1;
	int line_y1;
	int line_x2;
	int line_y2;
	int step = 4;
	float angle;
	float new_dist;
	float new_angle;
	
	if (this->Misc[1] == 0)
	{
		for (int i = 0; i < SizeOfArray(wind_lines) * 0.25; i++)
		{
			line_x1 = wind_lines[i];
			line_y1 = wind_lines[i + (SizeOfArray(wind_lines) * 0.25)];
			line_x2 = wind_lines[i + (SizeOfArray(wind_lines) * 0.5)];
			line_y2 = wind_lines[i + (SizeOfArray(wind_lines) * 0.75)];
			
			if (suck)
			{
				angle = Angle(wind_lines[i], wind_lines[i + (SizeOfArray(wind_lines) * 0.25)], Ghost_X + (0.5 * 16 * ghost->TileWidth), Ghost_Y + (0.5 * 16 * ghost->TileHeight));
				if (Distance(Ghost_X + (0.5 * 16 * ghost->TileWidth), Ghost_Y + (0.5 * 16 * ghost->TileHeight), wind_lines[i], wind_lines[i + (SizeOfArray(wind_lines) * 0.25)]) > 10)
				{
					line_x1 += VectorX(step, angle);
					line_y1 += VectorY(step, angle);
				}
				else if (Distance(wind_lines[i], wind_lines[i + (SizeOfArray(wind_lines) * 0.25)], wind_lines[i + (SizeOfArray(wind_lines) * 0.5)], wind_lines[i + (SizeOfArray(wind_lines) * 0.75)]) <= step)
				{
					new_dist = Rand(96, 112);
					new_angle = Rand(360);
					line_x1 = Ghost_X + VectorX(new_dist, new_angle);
					line_y1 = Ghost_Y + VectorY(new_dist, new_angle);
					line_x2 = line_x1;
					line_y2 = line_y1;
				}
				if (Distance(wind_lines[i], wind_lines[i + (SizeOfArray(wind_lines) * 0.25)], wind_lines[i + (SizeOfArray(wind_lines) * 0.5)], wind_lines[i + (SizeOfArray(wind_lines) * 0.75)]) >= 32 || (Distance(Ghost_X + (0.5 * 16 * ghost->TileWidth), Ghost_Y + (0.5 * 16 * ghost->TileHeight), wind_lines[i], wind_lines[i + (SizeOfArray(wind_lines) * 0.25)]) <= 10 && Distance(wind_lines[i], wind_lines[i + (SizeOfArray(wind_lines) * 0.25)], wind_lines[i + (SizeOfArray(wind_lines) * 0.5)], wind_lines[i + (SizeOfArray(wind_lines) * 0.75)]) > step))
				{
					line_x2 += VectorX(step, angle);
					line_y2 += VectorY(step, angle);
				}
			}
			else
			{
				angle = Angle(Ghost_X + (0.5 * 16 * ghost->TileWidth), Ghost_Y + (0.5 * 16 * ghost->TileHeight), wind_lines[i], wind_lines[i + (SizeOfArray(wind_lines) * 0.25)]);
				if (Distance(Ghost_X + (0.5 * 16 * ghost->TileWidth), Ghost_Y + (0.5 * 16 * ghost->TileHeight), wind_lines[i], wind_lines[i + (SizeOfArray(wind_lines) * 0.25)]) < 144)
				{
					line_x1 += VectorX(step, angle);
					line_y1 += VectorY(step, angle);
				}
				else if (Distance(wind_lines[i], wind_lines[i + (SizeOfArray(wind_lines) * 0.25)], wind_lines[i + (SizeOfArray(wind_lines) * 0.5)], wind_lines[i + (SizeOfArray(wind_lines) * 0.75)]) <= step)
				{
					new_dist = Rand(0, 64);
					new_angle = Rand(360);
					line_x1 = Ghost_X + VectorX(new_dist, new_angle);
					line_y1 = Ghost_Y + VectorY(new_dist, new_angle);
					line_x2 = line_x1;
					line_y2 = line_y1;
				}
				if (Distance(wind_lines[i], wind_lines[i + (SizeOfArray(wind_lines) * 0.25)], wind_lines[i + (SizeOfArray(wind_lines) * 0.5)], wind_lines[i + (SizeOfArray(wind_lines) * 0.75)]) >= 32 || (Distance(Ghost_X + (0.5 * 16 * ghost->TileWidth), Ghost_Y + (0.5 * 16 * ghost->TileHeight), wind_lines[i], wind_lines[i + (SizeOfArray(wind_lines) * 0.25)]) >= 144 && Distance(wind_lines[i], wind_lines[i + (SizeOfArray(wind_lines) * 0.25)], wind_lines[i + (SizeOfArray(wind_lines) * 0.5)], wind_lines[i + (SizeOfArray(wind_lines) * 0.75)]) > step))
				{
					line_x2 += VectorX(step, angle);
					line_y2 += VectorY(step, angle);
				}
			}
			Screen->Line(6, line_x1, line_y1, line_x2, line_y2, COLOR_WIND, 1, 0, 0, 0, OP_OPAQUE);
			wind_lines[i] = line_x1;
			wind_lines[i + (SizeOfArray(wind_lines) * 0.25)] = line_y1;
			wind_lines[i + (SizeOfArray(wind_lines) * 0.5)] = line_x2;
			wind_lines[i + (SizeOfArray(wind_lines) * 0.75)] = line_y2;
		}
	}
}

void SuckToBlow_WindLinesRandomize(ffc this, npc ghost, int wind_lines, bool suck)
{
	int new_dist;
	int new_angle;
	
	for (int i = 0; i < SizeOfArray(wind_lines) * 0.25; i++)
	{
		if (suck)
		{
			new_dist = Rand(96, 112);
		}
		else
		{
			new_dist = Rand(0, 64);
		}
		new_angle = Rand(360);
		wind_lines[i] = Ghost_X + VectorX(new_dist, new_angle);
		wind_lines[i + (SizeOfArray(wind_lines) * 0.25)] = Ghost_Y + VectorY(new_dist, new_angle);
		wind_lines[i + (SizeOfArray(wind_lines) * 0.5)] = Ghost_X + VectorX(new_dist, new_angle);
		wind_lines[i + (SizeOfArray(wind_lines) * 0.75)] = Ghost_Y + VectorY(new_dist, new_angle);
	}
}

bool LinkCollisionMod(eweapon b)
{
	int ax = Link->X + Link->HitXOffset;
	int bx = b->X + b->HitXOffset;
	int ay = Link->Y + Link->HitYOffset;
	int by = b->Y + b->HitYOffset;
	return RectCollision(ax+8, ay+8, ax+Link->HitWidth-8, ay+Link->HitHeight-8, bx, by, bx+b->HitWidth, by+b->HitHeight) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

const int ICE_BLOCK_SCRIPT = 6; // Slot number that the ice_block script is assigned to
const int ICE_BLOCK_SENSITIVITY = 8; // Number of frames the blocks need to be pushed against to start moving

ffc script IceBlock {
	void run(int specialroom) {
		int undercombo;
		int framecounter = 0;
		
		Waitframe();
		undercombo = Screen->ComboD[this->Y + (this->X >> 4)];
		Screen->ComboD[this->Y + (this->X >> 4)] = this->Data;
		
		bool GravityBlock;
		if ( this->Data == 628 )
			GravityBlock = true;
		bool SwapBlock;
		if ( this->Data == 629 )
			SwapBlock = true;
		bool IcyBlock;
		if ( this->Data == 630 )
			IcyBlock = true;
		bool SyncBlock;
		if ( this->Data == 632 || this->Data == 27 )
			SyncBlock = true;
		while(true) {
			int StopIt;
			bool dontmovelink;
			// Check if Link is pushing against the block
			if((Link->X == this->X - 16 && (Link->Y < this->Y + 1 && Link->Y > this->Y - 12) && Link->InputRight && Link->Dir == DIR_RIGHT) || // Right
			(Link->X == this->X + 16 && (Link->Y < this->Y + 1 && Link->Y > this->Y - 12) && Link->InputLeft && Link->Dir == DIR_LEFT) || // Left
			(Link->Y == this->Y - 16 && (Link->X < this->X + 6 && Link->X > this->X - 6) && Link->InputDown && Link->Dir == DIR_DOWN) || // Down
			(Link->Y == this->Y + 8 && (Link->X < this->X + 6 && Link->X > this->X - 6) && Link->InputUp && Link->Dir == DIR_UP)) { // Up
				framecounter++;
			}
			else {
				// Reset the frame counter
				framecounter = 0;
			}
			if(GravityBlock || (SyncBlock && Screen->D[0] == -3)) {
				while(this->Y < 160 && // Not at the edge of the screen
				!ComboFI(this->X, this->Y + 16, CF_NOBLOCKS) && // Not "No Push Block"
				Screen->ComboS[(this->Y + 16) + (this->X >> 4)] == 0000b
				&& StopIt < 1) { // Is walkable
					Screen->ComboD[(this->Y + 16) + (this->X >> 4)] += 440;
					Screen->ComboD[this->Y + (this->X >> 4)] = undercombo;
					this->Vy = 2;
					Waitframes(8);
					undercombo = Screen->ComboD[this->Y + (this->X >> 4)] - 440;
					StopIt ++;
					//dontmovelink = true;
				}
				this->Vy = 0;
				Screen->ComboD[this->Y + (this->X >> 4)] = this->Data;
				if ( dontmovelink )
					NoAction();
			}
			if(SyncBlock && Screen->D[0] == -2) {
				while(this->X < 240 && // Not at the edge of the screen
				!ComboFI(this->X + 16, this->Y, CF_NOBLOCKS) && // Not "No Push Block"
				Screen->ComboS[this->Y + ((this->X + 16) >> 4)] == 0000b
				&& StopIt < 1) { // Is walkable
					Screen->ComboD[this->Y + ((this->X + 16) >> 4)] += 440;
					Screen->ComboD[this->Y + (this->X >> 4)] = undercombo;
					this->Vx = 2;
					Waitframes(8);
					undercombo = Screen->ComboD[this->Y + (this->X >> 4)] - 440;
					StopIt ++;
					//dontmovelink = true;
				}
				this->Vx = 0;
				Screen->ComboD[this->Y + (this->X >> 4)] = this->Data;
				if ( dontmovelink )
					NoAction();
			}
			if(SyncBlock && Screen->D[0] == -1) {
				while(this->Y > 0 && // Not at the edge of the screen
				!ComboFI(this->X, this->Y - 1, CF_NOBLOCKS) && // Not "No Push Block"
				Screen->ComboS[(this->Y - 16) + (this->X >> 4)] == 0000b
				&& StopIt < 1) { // Is walkable
					Screen->ComboD[(this->Y - 16) + (this->X >> 4)] += 440;
					Screen->ComboD[this->Y + (this->X >> 4)] = undercombo;
					this->Vy = -2;
					Waitframes(8);
					undercombo = Screen->ComboD[this->Y + (this->X >> 4)] - 440;
					StopIt ++;
					//dontmovelink = true;
				}
				this->Vy = 0;
				Screen->ComboD[this->Y + (this->X >> 4)] = this->Data;
				if ( dontmovelink )
					NoAction();
			}
			if(SyncBlock && Screen->D[0] == -4) {
				while(this->X > 0 && // Not at the edge of the screen
				!ComboFI(this->X - 1, this->Y, CF_NOBLOCKS) && // Not "No Push Block"
				Screen->ComboS[this->Y + ((this->X - 16) >> 4)] == 0000b
				&& StopIt < 1) { // Is walkable
					Screen->ComboD[this->Y + ((this->X - 16) >> 4)] += 440;
					Screen->ComboD[this->Y + (this->X >> 4)] = undercombo;
					this->Vx = -2;
					Waitframes(8);
					undercombo = Screen->ComboD[this->Y + (this->X >> 4)] - 440;
					StopIt ++;
					//dontmovelink = true;
				}
				this->Vx = 0;
				Screen->ComboD[this->Y + (this->X >> 4)] = this->Data;
				if ( dontmovelink )
					NoAction();
			}
			// Once enough frames have passed, move the block
			if(framecounter >= ICE_BLOCK_SENSITIVITY) {
				bool dontplaysound;
				// Check the direction
				if(Link->Dir == DIR_RIGHT) {
					while((this->X < 240 && // Not at the edge of the screen
					!ComboFI(this->X + 16, this->Y, CF_NOBLOCKS) && // Not "No Push Block"
					Screen->ComboS[this->Y + ((this->X + 16) >> 4)] == 0000b || SwapBlock)
					&& StopIt < 1 ) { // Is walkable
						if ( !dontplaysound ) {
							Game->PlaySound(50);
							dontplaysound = true;
						}
						Screen->ComboD[this->Y + (this->X >> 4)] = undercombo;
						if ( SwapBlock ) {
							for(int i=0; i<8; i++){
								this->Vx = -2;
								WaitNoAction(1);
								Link->X += 2;
							}
						}
						else if ( GravityBlock ) {
							this->Vx = 2;
							Waitframes(8);
							//dontmovelink = true;
						}
						else if ( IcyBlock && StopIt <= 0 && StopIt != -2 ) {
							this->Vx = 2;
							Waitframes(8);
							StopIt --;
						}
						else if ( IcyBlock && StopIt == -2 ) {
							this->Vx = 1;
							Waitframes(16);
							StopIt = 1;
						}
						else if ( SyncBlock ) {
							Screen->D[0] = 2;
							Waitframe();
							this->Vx = 2;
							Waitframes(2);
							Screen->D[0] = 0;
							Waitframes(6);
						}
						undercombo = Screen->ComboD[this->Y + (this->X >> 4)];
						if ( GravityBlock || SwapBlock || SyncBlock )
							StopIt ++;
					}
					this->Vx = 0;
					Screen->ComboD[this->Y + (this->X >> 4)] = this->Data;
					if ( dontmovelink )
						NoAction();
					if ( this->Data == 27 ) {
						Game->PlaySound(27);
						Screen->ComboF[71] = 0;
						Quit();
					}
				}
				else if(Link->Dir == DIR_LEFT) {
					while((this->X > 0 && // Not at the edge of the screen
					!ComboFI(this->X - 1, this->Y, CF_NOBLOCKS) && // Not "No Push Block"
					Screen->ComboS[this->Y + ((this->X - 16) >> 4)] == 0000b || SwapBlock)
					&& StopIt < 1) { // Is walkable
						if ( !dontplaysound ) {
							Game->PlaySound(50);
							dontplaysound = true;
						}
						Screen->ComboD[this->Y + (this->X >> 4)] = undercombo;
						if ( SwapBlock ) {
							for(int i=0; i<8; i++){
								this->Vx = 2;
								WaitNoAction(1);
								Link->X -= 2;
							}
						}
						else if ( GravityBlock ) {
							this->Vx = -2;
							Waitframes(8);
							//dontmovelink = true;
						}
						else if ( IcyBlock && StopIt <= 0 && StopIt != -2 ) {
							this->Vx = -2;
							Waitframes(8);
							StopIt --;
						}
						else if ( IcyBlock && StopIt == -2 ) {
							this->Vx = -1;
							Waitframes(16);
							StopIt = 1;
						}
						else if ( SyncBlock ) {
							Screen->D[0] = 4;
							Waitframe();
							this->Vx = -2;
							Waitframes(2);
							Screen->D[0] = 0;
							Waitframes(6);
						}
						undercombo = Screen->ComboD[this->Y + (this->X >> 4)];
						if ( GravityBlock || SwapBlock || SyncBlock )
							StopIt ++;
					}
					this->Vx = 0;
					if ( specialroom == 1 && this->Y + (this->X >> 4) == 133 && !Screen->State[ST_SECRET] ) {
						Screen->Message(37);
						WaitNoAction();
						this->X = 192;
						this->Y = 32;
						Link->X = 176;
						Link->Y = 32;
					}
					Screen->ComboD[this->Y + (this->X >> 4)] = this->Data;
					if ( dontmovelink )
						NoAction();
					if ( this->Data == 27 ) {
						Game->PlaySound(27);
						Screen->ComboF[71] = 0;
						Quit();
					}
				}
				else if(Link->Dir == DIR_DOWN) {
					while((this->Y < 160 && // Not at the edge of the screen
					!ComboFI(this->X, this->Y + 16, CF_NOBLOCKS) && // Not "No Push Block"
					Screen->ComboS[(this->Y + 16) + (this->X >> 4)] == 0000b || SwapBlock)
					&& StopIt < 1) { // Is walkable
						if ( !dontplaysound ) {
							Game->PlaySound(50);
							dontplaysound = true;
						}
						Screen->ComboD[this->Y + (this->X >> 4)] = undercombo;
						if ( SwapBlock ) {
							for(int i=0; i<8; i++){
								this->Vy = -2;
								WaitNoAction(1);
								Link->Y += 2;
							}
						}
						else if ( GravityBlock ) {
							this->Vy = 2;
							Waitframes(8);
							//dontmovelink = true;
						}
						else if ( IcyBlock && StopIt <= 0 && StopIt != -2 ) {
							this->Vy = 2;
							Waitframes(8);
							StopIt --;
						}
						else if ( IcyBlock && StopIt == -2 ) {
							this->Vy = 1;
							Waitframes(16);
							StopIt = 1;
						}
						else if ( SyncBlock ) {
							Screen->D[0] = 3;
							Waitframe();
							this->Vy = 2;
							Waitframes(2);
							Screen->D[0] = 0;
							Waitframes(6);
						}
						undercombo = Screen->ComboD[this->Y + (this->X >> 4)];
						if ( GravityBlock || SwapBlock || SyncBlock )
							StopIt ++;
					}
					this->Vy = 0;
					if ( specialroom == 1 && this->Y + (this->X >> 4) == 99 && !Screen->State[ST_SECRET] ) {
						Screen->Message(37);
						WaitNoAction();
						this->X = 192;
						this->Y = 32;
						Link->X = 192;
						Link->Y = 48;
					}
					Screen->ComboD[this->Y + (this->X >> 4)] = this->Data;
					if ( dontmovelink )
						NoAction();
					if ( this->Data == 27 ) {
						Game->PlaySound(27);
						Screen->ComboF[71] = 0;
						Quit();
					}
				}
				else if(Link->Dir == DIR_UP) {
					while((this->Y > 0 && // Not at the edge of the screen
					!ComboFI(this->X, this->Y - 1, CF_NOBLOCKS) && // Not "No Push Block"
					Screen->ComboS[(this->Y - 16) + (this->X >> 4)] == 0000b || SwapBlock)
					&& StopIt < 1) { // Is walkable
						if ( !dontplaysound ) {
							Game->PlaySound(50);
							dontplaysound = true;
						}
						Screen->ComboD[this->Y + (this->X >> 4)] = undercombo;
						if ( SwapBlock ) {
							for(int i=0; i<8; i++){
								this->Vy = 2;
								WaitNoAction(1);
								Link->Y -= 2;
							}
						}
						else if ( GravityBlock ) {
							this->Vy = -2;
							Waitframes(8);
							//dontmovelink = true;
						}
						else if ( IcyBlock && StopIt <= 0 && StopIt != -2 ) {
							this->Vy = -2;
							Waitframes(8);
							StopIt --;
						}
						else if ( IcyBlock && StopIt == -2 ) {
							this->Vy = -1;
							Waitframes(16);
							StopIt = 1;
						}
						else if ( SyncBlock ) {
							Screen->D[0] = 1;
							Waitframe();
							this->Vy = -2;
							Waitframes(2);
							Screen->D[0] = 0;
							Waitframes(6);
						}
						undercombo = Screen->ComboD[this->Y + (this->X >> 4)];
						if ( GravityBlock || SwapBlock || SyncBlock )
							StopIt ++;
					}
					this->Vy = 0;
					Screen->ComboD[this->Y + (this->X >> 4)] = this->Data;
					if ( dontmovelink )
						NoAction();
					if ( this->Data == 27 ) {
						Game->PlaySound(27);
						Screen->ComboF[71] = 0;
						Quit();
					}
				}
				// Reset the frame counter
				framecounter = 0;
			}
			Waitframe();
		}
	}
}

ffc script BlockSyncing{
	void run(){
		while(true){
			if ( Screen->D[0] == 1 )
				Screen->D[0] = -1;
			if ( Screen->D[0] == 2 )
				Screen->D[0] = -2;
			if ( Screen->D[0] == 3 )
				Screen->D[0] = -3;
			if ( Screen->D[0] == 4 )
				Screen->D[0] = -4;
			Waitframe();
		}
	}
}

// Ice trigger script
ffc script IceTrigger {
	void run() {
		ffc blocks[31];
		int triggerx[31];
		int triggery[31];
		int num_ice_blocks = 0;
		int num_triggers = 0;
		int good_counter = 0;
		
		for(int i = 0; i < 176 && num_triggers < 31; i++) {
			if(Screen->ComboF[i] == CF_BLOCKTRIGGER || Screen->ComboI[i] == CF_BLOCKTRIGGER) {
				triggerx[num_triggers] = (i % 16) * 16;
				triggery[num_triggers] = Floor(i / 16) * 16;
				num_triggers++;
			}
		}
		if(num_triggers == 0) Quit();
		
		for(int i = 1; i <= 32; i++) {
			ffc temp = Screen->LoadFFC(i);
			if(temp->Script == ICE_BLOCK_SCRIPT) {
				blocks[num_ice_blocks] = temp;
				num_ice_blocks++;
			}
		}
		if(num_ice_blocks == 0) Quit();
		
		int actualgoodcounter;
		while(true) {
			for(int i = 0; i < num_ice_blocks; i++) {
				//Check if blocks are on switches and not moving
				for(int j = 0; j < num_triggers; j++) {
					if(blocks[i]->X == triggerx[j] && blocks[i]->Y == triggery[j] && blocks[i]->Vx == 0 && blocks[i]->Vy == 0) {
						good_counter++;
						break;
					}
				}
			}
			if ( good_counter == num_triggers )
				actualgoodcounter ++;
			else
				actualgoodcounter = 0;
			if(actualgoodcounter > 1) {
				Game->PlaySound(SFX_SECRET);
				Screen->TriggerSecrets();
				if((Screen->Flags[SF_SECRETS] & 2) == 0) Screen->State[ST_SECRET] = true;
				Quit();
			}
			good_counter = 0;
			Waitframe();
		}
	}
}

ffc script WavyFireballShooter{
	void run(){
		int timer = Rand(240) + 30;
		while(true){
			if ( timer == 0 ) {
				int angle = DegtoRad(Angle(this->X, this->Y, Link->X, Link->Y));
				for (int i = 1; i <= 5; i++) {
					eweapon fireball = FireEWeapon(EW_FIREBALL, this->X, this->Y, angle, 150, 4, -1, 0, 0);
					SetEWeaponMovement(fireball, EWM_SINE_WAVE, 8, 15);
					Game->PlaySound(40);
					Waitframes(3);
				}
				timer = Rand(240) + 60;
			}
			else if ( timer > 0 )
				timer --;
			Waitframe();
		}
	}
}

ffc script ReaimFireballShooter{
	void run(){
		int timer = Rand(240) + 30;
		while(true){
			if ( timer == 0 ) {
				Game->PlaySound(40);
				for (int i = 45; i <= 315; i+= 90) {
					eweapon fireball = FireEWeapon(EW_FIREBALL, this->X, this->Y, DegtoRad(i), 150, 4, -1, 0, 0);
					SetEWeaponMovement(fireball, EWM_HOMING_REAIM, 1, 35);
				}
				timer = Rand(240) + 60;
			}
			else if ( timer > 0 )
				timer --;
			Waitframe();
		}
	}
}

ffc script DoubleFireballShooter{
	void run(){
		int timer = Rand(60) + 30;
		while(true){
			if ( timer == 0 ) {
				Game->PlaySound(40);
				int angle = Angle(this->X, this->Y, Link->X, Link->Y);
				eweapon fireball = FireEWeapon(EW_FIREBALL, this->X, this->Y, DegtoRad(angle+25), 150, 4, -1, 0, 0);
				eweapon fireball2 = FireEWeapon(EW_FIREBALL, this->X, this->Y, DegtoRad(angle-25), 150, 4, -1, 0, 0);
				timer = 60;
			}
			else if ( timer > 0 )
				timer --;
			Waitframe();
		}
	}
}

ffc script AimSpreadFireballShooter{
	void run(){
		int timer = Rand(60) + 30;
		while(true){
			if ( timer == 0 ) {
				Game->PlaySound(40);
				int angle = Angle(this->X, this->Y, Link->X, Link->Y);
				for (int i = -60; i <= 60; i+= 30) {
					eweapon fireball = FireEWeapon(EW_FIREBALL, this->X, this->Y, DegtoRad(angle+i), 150, 4, -1, 0, 0);
					SetEWeaponMovement(fireball, EWM_HOMING, DegtoRad(1), 120);
				}
				timer = Rand(60) + 60;
			}
			else if ( timer > 0 )
				timer --;
			Waitframe();
		}
	}
}

ffc script YoloFireballShooter{
	void run(){
		int timer = 4;
		int angle = 150;
		while(true){
			if ( timer == 0 ) {
				Game->PlaySound(40);
				eweapon fireball = FireEWeapon(EW_FIREBALL, this->X, this->Y, DegtoRad(angle), 150, 4, -1, 0, 0);
				angle += 4;
			}
			else if ( timer > 0 )
				timer --;
			Waitframe();
		}
	}
}

ffc script GatesFireballShooter{
	void run(){
		int timer = 4;
		int angle = 90;
		while(true){
			if ( timer == 0 ) {
				for (int i = 0; i <= 4; i++) {
					Game->PlaySound(40);
					eweapon fireball = FireEWeapon(EW_FIREBALL, this->X, this->Y, DegtoRad(angle), 100, 4, -1, 0, 0);
					eweapon fireball2 = FireEWeapon(EW_FIREBALL, this->X, this->Y, DegtoRad(angle+180), 100, 4, -1, 0, 0);
					Waitframes(8);
				}
				if ( angle == 0 )
					angle = 90;
				else
					angle = 0;
			}
			else if ( timer > 0 )
				timer --;
			Waitframe();
		}
	}
}

ffc script ABInputFireballShooter{
	void run(){
		int timer = Rand(240) + 30;
		while(true){
			if ( timer > 8 && (Link->InputA || Link->InputB) )
				timer = 8;
			if ( timer == 0 ) {
				int angle = DegtoRad(Angle(this->X, this->Y, Link->X, Link->Y));
				eweapon fireball = FireEWeapon(EW_FIREBALL, this->X, this->Y, angle, 150, 4, -1, 0, 0);
				Game->PlaySound(40);
				timer = Rand(240) + 60;
			}
			else if ( timer > 0 )
				timer --;
			Waitframe();
		}
	}
}

ffc script LikeLikeInside{
	void run(){
		Waitframes(2);
		Link->DrawXOffset = -1001;
	}
}

ffc script LikeLikeWarper{
	void run(){
		Link->Item[151] = true;
		while(true){
			if ( !Link->Item[151] )
				this->Data = 888;
			Waitframe();
		}
	}
}

item script KeyForAnotherLevelMessage{
	void run(int level, int m){
		Screen->Message(m);
		Game->LKeys[level]++;
	}
}

ffc script Level1FinalPuzzle{
	void run(){
		if ( Screen->State[ST_SECRET] == true )
			Quit();
		while(true){
			if ( Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] == 532 ) {
				Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] = 0;
				if ( Screen->ComboD[69] == 532 && Screen->ComboD[70] == 0 && Screen->ComboD[71] == 532 && Screen->ComboD[72] == 532 &&
				Screen->ComboD[85] == 0 && Screen->ComboD[86] == 532 && Screen->ComboD[87] == 532 && Screen->ComboD[88] == 0 &&
				Screen->ComboD[101] == 0 && Screen->ComboD[102] == 0 && Screen->ComboD[103] == 0 && Screen->ComboD[104] == 0 &&
				Screen->ComboD[117] == 0 && Screen->ComboD[118] == 532 && Screen->ComboD[119] == 0 && Screen->ComboD[120] == 532 ) {
					Game->PlaySound(27);
					Screen->TriggerSecrets();
					Screen->State[ST_SECRET] = true;
					Quit();
				}
			}
			Waitframe();
		}
	}
}

ffc script Level2ImagePuzzle{
	void run(){
		if ( Screen->State[ST_SECRET] == true )
			Quit();
		while(true){
			if ( Screen->ComboD[106] == 1044 && Screen->ComboD[107] == 1045
			&& Screen->ComboD[108] == 1046 && Screen->ComboD[122] == 1048 && Screen->ComboD[123] == 1049
			&& Screen->ComboD[124] == 1050 && Screen->ComboD[138] == 1052 && Screen->ComboD[139] == 1053 ) {
				Game->PlaySound(27);
				Screen->TriggerSecrets();
				Screen->State[ST_SECRET] = true;
				Quit();
			}
			Waitframe();
		}
	}
}

ffc script BossMusic{
	void run(int type){
		if ( Screen->State[ST_SECRET] == true )
			Quit();
		int dmapmusic[256];
		int bossmusica[256];
		int bossmusicb[256];
		int bossmusicc[256];
		Game->GetDMapMusicFilename(Game->GetCurDMap(), dmapmusic);
		Game->GetDMapMusicFilename(9, bossmusica);
		Game->GetDMapMusicFilename(12, bossmusicb);
		Game->GetDMapMusicFilename(11, bossmusicc);
		if ( type == 0 )
			Game->PlayEnhancedMusic(bossmusica, Game->GetDMapMusicTrack(9));
		else if ( type == 1 )
			Game->PlayEnhancedMusic(bossmusicb, Game->GetDMapMusicTrack(12));
		else
			Game->PlayEnhancedMusic(bossmusicc, Game->GetDMapMusicTrack(11));
		while(true){
			if ( Screen->State[ST_SECRET] == true ) {
				Game->PlayEnhancedMusic(dmapmusic, Game->GetDMapMusicTrack(Game->GetCurDMap()));
				Quit();
			}
			Waitframe();
		}
	}
}

ffc script Ghini{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
		Ghost_SetFlag(GHF_IGNORE_NO_ENEMY);
		Ghost_SetFlag(GHF_MOVE_OFFSCREEN);
		int direction = Choose(DIR_RIGHT, DIR_LEFT);
		if ( direction == DIR_RIGHT )
			Ghost_X = -32;
		else
			Ghost_X = 288;
		Ghost_Y = Rand(16, 144);
		if ( direction == DIR_RIGHT )
			Ghost_Transform(this, ghost, 1089, -1, -1, -1);
		bool halfframe;
		Ghost_Waitframes(this, ghost, 45+Rand(0, 120));
		//int fireshot;
		while(true){
			if ( direction == DIR_RIGHT ) {
				if ( halfframe )
					Ghost_X ++;
				Ghost_X ++;
			}
			if ( direction == DIR_LEFT ) {
				if ( halfframe )
					Ghost_X --;
				Ghost_X --;
			}
			if ( halfframe )
				halfframe = false;
			else
				halfframe = true;
			if ( Ghost_X < -32 ) {
				Ghost_X = -32;
				Ghost_Y = Rand(16, 144);
				direction = DIR_RIGHT;
				Ghost_Transform(this, ghost, 1089, -1, -1, -1);
				Ghost_Waitframes(this, ghost, Rand(0, 120));
				//fireshot = 0;
			}
			if ( Ghost_X > 288 ) {
				Ghost_X = 288;
				Ghost_Y = Rand(16, 144);
				direction = DIR_LEFT;
				Ghost_Transform(this, ghost, 1088, -1, -1, -1);
				Ghost_Waitframes(this, ghost, Rand(0, 120));
				//fireshot = 0;
			}
			//if ( (fireshot == 0 && Ghost_X > Link->X-4 && Ghost_X < Link->X+4) || fireshot == 5 || fireshot == 9 || fireshot == 13 || fireshot == 17 || fireshot == 21 ) {
			//	if ( fireshot == 0 )
			//		fireshot ++;
			//	eweapon fireball = FireAimedEWeapon(EW_FIREBALL, Ghost_X, Ghost_Y, 0, 75, 4, -1, -1, 0);
			//	SetEWeaponMovement(fireball, EWM_HOMING_REAIM, 2, 60);
			//}
			//if ( fireshot > 0 )
			//	fireshot ++;
			//if ( fireshot == 21 )
			//	fireshot = -1;
			Ghost_Waitframe(this, ghost);
		}
	}
}

ffc script CursorEyeball{
	void run(){
		while(true){
			int direction = AngleDir8(Angle(this->X+8, this->Y+8, Link->InputMouseX, Link->InputMouseY));
			if ( direction == DIR_UP )
				Screen->ComboD[ComboAt(this->X, this->Y)] = 132;
			if ( direction == DIR_RIGHTUP )
				Screen->ComboD[ComboAt(this->X, this->Y)] = 133;
			if ( direction == DIR_RIGHT )
				Screen->ComboD[ComboAt(this->X, this->Y)] = 134;
			if ( direction == DIR_RIGHTDOWN )
				Screen->ComboD[ComboAt(this->X, this->Y)] = 135;
			if ( direction == DIR_DOWN )
				Screen->ComboD[ComboAt(this->X, this->Y)] = 136;
			if ( direction == DIR_LEFTDOWN )
				Screen->ComboD[ComboAt(this->X, this->Y)] = 137;
			if ( direction == DIR_LEFT )
				Screen->ComboD[ComboAt(this->X, this->Y)] = 138;
			if ( direction == DIR_LEFTUP )
				Screen->ComboD[ComboAt(this->X, this->Y)] = 139;
			Waitframe();
		}
	}
}

item script TriforceGet{
	void run(){
		Screen->D[0] = 1;
		TriforcePieces ++;
		if ( Game->GetCurLevel() == 1 ) {
			Link->Item[166] = true;
			Link->Item[167] = true;
		}
		if ( Game->GetCurLevel() == 2 ) {
			Link->Item[168] = true;
			Link->Item[169] = true;
		}
		if ( Game->GetCurLevel() == 3 ) {
			Link->Item[170] = true;
			Link->Item[171] = true;
		}
	}
}

ffc script TriforceAnimation{
	void run(){
		Screen->D[0] = 0;
		while(Screen->D[0] == 0)
			Waitframe();
		if ( Screen->ComboD[80] == 484 )
			Screen->ComboD[80] = 414;
		if ( Screen->ComboD[95] == 487 )
			Screen->ComboD[95] = 415;
		if ( Screen->ComboD[167] == 454 )
			Screen->ComboD[167] = 410;
		if ( Screen->ComboD[168] == 455 )
			Screen->ComboD[168] = 410;
		Game->PlayMIDI(0);
		Game->PlaySound(69);
		Link->Invisible = true;
		item Triforce = CreateItemAt(20, Link->X, Link->Y-17);
		Triforce->HitXOffset = -1000;
		int TriforceAnimationFrames;
		int RefillFrame;
		
		int TriangleLinesDegree;
		int TriangleLinesPointAX;
		int TriangleLinesPointAY;
		int TriangleLinesPointBX;
		int TriangleLinesPointBY;
		int TriangleLinesPointCX;
		int TriangleLinesPointCY;
		int TriangleLinesRadius = 5;
		bool TriangleLines;
		
		int TriangleOutroPointAX;
		int TriangleOutroPointAY;
		int TriangleOutroPointBX;
		int TriangleOutroPointBY;
		int TriangleOutroPointCX;
		int TriangleOutroPointCY;
		int TriangleOutroRadius = 5;
		bool TriangleOutro;
		
		int Sideshoot;
		int Centershoot;
		int CentershootDegree;
		
		int InLinesPointAX[200];
		int InLinesPointAY[200];
		int InLinesPointBX[200];
		int InLinesPointBY[200];
		int InLinesPointCX[200];
		int InLinesPointCY[200];
		int InLinesRadius[200];
		int InLinesInUse[200];
		
		int TColor;
		int ColorChange;
		while(true){
			Screen->FastTile(2, Link->X, Link->Y, 32073, 6, OP_OPAQUE);
			
			if ( (TriforceAnimationFrames >= 20 && TriforceAnimationFrames <= 23) || (TriforceAnimationFrames >= 28 && TriforceAnimationFrames <= 31)
			|| (TriforceAnimationFrames >= 36 && TriforceAnimationFrames <= 39) || (TriforceAnimationFrames >= 44 && TriforceAnimationFrames <= 47)
			|| (TriforceAnimationFrames >= 52 && TriforceAnimationFrames <= 55) || (TriforceAnimationFrames >= 60 && TriforceAnimationFrames <= 63) )
				Screen->Rectangle(6, 0, 0, 256, 176, 0x08, 1, 0, 0, 0, true, OP_OPAQUE);
			
			if ( TriforceAnimationFrames > 70 && RefillFrame == 0 && Link->HP < Link->MaxHP ) {
				Game->PlaySound(23);
				Link->HP += 4;
			}
			if ( Link->HP > Link->MaxHP )
				Link->HP = Link->MaxHP;
			if ( RefillFrame > 1 )
				RefillFrame = 0;
			else
				RefillFrame ++;
			
			TriangleLinesDegree += 4;
			if(TriangleLinesDegree < -360)TriangleLinesDegree+=360; //Wrap if below -360. ???? i dont know
			else if(TriangleLinesDegree > 360)TriangleLinesDegree-=360; //Wrap if above 360. ???? i dont know
			
			if ( TriangleLines && TriangleLinesRadius < 40 && TriforceAnimationFrames < 480 )
				TriangleLinesRadius ++;
			if ( TriforceAnimationFrames == 70 ) {
				TriangleLinesDegree = 0;
				TriangleLines = true;
			}
			TriangleLinesPointAX = Triforce->X+8 + TriangleLinesRadius*Cos(TriangleLinesDegree+270);
			TriangleLinesPointAY = Triforce->Y+12 + TriangleLinesRadius*Sin(TriangleLinesDegree+270);
			TriangleLinesPointBX = Triforce->X+8 + TriangleLinesRadius*Cos(TriangleLinesDegree+150);
			TriangleLinesPointBY = Triforce->Y+12 + TriangleLinesRadius*Sin(TriangleLinesDegree+150);
			TriangleLinesPointCX = Triforce->X+8 + TriangleLinesRadius*Cos(TriangleLinesDegree+30);
			TriangleLinesPointCY = Triforce->Y+12 + TriangleLinesRadius*Sin(TriangleLinesDegree+30);
			if ( TriangleLines ) {
				int tlplayer = 2;
				if ( TriangleOutroRadius >= 40 )
					tlplayer = 1;
				Screen->Line(tlplayer, TriangleLinesPointAX, TriangleLinesPointAY, TriangleLinesPointBX, TriangleLinesPointBY, 0x01, 1, 0, 0, 0, OP_OPAQUE);
				Screen->Line(tlplayer, TriangleLinesPointAX, TriangleLinesPointAY, TriangleLinesPointCX, TriangleLinesPointCY, 0x01, 1, 0, 0, 0, OP_OPAQUE);
				Screen->Line(tlplayer, TriangleLinesPointBX, TriangleLinesPointBY, TriangleLinesPointCX, TriangleLinesPointCY, 0x01, 1, 0, 0, 0, OP_OPAQUE);
			}
			
			Sideshoot ++;
			if ( TriforceAnimationFrames == 70 || Sideshoot > 6 )
				Sideshoot = 0;
			if ( TriforceAnimationFrames >= 70 && Sideshoot == 0 && TriforceAnimationFrames <= 280 ) {
				eweapon dumtriforce = FireEWeapon(EW_SCRIPT10, 0, 24, 0, 200, 0, 105, 0, EWF_NO_COLLISION);
				eweapon dumtriforce2 = FireEWeapon(EW_SCRIPT10, 240, 124, PI, 200, 0, 105, 0, EWF_NO_COLLISION);
			}
			
			CentershootDegree -= 9;
			if(CentershootDegree < -360)CentershootDegree+=360; //Wrap if below -360. ???? i dont know
			else if(CentershootDegree > 360)CentershootDegree-=360; //Wrap if above 360. ???? i dont know
			
			Centershoot ++;
			if ( TriforceAnimationFrames == 240 || Centershoot > 2 )
				Centershoot = 0;
			if ( TriforceAnimationFrames >= 240 && Centershoot == 0 && TriforceAnimationFrames <= 600 ) {
				eweapon dumtriforce = FireEWeapon(EW_SCRIPT10, Triforce->X, Triforce->Y+3, DegtoRad(0+CentershootDegree), 250, 0, 105, 0, EWF_NO_COLLISION);
				eweapon dumtriforce2 = FireEWeapon(EW_SCRIPT10, Triforce->X, Triforce->Y+3, DegtoRad(120+CentershootDegree), 250, 0, 105, 0, EWF_NO_COLLISION);
				eweapon dumtriforce3 = FireEWeapon(EW_SCRIPT10, Triforce->X, Triforce->Y+3, DegtoRad(240+CentershootDegree), 250, 0, 105, 0, EWF_NO_COLLISION);
			}
			
			if ( TriforceAnimationFrames >= 380 )
				TriangleLinesRadius += 4;
			
			if ( TriforceAnimationFrames >= 440 && Sideshoot == 0 && TriforceAnimationFrames <= 560 ) {
				int okk;
				while(okk != -1){
					if ( InLinesInUse[okk] == 0 ) {
						InLinesInUse[okk] = 1;
						InLinesRadius[okk] = 320;
						okk = -1;
					}
					else
						okk ++;
				}
			}
			for (int i = 0; i < 200; i++) {
				if ( InLinesRadius[i] >= 4 ) {
					InLinesPointAX[i] = Triforce->X+8 + InLinesRadius[i]*Cos(TriangleLinesDegree+i*6+270);
					InLinesPointAY[i] = Triforce->Y+12 + InLinesRadius[i]*Sin(TriangleLinesDegree+i*6+270);
					InLinesPointBX[i] = Triforce->X+8 + InLinesRadius[i]*Cos(TriangleLinesDegree+i*6+150);
					InLinesPointBY[i] = Triforce->Y+12 + InLinesRadius[i]*Sin(TriangleLinesDegree+i*6+150);
					InLinesPointCX[i] = Triforce->X+8 + InLinesRadius[i]*Cos(TriangleLinesDegree+i*6+30);
					InLinesPointCY[i] = Triforce->Y+12 + InLinesRadius[i]*Sin(TriangleLinesDegree+i*6+30);
					Screen->Line(2, InLinesPointAX[i], InLinesPointAY[i], InLinesPointBX[i], InLinesPointBY[i], 0x01, 1, 0, 0, 0, OP_OPAQUE);
					Screen->Line(2, InLinesPointAX[i], InLinesPointAY[i], InLinesPointCX[i], InLinesPointCY[i], 0x01, 1, 0, 0, 0, OP_OPAQUE);
					Screen->Line(2, InLinesPointBX[i], InLinesPointBY[i], InLinesPointCX[i], InLinesPointCY[i], 0x01, 1, 0, 0, 0, OP_OPAQUE);
					InLinesRadius[i] -= 4;
				}
			}
			
			if ( TriangleOutro )
				TriangleOutroRadius += 3;
			if ( TriforceAnimationFrames == 645 )
				TriangleOutro = true;
			TriangleOutroPointAX = Triforce->X+8 + TriangleOutroRadius*Cos(270);
			TriangleOutroPointAY = Triforce->Y+12 + TriangleOutroRadius*Sin(270);
			TriangleOutroPointBX = Triforce->X+8 + TriangleOutroRadius*Cos(150);
			TriangleOutroPointBY = Triforce->Y+12 + TriangleOutroRadius*Sin(150);
			TriangleOutroPointCX = Triforce->X+8 + TriangleOutroRadius*Cos(30);
			TriangleOutroPointCY = Triforce->Y+12 + TriangleOutroRadius*Sin(30);
			if ( TriangleOutro )
				Screen->Triangle(1, TriangleOutroPointAX, TriangleOutroPointAY, TriangleOutroPointBX, TriangleOutroPointBY, TriangleOutroPointCX, TriangleOutroPointCY, 1, 1, 0, 0, 23484, PT_TEXTURE);
			
			if ( TriforceAnimationFrames >= 880 )
				this->Data = 888;
			
			TriforceAnimationFrames ++;
			NoAction();
			Link->PressStart = false;
			Link->PressMap = false;
			Link->InputStart = false;
			Link->InputMap = false;
			Waitframe();
		}
	}
}

ffc script CirclingTraps{
	void run(int type){
		int TrapX[20];
		int TrapY[20];
		int TrapsDegree;
		int TrapsDegreePlus;
		
		if ( type == 0 ) {
			TrapX[0] = 112;
			TrapY[0] = 80;
		}
		if ( type == 1 ) {
			TrapX[0] = 120;
			TrapY[0] = 80;
		}
		while(true){
			
			TrapsDegree --;
			if(TrapsDegree < -360)TrapsDegree+=360; //Wrap if below -360. ???? i dont know
			else if(TrapsDegree > 360)TrapsDegree-=360; //Wrap if above 360. ???? i dont know
			
			if ( type == 0 ) {
				TrapsDegreePlus ++; //not gay
			}
			if ( type == 1 ) {
				TrapsDegreePlus += 1.5;
			}
			if ( type == 2 ) {
				TrapsDegreePlus += 0.75;
			}
			if(TrapsDegreePlus < -360)TrapsDegreePlus+=360; //Wrap if below -360. ???? i dont know
			else if(TrapsDegreePlus > 360)TrapsDegreePlus-=360; //Wrap if above 360. ???? i dont know
			
			if ( type == 0 ) {
				TrapX[1] = 112 + 16*Cos(TrapsDegree+45);
				TrapY[1] = 80 + 16*Sin(TrapsDegree+45);
				TrapX[2] = 112 + 16*Cos(TrapsDegree+135);
				TrapY[2] = 80 + 16*Sin(TrapsDegree+135);
				TrapX[3] = 112 + 16*Cos(TrapsDegree+225);
				TrapY[3] = 80 + 16*Sin(TrapsDegree+225);
				TrapX[4] = 112 + 16*Cos(TrapsDegree+315);
				TrapY[4] = 80 + 16*Sin(TrapsDegree+315);
				
				TrapX[5] = 112 + 32*Cos(TrapsDegree+45);
				TrapY[5] = 80 + 32*Sin(TrapsDegree+45);
				TrapX[6] = 112 + 32*Cos(TrapsDegree+135);
				TrapY[6] = 80 + 32*Sin(TrapsDegree+135);
				TrapX[7] = 112 + 32*Cos(TrapsDegree+225);
				TrapY[7] = 80 + 32*Sin(TrapsDegree+225);
				TrapX[8] = 112 + 32*Cos(TrapsDegree+315);
				TrapY[8] = 80 + 32*Sin(TrapsDegree+315);
				
				TrapX[9] = 112 + 48*Cos(TrapsDegree+45);
				TrapY[9] = 80 + 48*Sin(TrapsDegree+45);
				TrapX[10] = 112 + 48*Cos(TrapsDegree+135);
				TrapY[10] = 80 + 48*Sin(TrapsDegree+135);
				TrapX[11] = 112 + 48*Cos(TrapsDegree+225);
				TrapY[11] = 80 + 48*Sin(TrapsDegree+225);
				TrapX[12] = 112 + 48*Cos(TrapsDegree+315);
				TrapY[12] = 80 + 48*Sin(TrapsDegree+315);
			}
			if ( type == 1 ) {
				TrapX[1] = 120 + 24*Cos(TrapsDegree+45);
				TrapY[1] = 80 + 24*Sin(TrapsDegree+45);
				TrapX[2] = 120 + 24*Cos(TrapsDegree+165);
				TrapY[2] = 80 + 24*Sin(TrapsDegree+165);
				TrapX[3] = 120 + 24*Cos(TrapsDegree+285);
				TrapY[3] = 80 + 24*Sin(TrapsDegree+285);
				
				TrapX[4] = 120 + 48*Cos(TrapsDegreePlus+45);
				TrapY[4] = 80 + 48*Sin(TrapsDegreePlus+45);
				TrapX[5] = 120 + 48*Cos(TrapsDegreePlus+135);
				TrapY[5] = 80 + 48*Sin(TrapsDegreePlus+135);
				TrapX[6] = 120 + 48*Cos(TrapsDegreePlus+225);
				TrapY[6] = 80 + 48*Sin(TrapsDegreePlus+225);
				TrapX[7] = 120 + 48*Cos(TrapsDegreePlus+315);
				TrapY[7] = 80 + 48*Sin(TrapsDegreePlus+315);
			}
			if ( type == 2 ) {
				TrapX[0] = 120 + 48*Cos(TrapsDegreePlus+90);
				TrapY[0] = 80 + 48*Sin(TrapsDegreePlus+90);
				TrapX[1] = 120 + 48*Cos(TrapsDegreePlus+150);
				TrapY[1] = 80 + 48*Sin(TrapsDegreePlus+150);
				TrapX[2] = 120 + 48*Cos(TrapsDegreePlus+210);
				TrapY[2] = 80 + 48*Sin(TrapsDegreePlus+210);
				TrapX[3] = 120 + 48*Cos(TrapsDegreePlus+270);
				TrapY[3] = 80 + 48*Sin(TrapsDegreePlus+270);
				TrapX[4] = 120 + 48*Cos(TrapsDegreePlus+330);
				TrapY[4] = 80 + 48*Sin(TrapsDegreePlus+330);
				TrapX[5] = 120 + 48*Cos(TrapsDegreePlus+30);
				TrapY[5] = 80 + 48*Sin(TrapsDegreePlus+30);
			}
			
			for (int i = 0; i < 20; i++) {
				if ( TrapX[i] != 0 || TrapY[i] != 0) {
					Screen->FastCombo(2, TrapX[i], TrapY[i], 1047, 7, OP_OPAQUE);
					if ( RectCollision(TrapX[i]+5, TrapY[i]+5, TrapX[i]+10, TrapY[i]+10, Link->X, Link->Y+2, Link->X+15, Link->Y+15) ) {
						eweapon e = FireEWeapon(EW_SCRIPT10, Link->X+InFrontX(Link->Dir, 12), Link->Y+InFrontY(Link->Dir, 12), 0, 0, 4, -1, -1, EWF_UNBLOCKABLE);
						e->Dir = Link->Dir;
						e->DrawYOffset = -1000;
						SetEWeaponLifespan(e, EWL_TIMER, 1);
						SetEWeaponDeathEffect(e, EWD_VANISH, 0);
					}
				}
			}
			Waitframe();
		}
	}
}

ffc script Level3FinalPuzzle{
	void run(){
		bool trigger1;
		bool trigger2;
		bool trigger3;
		int sequence;
		while(true){
			if ( Screen->State[ST_SECRET] == true )
				Quit();
			
			if ( ComboAt(Link->X+8, Link->Y+12) == 74 && !trigger1 ) {
				trigger1 = true;
				trigger2 = false;
				trigger3 = false;
				Screen->ComboD[74] = 1091; Screen->ComboD[76] = 624;
				Screen->ComboD[106] = 1090; Screen->ComboD[108] = 625;
				Screen->ComboD[138] = 1090; Screen->ComboD[140] = 625;
				if ( sequence == 0 )
					sequence = 1;
				else if ( sequence == 4 )
					sequence = 5;
				else
					sequence = 0;
			}
			if ( ComboAt(Link->X+8, Link->Y+12) == 106 && !trigger2 ) {
				trigger1 = false;
				trigger2 = true;
				trigger3 = false;
				Screen->ComboD[74] = 1090; Screen->ComboD[76] = 625;
				Screen->ComboD[106] = 1091; Screen->ComboD[108] = 624;
				Screen->ComboD[138] = 1090; Screen->ComboD[140] = 625;
				if ( sequence == 2 )
					sequence = 3;
				else if ( sequence == 5 )
					sequence = 6;
				else
					sequence = 0;
			}
			if ( ComboAt(Link->X+8, Link->Y+12) == 138 && !trigger3 ) {
				trigger1 = false;
				trigger2 = false;
				trigger3 = true;
				Screen->ComboD[74] = 1090; Screen->ComboD[76] = 625;
				Screen->ComboD[106] = 1090; Screen->ComboD[108] = 625;
				Screen->ComboD[138] = 1091; Screen->ComboD[140] = 624;
				if ( sequence == 1 )
					sequence = 2;
				else if ( sequence == 3 )
					sequence = 4;
				else
					sequence = 0;
			}
			if ( sequence == 6 ) {
				Game->PlaySound(27);
				Screen->TriggerSecrets();
				Screen->State[ST_SECRET] = true;
				Screen->ComboD[76] = 624;
				Screen->ComboD[108] = 624;
				Screen->ComboD[140] = 624;
				Quit();
			}
			Waitframe();
		}
	}
}

ffc script BreakOfTakeABreak{
	void run(){
		while(true){
			TakeABreak --;
			Waitframe();
		}
	}
}

//D0: How to detect secrets
//0 = Detect trigger flags
//1 = Detect the script flag
//2 = Detect both trigger flags and the script flag
//D1: Condition for detecting secrets
//0 = Always detect
//1 = Don't detect if permanent secrets are activated
ffc script BetterStoneOfAgony{
	void run(int type, int condition){
		bool SecretDetected;
		bool OtherFrame;
		int LinkVibration;
		bool LinkOffset;
		int SFXRepeat;
		while(true){
			while( !Link->Item[BetterAgony_ID] || (condition == 1 && Screen->State[ST_SECRET]) ) { //halt the script
				LinkVibration = 0;
				if ( LinkOffset )
					Link->DrawYOffset ++; //revert drawoffset
				LinkOffset = false;
				SFXRepeat = 0;
				Waitframe();
			}
			if ( OtherFrame ) { //only check every other frame to prevent slowdown
				SecretDetected = false;
				for(int i = 0; i <= 6; i++) { //for all layers
					if ( i == 0 || Screen->LayerMap(i) != -1 ) { //dont check unvalid layers
						for(int j = 0; j <= 175; j++) { //all combos
							if ( Distance(Link->X, Link->Y, ComboX(j), ComboY(j)) <= BetterAgony_DetectionRadius ) //check distance
								if ( (IsATriggerFlag(GetLayerComboF(i, j)) && type != 1)
								|| (GetLayerComboF(i, j) == BetterAgony_DetectionFlag && type != 0) ) //check flag
									SecretDetected = true;
						}
					}
				}
			}
			if ( OtherFrame )
				OtherFrame = false;
			else
				OtherFrame = true;
			if ( SecretDetected ) {
				if ( BetterAgony_Vibrate == 1 ) { //link vibrates using drawoffset
					if ( LinkVibration == 0 ) {
						Link->DrawYOffset --;
						LinkOffset = true;
					}
					if ( LinkVibration == 3 ) {
						Link->DrawYOffset ++;
						LinkOffset = false;
					}
					LinkVibration ++;
					if ( LinkVibration > 5 )
						LinkVibration = 0;
				}
				if ( BetterAgony_SFX != 0 ) { //repeatedly played sfx
					if ( SFXRepeat == 0 )
						Game->PlaySound(BetterAgony_SFX);
					SFXRepeat ++;
					if ( SFXRepeat > BetterAgony_SFXRepeatRate )
						SFXRepeat = 0;
				}
				if ( BetterAgony_ComboID != 0 ) //indicator combo drawn on layer 7 above link
					Screen->FastCombo(7, Link->X, Link->Y-16, BetterAgony_ComboID, BetterAgony_ComboCSet, OP_OPAQUE);
			}
			else { //secrets not detected
				LinkVibration = 0;
				if ( LinkOffset )
					Link->DrawYOffset ++; //revert drawoffset
				LinkOffset = false;
				SFXRepeat = 0;
			}
			Waitframe();
		}
	}
}

bool IsATriggerFlag(int f) {
	if ( (f >= 3 && f <= 6) || f == 11 || (f >= 68 && f <= 90) ) //trigger flags
		return true;
	else
		return false;
}

ffc script ShuffleCave{
	void run(){
		int ShuffleTimer = Rand(30) + 120;
		while(true){
			if ( ShuffleTimer == 0 ) {
				int Shuffling;
				while(Shuffling < 80){
					bool PositionFound;
					int NewPosition;
					while(!PositionFound){
						NewPosition = Rand(175);
						if ( !Screen->isSolid(ComboX(NewPosition), ComboY(NewPosition)) && !Screen->isSolid(ComboX(NewPosition)+15, ComboY(NewPosition)+15) )
							PositionFound = true;
					}
					Link->X = ComboX(NewPosition);
					Link->Y = ComboY(NewPosition);
					Shuffling = Rand(100);
					Waitframes(8);
				}
				ShuffleTimer = Rand(60) + 120;
			}
			if ( ShuffleTimer > 0 )
				ShuffleTimer --;
			Waitframe();
		}
	}
}

ffc script CosmicClone{
	void run(){
		int TrackX[60];
		int TrackY[60];
		int TrackTile[60];
		for(int i = 0; i <= 59; i++){
			TrackX[i] = -1;
			TrackY[i] = -1;
			TrackTile[i] = -1;
		}
		int MovedX = Link->X;
		int MovedY = Link->Y;
		while(true){
			if ( MovedX != Link->X || MovedY != Link->Y )
				break;
			Waitframe();
		}
		eweapon Spawn = CreateEWeaponAt(EW_SCRIPT1, 4, 4);
		Spawn->DrawXOffset = -4+MovedX;
		Spawn->DrawYOffset = -4+MovedY;
		Spawn->UseSprite(107);
		Spawn->CollDetection = false;
		while(true){
			if ( TrackX[0] != -1 && Spawn->isValid() )
				Spawn->X = -1000;
			if ( TrackX[0] != -1 ) {
				Screen->FastTile(2, TrackX[0], TrackY[0], TrackTile[0], 10, OP_OPAQUE);
				if ( RectCollision(TrackX[0]+5, TrackY[0]+5, TrackX[0]+10, TrackY[0]+10, Link->X, Link->Y+2, Link->X+15, Link->Y+15) ) {
					eweapon e = FireEWeapon(EW_SCRIPT10, Link->X+InFrontX(Link->Dir, 12), Link->Y+InFrontY(Link->Dir, 12), 0, 0, 4, -1, -1, EWF_UNBLOCKABLE);
					e->Dir = Link->Dir;
					e->DrawYOffset = -1000;
					SetEWeaponLifespan(e, EWL_TIMER, 1);
					SetEWeaponDeathEffect(e, EWD_VANISH, 0);
				}
			}
			for(int i = 1; i <= 59; i++){
				TrackX[i-1] = TrackX[i];
				TrackY[i-1] = TrackY[i];
				TrackTile[i-1] = TrackTile[i];
			}
			TrackX[59] = Link->X;
			TrackY[59] = Link->Y;
			TrackTile[59] = Link->Tile-260;
			Waitframe();
		}
	}
}

ffc script AkumaWalking{
	void run(){
		int IceWalkDir = -1;
		if ( Link->X == 0 )
			IceWalkDir = DIR_RIGHT;
		if ( Link->Y == 0 )
			IceWalkDir = DIR_DOWN;
		if ( Link->X == 240 )
			IceWalkDir = DIR_LEFT;
		if ( Link->Y == 160 )
			IceWalkDir = DIR_UP;
		while(true){
			if ( IceWalkDir == -1 ) {
				if ( Link->InputUp )
					IceWalkDir = DIR_UP;
				else if ( Link->InputRight )
					IceWalkDir = DIR_RIGHT;
				else if ( Link->InputDown )
					IceWalkDir = DIR_DOWN;
				else if ( Link->InputLeft )
					IceWalkDir = DIR_LEFT;
			}
			if ( IceWalkDir == DIR_UP )
				Link->InputUp = true;
			else
				Link->InputUp = false;
			if ( IceWalkDir == DIR_RIGHT )
				Link->InputRight = true;
			else
				Link->InputRight = false;
			if ( IceWalkDir == DIR_DOWN )
				Link->InputDown = true;
			else
				Link->InputDown = false;
			if ( IceWalkDir == DIR_LEFT )
				Link->InputLeft = true;
			else			
				Link->InputLeft = false;
			if ( IceWalkDir != -1 && !CanWalk(Link->X, Link->Y, IceWalkDir, 1, false) )
				IceWalkDir = -1;
			Waitframe();
		}
	}
}

ffc script PotionShopEntrance{
	void run(){
		if ( Link->Item[160] )
			Screen->ComboD[21] ++;
	}
}

void DarkRoomGlobal(bool HelloDarknessMyOldFriend)
{
	bool OkayFoundOne = false;
	if (HelloDarknessMyOldFriend == true)
	{
		if (Link->Action == LA_SCROLLING) 
		{
			Screen->Rectangle(6, 0, 0, 256, 176, BLACK_COLOR, 1, 0, 0, 0, true, OP_OPAQUE);
		}
		else HelloDarknessMyOldFriend = false;
	}
	for (int h = 1; h <= 32; h++)
	{
		ffc DarkMaybe = Screen->LoadFFC(h);
		if (DarkMaybe->Script == DARK_ROOM_SLOT)
		{
			if (Link->Action == LA_SCROLLING) 
			{
				Screen->Rectangle(6, 0, 0, 256, 176, BLACK_COLOR, 1, 0, 0, 0, true, OP_OPAQUE);
			}
			OkayFoundOne = true;
		}
	}
	if (OkayFoundOne == false && ActiveLastFrame == true) 
	{
		HelloDarknessMyOldFriend = true;
	}
	ActiveLastFrame = false;
}

ffc script DarkRoom
{
	void run(int LinkSize, int FlagSize, int LinkWeaponSize, int EnemyWeaponSize, int Expand, int Expanding, int CandleID)
	{
		int Expander = 0;
		int Expandest = 0;
		bool Expandirect = true;
		if (LinkSize == 0) LinkSize = 48;
		if (FlagSize == 0) FlagSize = 48;
		if (LinkWeaponSize == 0) LinkWeaponSize = 48;
		if (EnemyWeaponSize == 0) EnemyWeaponSize = 48;
		while(true)
		{
			if (Expand > 0)
			{
				if (Expanding > 0) Expander+=Expanding;
				else Expander+=2;
				if (Expander >= 20)
				{
					Expander = 0;
					if (Expandirect) Expandest++;
					else Expandest--;
					if (Expandest >= Expand) Expandirect = false;
					else if (Expandest <= 0) Expandirect = true;
				}
			}
			Screen->SetRenderTarget(RT_BITMAP0);
			Screen->Rectangle(6, 0, 0, 256, 176, BLACK_COLOR, 1, 0, 0, 0, true, OP_OPAQUE);
			if (LinkSize >= 0 && (CandleID == 0 || (CandleID < 0 && Link->Item[Abs(CandleID)] == true) || (CandleID > 0 && (GetEquipmentA() == CandleID || GetEquipmentB() == CandleID)))) Screen->Circle(6, Link->X + 8, Link->Y + 8, LinkSize + Expandest, 0, 1, 0, 0, 0, true, OP_OPAQUE);
			
			if (FlagSize >= 0) 
			{
				for(int i = 0; i < 176; i++)
				{
					if (Screen->ComboF[i] == LIGHT_FLAG || Screen->ComboI[i] == LIGHT_FLAG)
					{
						Screen->Circle(6, ComboX(i) + 8, ComboY(i) + 8, FlagSize + Expandest, 0, 1, 0, 0, 0, true, OP_OPAQUE);
					}
				}
			}
			if (LinkWeaponSize >= 0)
			{
				for(int l = Screen->NumLWeapons(); l > 0; l--)
				{
					lweapon MLG = Screen->LoadLWeapon(l);
					if (MLG->ID == LW_FIRE || MLG->ID == LW_REFFIREBALL || MLG->ID == LW_FIRESPARKLE)
					{
						Screen->Circle(6, MLG->X + 8, MLG->Y + 8, LinkWeaponSize + Expandest, 0, 1, 0, 0, 0, true, OP_OPAQUE);
					}
				}
			}
			if (EnemyWeaponSize >= 0)
			{
				for(int j = Screen->NumEWeapons(); j > 0; j--)
				{
					eweapon GLG = Screen->LoadEWeapon(j);
					if (GLG->ID == EW_FIRE || GLG->ID ==EW_FIREBALL || GLG->ID ==EW_FIREBALL2 || GLG->ID ==EW_FIRE2 || GLG->ID ==EW_FIRETRAIL)
					{
						Screen->Circle(6, GLG->X + 8, GLG->Y + 8, EnemyWeaponSize + Expandest, 0, 1, 0, 0, 0, true, OP_OPAQUE);
					}
				}
			}
			Screen->SetRenderTarget(RT_SCREEN);
			Screen->DrawBitmap(6, RT_BITMAP0, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
			ActiveLastFrame = true;
			Waitframe();
		}
	}
}

ffc script BombRain{
	void run(){
		npc BombRain[100];
		int BombRainTimer[100];
		int Timer;
		while(true){
			if ( Timer == 0 ) {
				int found;
				while(found != -1){
					if ( BombRain[found]->isValid() )
						found ++;
					else {
						BombRain[found] = CreateNPCAt(160, Rand(32, 208), Rand(32, 128));
						BombRain[found]->Z = 96;
						BombRain[found]->CollDetection = false;
						BombRainTimer[found] = 100;
						found = -1;
					}
				}
				Timer = 12;
			}
			for (int i = 0; i <= 99; i++) {
				if ( BombRainTimer[i] > 0 ) {
					BombRainTimer[i] --;
					if ( BombRainTimer[i] == 0 ) {
						eweapon boom = CreateEWeaponAt(EW_BOMBBLAST, BombRain[i]->X, BombRain[i]->Y);
						boom->Damage = 4;
						BombRain[i]->X = -1000;
					}
				}
			}
			if ( Timer > 0 )
				Timer --;
			Waitframe();
		}
	}
}

ffc script MemoryCave{
	void run(){
		if ( Screen->State[ST_SECRET] )
			Quit();
		int MTile[6];
		MTile[0] = 23689;
		MTile[1] = 22260;
		MTile[2] = 22928;
		MTile[3] = 22929;
		MTile[4] = 23441;
		MTile[5] = 21507;
		int MPos[12];
		for (int i = 0; i < 175; i++) {
			if ( Screen->ComboD[i] == 72 ) {
				for (int j = 0; j < 12; j++) {
					if ( MPos[j] == 0 ) {
						MPos[j] = i;
						j = 12;
					}
				}
			}
		}
		int MContent[12];
		int tilesLeft;
		if ( MPos[11] != 0 ) {
			tilesLeft = 12;
			MContent[0] = 5;
			MContent[1] = 1;
			MContent[2] = 2;
			MContent[3] = 1;
			MContent[4] = 3;
			MContent[5] = 4;
			MContent[6] = 0;
			MContent[7] = 5;
			MContent[8] = 0;
			MContent[9] = 3;
			MContent[10] = 4;
			MContent[11] = 2;
		}
		else if ( MPos[5] != 0 ) {
			tilesLeft = 6;
			MContent[0] = 0;
			MContent[1] = 1;
			MContent[2] = 2;
			MContent[3] = 0;
			MContent[4] = 1;
			MContent[5] = 2;
		}
		else {
			tilesLeft = 4;
			MContent[0] = 0;
			MContent[1] = 0;
			MContent[2] = 1;
			MContent[3] = 1;
		}
		bool onMPos;
		int firstM = -1;
		int secondM = -1;
		int firstUndoM = -1;
		int secondUndoM = -1;
		int undoTimer;
		while(true){
			if ( !onMPos && Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] == 72 ) {
				onMPos = true;
				Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] ++;
				if ( firstM == -1 ) {
					if ( firstUndoM != -1 ) {
						undoTimer = 0;
						Screen->ComboD[MPos[firstUndoM]] --;
						Screen->ComboD[MPos[secondUndoM]] --;
						firstUndoM = -1;
						secondUndoM = -1;
					}
					for (int i = 0; i < 12; i++) {
						if ( MPos[i] == ComboAt(Link->X+8, Link->Y+12) )
							firstM = i;
					}
				}
				else {
					for (int i = 0; i < 12; i++) {
						if ( MPos[i] == ComboAt(Link->X+8, Link->Y+12) )
							secondM = i;
					}
					if ( MContent[firstM] == MContent[secondM] ) {
						Game->PlaySound(60);
						tilesLeft -= 2;
					}
					else {
						Game->PlaySound(61);
						firstUndoM = firstM;
						secondUndoM = secondM;
						undoTimer = 60;
					}
					firstM = -1;
					secondM = -1;
				}
			}
			
			for (int i = 0; i < 12; i++) {
				if ( MPos[i] != 0 && Screen->ComboD[MPos[i]] == 73 ) {
					Screen->FastTile(0, ComboX(MPos[i]), ComboY(MPos[i]), MTile[MContent[i]], 8, OP_OPAQUE);
				}
			}
			
			if ( tilesLeft == 0 ) {
				Game->PlaySound(27);
				Screen->TriggerSecrets();
				Screen->State[ST_SECRET] = true;
				Quit();
			}
			
			if ( undoTimer == 0 && firstUndoM != -1 ) {
				Screen->ComboD[MPos[firstUndoM]] --;
				Screen->ComboD[MPos[secondUndoM]] --;
				firstUndoM = -1;
				secondUndoM = -1;
			}
			if ( undoTimer > 0 )
				undoTimer --;
			if ( onMPos && Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] != 72 && Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] != 73 )
				onMPos = false;
			Waitframe();
		}
	}
}

ffc script RoomPositionMover{
	void run(int Destination){
		int DestinationX;
		int DestinationY;
		int CurrentX;
		int CurrentY;
		int StartX;
		int StartY;
		int Moving;
		int Angle;
		while(true){
			if ( PowerColour == 1 && ComboAt(Link->X+8, Link->Y+12) == ComboAt(this->X+8, this->Y+8) && Moving == 0 ) {
				Moving = 1;
				DestinationX = ComboX(Destination);
				DestinationY = ComboY(Destination);
				CurrentX = Link->X;
				CurrentY = Link->Y;
				StartX = CurrentX;
				StartY = CurrentY;
				Angle = Angle(CurrentX, CurrentY, DestinationX, DestinationY);
				Link->CollDetection = false;
				for (int i = 0; i < 175; i++) {
					if ( Screen->ComboD[i] == 448 )
						Screen->ComboD[i] = 406;
					if ( Screen->ComboD[i] == 449 )
						Screen->ComboD[i] = 407;
					if ( Screen->ComboD[i] == 454 )
						Screen->ComboD[i] = 410;
					if ( Screen->ComboD[i] == 455 )
						Screen->ComboD[i] = 411;
					if ( Screen->ComboD[i] == 484 )
						Screen->ComboD[i] = 414;
					if ( Screen->ComboD[i] == 487 )
						Screen->ComboD[i] = 415;
				}
				Screen->SetRenderTarget(3);
				for (int i = 0; i <= 175; i++) {
					Screen->FastCombo(0, ComboX(i), ComboY(i), Screen->ComboD[i], Screen->ComboC[i], OP_OPAQUE);
					if ( Screen->LayerMap(1) != -1 && Screen->ComboD[i] != 632 )
						Screen->FastCombo(0, ComboX(i), ComboY(i), GetLayerComboD(1, i), 2, OP_OPAQUE);
				}
				Screen->SetRenderTarget(RT_SCREEN);
			}
			
			if ( Moving == 1 ) {
				CurrentX += VectorX((Distance(CurrentX, CurrentY, DestinationX, DestinationY)+20)/35, Angle);
				CurrentY += VectorY((Distance(CurrentX, CurrentY, DestinationX, DestinationY)+20)/35, Angle);
				int itsthere;
				if ( StartX < CurrentX ) {
					if ( CurrentX >= DestinationX )
						itsthere ++;
				}
				else {
					if ( CurrentX <= DestinationX )
						itsthere ++;
				}
				if ( StartY < CurrentY ) {
					if ( CurrentY >= DestinationY )
						itsthere ++;
				}
				else {
					if ( CurrentY <= DestinationY )
						itsthere ++;
				}
				if ( itsthere == 2 ) {
					CurrentX = DestinationX;
					CurrentY = DestinationY;
					Link->X = CurrentX;
					Link->Y = CurrentY;
					Link->DrawXOffset = -1000;
					DestinationX = StartX;
					DestinationY = StartY;
					StartX = CurrentX;
					StartY = CurrentY;
					Angle = Angle(CurrentX, CurrentY, DestinationX, DestinationY);
					Moving = 2;
					Screen->SetRenderTarget(3);
					Screen->FastTile(1, Link->X, Link->Y, Link->Tile, 6, OP_OPAQUE);
					Screen->SetRenderTarget(RT_SCREEN);
				}
			}
			
			if ( Moving == 2 ) {
				CurrentX += VectorX((Distance(CurrentX, CurrentY, StartX, StartY)+20)/35, Angle);
				CurrentY += VectorY((Distance(CurrentX, CurrentY, StartX, StartY)+20)/35, Angle);
				int itsthere;
				if ( StartX < CurrentX ) {
					if ( CurrentX >= DestinationX )
						itsthere ++;
				}
				else {
					if ( CurrentX <= DestinationX )
						itsthere ++;
				}
				if ( StartY < CurrentY ) {
					if ( CurrentY >= DestinationY )
						itsthere ++;
				}
				else {
					if ( CurrentY <= DestinationY )
						itsthere ++;
				}
				if ( itsthere == 2 ) {
					Moving = 0;
					Link->CollDetection = true;
					Link->DrawXOffset = 0;
					for (int i = 0; i < 175; i++) {
						if ( Screen->ComboD[i] == 406 )
							Screen->ComboD[i] = 448;
						if ( Screen->ComboD[i] == 407 )
							Screen->ComboD[i] = 449;
						if ( Screen->ComboD[i] == 410 )
							Screen->ComboD[i] = 454;
						if ( Screen->ComboD[i] == 411 )
							Screen->ComboD[i] = 455;
						if ( Screen->ComboD[i] == 414 )
							Screen->ComboD[i] = 484;
						if ( Screen->ComboD[i] == 415 )
							Screen->ComboD[i] = 487;
					}
				}
			}
			
			if ( Moving > 0 ) {
				Screen->SetRenderTarget(3);
				for (int i = 0; i < 175; i++) {
					if ( Screen->ComboD[i] >= 704 && Screen->ComboD[i] <= 707 )
						Screen->FastCombo(0, ComboX(i), ComboY(i), Screen->ComboD[i], 2, OP_OPAQUE);
				}
				Screen->SetRenderTarget(RT_SCREEN);
				Screen->Rectangle(2, 0, 0, 255, 175, 0x07, 1, 0, 0, 0, true, OP_OPAQUE);
				if ( Moving == 1 ) {
					Screen->DrawBitmap(2, 3, 0, 0, 256, 176, StartX-CurrentX, StartY-CurrentY, 256, 176, 0, true);
					GlobalVars[LinkMoving0] = StartX-CurrentX;
					GlobalVars[LinkMoving1] = StartY-CurrentY;
					GlobalVars[LinkMoving2] = 0;
				}
				else {
					Screen->DrawBitmap(2, 3, 0, 0, 256, 176, DestinationX-CurrentX, DestinationY-CurrentY, 256, 176, 0, true);
					GlobalVars[LinkMoving0] = DestinationX-CurrentX;
					GlobalVars[LinkMoving1] = DestinationY-CurrentY;
					GlobalVars[LinkMoving2] = 1;
				}
			}
			
			if ( Moving > 0 )
				NoAction();
			
			
			Waitframe();
		}
	}
}

ffc script CelesteRedBubble{
	void run(){
		Screen->D[1] = 0;
		bool stop;
		int initialX = this->X;
		int initialY = this->Y;
		while(true){
			if ( PowerColour == 2 && ComboAt(Link->X+8, Link->Y+12) == ComboAt(this->X, this->Y) && this->Vx == 0 && this->Vy == 0 ) {
				Game->PlaySound(60);
				Screen->D[1] = 1;
				Link->CollDetection = false;
				Link->X = this->X;
				Link->Y = this->Y;
				WaitNoAction(45);
				Game->PlaySound(65);
				Screen->D[1] = 0;
				if ( Link->InputUp && Link->InputRight ) {
					this->Vx = 2;
					this->Vy = -2;
				}
				else if ( Link->InputDown && Link->InputRight ) {
					this->Vx = 2;
					this->Vy = 2;
				}
				else if ( Link->InputDown && Link->InputLeft ) {
					this->Vx = -2;
					this->Vy = 2;
				}
				else if ( Link->InputUp && Link->InputLeft ) {
					this->Vx = -2;
					this->Vy = -2;
				}
				else if ( Link->InputUp )
					this->Vy = -2;
				else if ( Link->InputRight )
					this->Vx = 2;
				else if ( Link->InputDown )
					this->Vy = 2;
				else if ( Link->InputLeft )
					this->Vx = -2;
				else {
					if ( Link->Dir == DIR_UP )
						this->Vy = -2;
					if ( Link->Dir == DIR_RIGHT )
						this->Vx = 2;
					if ( Link->Dir == DIR_DOWN )
						this->Vy = 2;
					if ( Link->Dir == DIR_LEFT )
						this->Vx = -2;
				}
			}
			if ( this->Vx != 0 || this->Vy != 0 ) {
				if ( this->Vx == 0 && this->Vy < 0 && Screen->ComboS[ComboAt(this->X+8, this->Y+8-8)] != 0000b )
					stop = true;
				if ( this->Vx > 0 && this->Vy < 0 && (Screen->ComboS[ComboAt(this->X+8+8, this->Y+8-8)] != 0000b || Screen->ComboS[ComboAt(this->X+7+8, this->Y+8-8)] != 0000b) )
					stop = true;
				if ( this->Vx > 0 && this->Vy == 0 && Screen->ComboS[ComboAt(this->X+8+8, this->Y+8)] != 0000b )
					stop = true;
				if ( this->Vx > 0 && this->Vy > 0 && (Screen->ComboS[ComboAt(this->X+8+8, this->Y+8+8)] != 0000b || Screen->ComboS[ComboAt(this->X+7+8, this->Y+8+8)] != 0000b) )
					stop = true;
				if ( this->Vx == 0 && this->Vy > 0 && Screen->ComboS[ComboAt(this->X+8, this->Y+8+8)] != 0000b )
					stop = true;
				if ( this->Vx < 0 && this->Vy > 0 && (Screen->ComboS[ComboAt(this->X+8-8, this->Y+8+8)] != 0000b || Screen->ComboS[ComboAt(this->X+7-8, this->Y+8+8)] != 0000b) )
					stop = true;
				if ( this->Vx < 0 && this->Vy == 0 && Screen->ComboS[ComboAt(this->X+8-8, this->Y+8)] != 0000b )
					stop = true;
				if ( this->Vx < 0 && this->Vy < 0 && (Screen->ComboS[ComboAt(this->X+8-8, this->Y+8-8)] != 0000b || Screen->ComboS[ComboAt(this->X+7-8, this->Y+8-8)] != 0000b) )
					stop = true;
				if ( Link->PressA || Link->PressB )
					stop = true;
				if ( Screen->D[1] == 1 ) {
					stop = true;
				}
				else {
					NoAction();
					Link->X = this->X;
					Link->Y = this->Y;
				}
			}
			if ( stop == true ) {
				stop = false;
				Game->PlaySound(55);
				if ( Screen->D[1] == 1 )
					Screen->D[1] = 0;
				else
					Link->CollDetection = true;
				this->Data = 1;
				lweapon wpn = CreateLWeaponAt(LW_SPARKLE, this->X, this->Y);
				wpn->UseSprite(108);
				this->Vx = 0;
				this->Vy = 0;
				this->X = initialX;
				this->Y = initialY;
				Waitframes(45);
				this->Data = 74;
			}
			Waitframe();
		}
	}
}

ffc script PowerColourStatue{
	void run(){
		lweapon ColourSparkle[10];
		int Timer;
		int ThisColour = Screen->ComboD[ComboAt(this->X, this->Y)] - 583;
		int ChangeLinksColour;
		int CircleRadius;
		int CircleX;
		int CircleY;
		int Angle;
		while(true){
			if ( Timer >= 12 ) {
				Timer = Rand(0, 5);
				int done;
				while(done != -1){
					if ( ColourSparkle[done]->isValid() )
						done ++;
					else {
						ColourSparkle[done] = CreateLWeaponAt(LW_SPARKLE, this->X+Rand(-8, 8), this->Y+Rand(-8, 8));
						ColourSparkle[done]->UseSprite(109);
						done = -1;
					}
					if ( done == 10 )
						done = -1;
				}
			}
			else
				Timer ++;
			
			if ( PowerColour != ThisColour && RectCollision(Link->X, Link->Y+8, Link->X+15, Link->Y+15, this->X-2, this->Y-2, this->X+17, this->Y+17) && ChangeLinksColour == 0 ) {
				ChangeLinksColour = 1;
				Game->PlaySound(74);
			}
			
			if ( ChangeLinksColour == 1 ) {
				Angle = Angle(this->X, this->Y, Link->X, Link->Y);
				CircleX = this->X;
				CircleY = this->Y;
				CircleRadius += 3;
				if ( CircleRadius >= 60 )
					ChangeLinksColour = 2;
			}
			if ( ChangeLinksColour >= 2 && ChangeLinksColour < 32 ) {
				ChangeLinksColour ++;
			}
			if ( ChangeLinksColour == 32 ) {
				PowerColour = ThisColour;
				if ( CircleRadius >= 60 ) {
					if ( PowerColour == 3 ) {
						for (int i = 0; i <= 27; i++) {
							Game->SetComboType(1, 0x2F, i, CT_NOENEMY);
							Game->SetComboInherentFlag(1, 0x2F, i, 67);
							Game->SetComboSolid(0, 0x2F, i, 0000b);
							Game->SetComboSolid(1, 0x2F, i, 0000b);
						}
					}
					else {
						for (int i = 0; i <= 27; i++) {
							Game->SetComboType(1, 0x2F, i, CT_NOGROUNDENEMY);
							Game->SetComboInherentFlag(1, 0x2F, i, 0);
							Game->SetComboSolid(0, 0x2F, i, 1111b);
							Game->SetComboSolid(1, 0x2F, i, 1111b);
						}
					}
				}
				if ( !RectCollision(Link->X-1, Link->Y-1, Link->X+1, Link->Y+1, CircleX, CircleY, CircleX, CircleY) ) {
					CircleX += VectorX(0.75, Angle);
					CircleY += VectorY(0.75, Angle);
				}
				if ( CircleRadius >= 58 && CircleRadius <= 59 && PowerColour != 3 ) {
					for (int i = 0; i <= 27; i++) {
						Game->SetComboType(1, 0x2F, i, CT_NOFLYZONE);
					}
				}
				CircleRadius -= 2;
				if ( CircleRadius <= 0 )
					ChangeLinksColour = 0;
			}
			
			if ( ChangeLinksColour > 0 ) {
				NoAction();
				int TheColour;
				if ( ThisColour == 1 )
					TheColour = 0x72;
				if ( ThisColour == 2 )
					TheColour = 0x82;
				if ( ThisColour == 3 )
					TheColour = 0xA6;
				if ( ThisColour == 4 )
					TheColour = 0x52;
				Screen->Circle(6, CircleX+8, CircleY+8, CircleRadius, TheColour, 1, 0, 0, 0, true, OP_OPAQUE);
			}
			
			for (int i = 0; i < 10; i++) {
				if ( ColourSparkle[i]->isValid() )
					Screen->FastTile(4, ColourSparkle[i]->X+GlobalVars[LinkMoving0], ColourSparkle[i]->Y+GlobalVars[LinkMoving1], 27544+((ThisColour-1)*4)+ColourSparkle[i]->Tile-20, 8, OP_OPAQUE);
			}
			Waitframe();
		}
	}
}

const int MAX_PUSH = 4;

int LinkMovement[16];
const int LM_PUSHX1A = 0;
const int LM_PUSHY1A = 1;
const int LM_PUSHX1B = 2;
const int LM_PUSHY1B = 3;
const int LM_PUSHX2A = 4;
const int LM_PUSHY2A = 5;
const int LM_PUSHX2B = 6;
const int LM_PUSHY2B = 7;
const int LM_STICKX = 8;
const int LM_STICKY = 9;
const int LM_MOVEBOOST = 10;

void LinkMovement_UpdateInput(){
	if(LinkMovement[LM_STICKY]==0){ //If no Y axis pressed
		if(Link->InputUp&&Link->InputDown) //Default to up when buttons pressed simultaneously
			LinkMovement[LM_STICKY] = -1;
		else if(Link->InputUp) //Set axis based on which button what pressed
			LinkMovement[LM_STICKY] = -1;
		else if(Link->InputDown)
			LinkMovement[LM_STICKY] = 1;
	}
	else{ //If Y axis pressed
		if(!Link->InputUp&&!Link->InputDown) //Release Y axis if neither button pressed
			LinkMovement[LM_STICKY] = 0;
		else if(LinkMovement[LM_STICKY]==-1&&!Link->InputUp) //Reverse Y axis if opposite direction held and button released
			LinkMovement[LM_STICKY] = 1;
		else if(LinkMovement[LM_STICKY]==1&&!Link->InputDown)
			LinkMovement[LM_STICKY] = -1;
	}
	
	if(LinkMovement[LM_STICKX]==0){ //If no X axis pressed
		if(Link->InputLeft&&Link->InputRight) //Default to left when buttons pressed simultaneously
			LinkMovement[LM_STICKX] = -1;
		else if(Link->InputLeft) //Set axis based on which button what pressed
			LinkMovement[LM_STICKX] = -1;
		else if(Link->InputRight)
			LinkMovement[LM_STICKX] = 1;
	}
	else{ //If Y axis pressed
		if(!Link->InputLeft&&!Link->InputRight) //Release Y axis if neither button pressed
			LinkMovement[LM_STICKX] = 0;
		else if(LinkMovement[LM_STICKX]==-1&&!Link->InputLeft) //Reverse Y axis if opposite direction held and button released
			LinkMovement[LM_STICKX] = 1;
		else if(LinkMovement[LM_STICKX]==1&&!Link->InputRight)
			LinkMovement[LM_STICKX] = -1;
	}
}

//Function adds extra movement to Link's step speed
void LinkMovement_SpeedChange(){
	if(Link->Action==LA_WALKING){
		if(LinkMovement[LM_STICKX]!=0||LinkMovement[LM_STICKY]!=0){
			float movementSpeed = LinkMovement[LM_MOVEBOOST];
			if((LinkMovement[LM_STICKX]<0&&LinkMovement[LM_STICKY]<0) || //Up-left
				(LinkMovement[LM_STICKX]>0&&LinkMovement[LM_STICKY]<0) || //Up-right
				(LinkMovement[LM_STICKX]<0&&LinkMovement[LM_STICKY]>0) || //Down-left
				(LinkMovement[LM_STICKX]>0&&LinkMovement[LM_STICKY]>0)) //Down-right
					movementSpeed = movementSpeed*0.7071; //Reduce movement speed at a diagonal
			
			if(LinkMovement[LM_STICKX]<0)
				LinkMovement[LM_PUSHX2A] -= movementSpeed;
			else if(LinkMovement[LM_STICKX]>0)
				LinkMovement[LM_PUSHX2A] += movementSpeed;
			if(LinkMovement[LM_STICKY]<0)
				LinkMovement[LM_PUSHY2A] -= movementSpeed;
			else if(LinkMovement[LM_STICKY]>0)
				LinkMovement[LM_PUSHY2A] += movementSpeed;
		}	
	}
	LinkMovement[LM_MOVEBOOST] = 0; //Movement boost reset until the next frame to prevent forgetting to clear the boost
}

bool LinkMovement_CanWalk(int x, int y, int dir, int step, bool full_tile, bool noEdge) {
    //if(!noEdge)
	//	return CanWalk(x, y, dir, step, full_tile);
	
	int c=8;
    int xx = x+15;
    int yy = y+15;
    if(full_tile) c=0;
    if(dir==0) return !(Screen->isSolid(x,y+c-step)||Screen->isSolid(x+8,y+c-step)||Screen->isSolid(xx,y+c-step));
    else if(dir==1) return !(Screen->isSolid(x,yy+step)||Screen->isSolid(x+8,yy+step)||Screen->isSolid(xx,yy+step));
    else if(dir==2) return !(Screen->isSolid(x-step,y+c)||Screen->isSolid(x-step,y+c+7)||Screen->isSolid(x-step,yy));
    else if(dir==3) return !(Screen->isSolid(xx+step,y+c)||Screen->isSolid(xx+step,y+c+7)||Screen->isSolid(xx+step,yy));
    return false; //invalid direction
}

void LinkMovement_UpdatePush(int indexX, int indexY, bool noEdge){
	int Imprecision = 0;
	for(int i=0; i<MAX_PUSH&&LinkMovement[indexX]<=-1; i++){
		if(LinkMovement_CanWalk(Link->X, Link->Y, DIR_LEFT, 1, false, noEdge)){
			Link->X--;
			LinkMovement[indexX]++;
		}
		else if(Imprecision>0&&Abs(GridY(Link->Y+8)-Link->Y)<Imprecision&&LinkMovement_CanWalk(Link->X, GridY(Link->Y+8), DIR_LEFT, 1, false, noEdge)){
			Link->Y = GridY(Link->Y+8);
			Link->X--;
			LinkMovement[indexX]++;
		}
		else{
			LinkMovement[indexX] = 0;
		}
	}
	for(int i=0; i<MAX_PUSH&&LinkMovement[indexX]>=1; i++){
		if(LinkMovement_CanWalk(Link->X, Link->Y, DIR_RIGHT, 1, false, noEdge)){
			Link->X++;
			LinkMovement[indexX]--;
		}
		else if(Imprecision>0&&Abs(GridY(Link->Y+8)-Link->Y)<Imprecision&&LinkMovement_CanWalk(Link->X, GridY(Link->Y+8), DIR_RIGHT, 1, false, noEdge)){
			Link->Y = GridY(Link->Y+8);
			Link->X++;
			LinkMovement[indexX]--;
		}
		else{
			LinkMovement[indexX] = 0;
		}
	}
	for(int i=0; i<MAX_PUSH&&LinkMovement[indexY]<=-1; i++){
		if(LinkMovement_CanWalk(Link->X, Link->Y, DIR_UP, 1, false, noEdge)){
			Link->Y--;
			LinkMovement[indexY]++;
		}
		else if(Imprecision>0&&Abs(GridX(Link->X+8)-Link->X)<Imprecision&&LinkMovement_CanWalk(GridX(Link->X+8), Link->Y, DIR_UP, 1, false, noEdge)){
			Link->X = GridX(Link->X+8);
			Link->Y--;
			LinkMovement[indexY]++;
		}
		else{
			LinkMovement[indexY] = 0;
		}
	}
	for(int i=0; i<MAX_PUSH&&LinkMovement[indexY]>=1; i++){
		if(LinkMovement_CanWalk(Link->X, Link->Y, DIR_DOWN, 1, false, noEdge)){
			Link->Y++;
			LinkMovement[indexY]--;
		}
		else if(Imprecision>0&&Abs(GridX(Link->X+8)-Link->X)<Imprecision&&LinkMovement_CanWalk(GridX(Link->X+8), Link->Y, DIR_DOWN, 1, false, noEdge)){
			Link->X = GridX(Link->X+8);
			Link->Y++;
			LinkMovement[indexY]--;
		}
		else{
			LinkMovement[indexY] = 0;
		}
	}
}

void LinkMovement_Init(){
	LinkMovement[LM_PUSHX1A] = 0;
	LinkMovement[LM_PUSHY1A] = 0;
	LinkMovement[LM_PUSHX1B] = 0;
	LinkMovement[LM_PUSHY1B] = 0;
	LinkMovement[LM_PUSHX2A] = 0;
	LinkMovement[LM_PUSHY2A] = 0;
	LinkMovement[LM_PUSHX2B] = 0;
	LinkMovement[LM_PUSHY2B] = 0;
	LinkMovement[LM_STICKX] = 0;
	LinkMovement[LM_STICKY] = 0;
	LinkMovement[LM_MOVEBOOST] = 0;
}

void LinkMovement_Update1(){
	LinkMovement_UpdateInput();
	LinkMovement_SpeedChange();
	LinkMovement_UpdatePush(LM_PUSHX1A, LM_PUSHY1A, false);
	LinkMovement_UpdatePush(LM_PUSHX1B, LM_PUSHY1B, true);
}

void LinkMovement_Update2(){
	LinkMovement_UpdatePush(LM_PUSHX2A, LM_PUSHY2A, false);
	LinkMovement_UpdatePush(LM_PUSHX2B, LM_PUSHY2B, true);
}

void LinkMovement_Push(int pX, int pY){
	LinkMovement[LM_PUSHX1A] += pX;
	LinkMovement[LM_PUSHY1A] += pY;
}

void LinkMovement_PushNoEdge(int pX, int pY){
	LinkMovement[LM_PUSHX1B] += pX;
	LinkMovement[LM_PUSHY1B] += pY;
}

void LinkMovement_Push2(int pX, int pY){
	LinkMovement[LM_PUSHX2A] += pX;
	LinkMovement[LM_PUSHY2A] += pY;
}

void LinkMovement_Push2NoEdge(int pX, int pY){
	LinkMovement[LM_PUSHX2B] += pX;
	LinkMovement[LM_PUSHY2B] += pY;
}

void LinkMovement_AddLinkSpeedBoost(float i){
	LinkMovement[LM_MOVEBOOST] += i;
}

void LinkMovement_SetLinkSpeedBoost(float i){
	LinkMovement[LM_MOVEBOOST] = i;
}

int LinkMovement_StickX(){
	return LinkMovement[LM_STICKX];
}

int LinkMovement_StickY(){
	return LinkMovement[LM_STICKY];
}

ffc script TriforceCheck{
	void run(){
		if ( !Screen->State[ST_SECRET] && TriforcePieces == 3 ) {
			WaitNoAction(2);
			item triforces = CreateItemAt(44, Link->X, Link->Y);
			SetItemPickup(triforces, IP_HOLDUP, true);
			Game->PlaySound(27);
			Waitframes(2);
			Game->PlaySound(9);
			Screen->TriggerSecrets();
			Screen->State[ST_SECRET] = true;
		}
	}
}

ffc script Level4MultiTriggers{
	void run(){
		if ( GlobalVars[L4MultiTrigger1] == 1 )
			Screen->ComboD[55] = 1091;
		if ( GlobalVars[L4MultiTrigger2] == 1 )
			Screen->ComboD[57] = 1091;
		if ( GlobalVars[L4MultiTrigger3] == 1 )
			Screen->ComboD[59] = 1091;
		if ( GlobalVars[L4MultiTrigger4] == 1 )
			Screen->ComboD[61] = 1091;
		while(true){
			if ( Screen->State[ST_SECRET] == true )
				Quit();
			if ( Link->CollDetection && ComboAt(Link->X+8, Link->Y+8) == 55 ) {
				Screen->ComboD[55] = 1091;
				GlobalVars[L4MultiTrigger1] = 1;
			}
			if ( Link->CollDetection && ComboAt(Link->X+8, Link->Y+8) == 57 ) {
				Screen->ComboD[57] = 1091;
				GlobalVars[L4MultiTrigger2] = 1;
			}
			if ( Link->CollDetection && ComboAt(Link->X+8, Link->Y+8) == 59 ) {
				Screen->ComboD[59] = 1091;
				GlobalVars[L4MultiTrigger3] = 1;
			}
			if ( Link->CollDetection && ComboAt(Link->X+8, Link->Y+8) == 61 ) {
				Screen->ComboD[61] = 1091;
				GlobalVars[L4MultiTrigger4] = 1;
			}
			if ( GlobalVars[L4MultiTrigger1] == 1 && GlobalVars[L4MultiTrigger2] == 1 && GlobalVars[L4MultiTrigger3] == 1 && GlobalVars[L4MultiTrigger4] == 1 ) {
				Game->PlaySound(27);
				Screen->TriggerSecrets();
				Screen->State[ST_SECRET] = true;
			}
			Waitframe();
		}
	}
}

ffc script NoAction{
	void run(){
		while(true){
			NoAction();
			Waitframe();
		}
	}
}

ffc script NoMap{
	void run(){
		while(true){
			Link->PressMap = false;
			Link->InputMap = false;
			Waitframe();
		}
	}
}

ffc script NoPotion{
	void run(){
		while(true){
			if ( GetEquipmentA() == 29 || GetEquipmentA() == 30 || GetEquipmentA() == 161 || GetEquipmentA() == 162 ) {
				if ( Link->PressA )
					Game->PlaySound(61);
				Link->PressA = false;
				Link->InputA = false;
			}
			if ( GetEquipmentB() == 29 || GetEquipmentB() == 30 || GetEquipmentB() == 161 || GetEquipmentB() == 162 ) {
				if ( Link->PressB )
					Game->PlaySound(61);
				Link->PressB = false;
				Link->InputB = false;
			}
			Waitframe();
		}
	}
}

ffc script Challenge1{
	void run(){
		Link->HP = 48;
		Screen->Message(61);
		int Triggers[176];
		while(true){
			if ( Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] == 1090 )
				Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] = 1091;
			if ( Screen->ComboD[ComboAt(Link->X+8, Link->Y+12)] == 558 ) {
				Screen->Message(63);
				WaitNoAction();
				this->Data = 888;
				WaitNoAction();
			}
			bool triggerfound;
			for (int i = 0; i <= 175; i++) {
				if ( ComboAt(Link->X+8, Link->Y+12) != i && Screen->ComboD[i] == 1091 )
					Screen->ComboD[i] = 558;
				if ( Screen->ComboD[i] == 1090 )
					triggerfound = true;
			}
			if ( !triggerfound ) {
				Screen->Message(64);
				WaitNoAction();
				Link->HP = Link->MaxHP;
				if ( GlobalVars[Challenge2] == 2 )
					GlobalVars[Challenge2] = 0;
				if ( GlobalVars[Challenge3] == 2 )
					GlobalVars[Challenge3] = 0;
				if ( GlobalVars[Challenge4] == 2 )
					GlobalVars[Challenge4] = 0;
				GlobalVars[Challenge1] = 2;
				this->Data = 889;
				WaitNoAction();
			}
			Waitframe();
		}
	}
}

ffc script Challenge2{
	void run(){
		Link->HP = 48;
		Screen->Message(65);
		while(true){
			if ( Link->X >= 175 ) {
				Screen->Message(64);
				WaitNoAction();
				Link->HP = Link->MaxHP;
				if ( GlobalVars[Challenge1] == 2 )
					GlobalVars[Challenge1] = 0;
				if ( GlobalVars[Challenge3] == 2 )
					GlobalVars[Challenge3] = 0;
				if ( GlobalVars[Challenge4] == 2 )
					GlobalVars[Challenge4] = 0;
				GlobalVars[Challenge2] = 2;
				this->Data = 889;
				WaitNoAction();
			}
			Waitframe();
		}
	}
}

ffc script Challenge3{
	void run(){
		Link->HP = 48;
		Screen->Message(67);
		int waitUntilLoad = 5;
		npc wizzrobe;
		int killCount;
		while(true){
			if ( wizzrobe->isValid() ) {
				if ( wizzrobe->HP <= 0 ) {
					Screen->Message(63);
					WaitNoAction();
					this->Data = 888;
					WaitNoAction();
				}
			}
			
			Screen->DrawInteger(6, 8+1, 8+1, FONT_Z1, 0x07, -1, 0, 0, killCount, -2, OP_OPAQUE);
			Screen->DrawInteger(6, 8, 8, FONT_Z1, 0x01, -1, 0, 0, killCount, -2, OP_OPAQUE);
			
			if ( killCount >= 16 ) {
				Screen->Message(64);
				WaitNoAction();
				Link->HP = Link->MaxHP;
				if ( GlobalVars[Challenge2] == 2 )
					GlobalVars[Challenge2] = 0;
				if ( GlobalVars[Challenge1] == 2 )
					GlobalVars[Challenge1] = 0;
				if ( GlobalVars[Challenge4] == 2 )
					GlobalVars[Challenge4] = 0;
				GlobalVars[Challenge3] = 2;
				this->Data = 889;
				WaitNoAction();
			}
			
			for (int i = 1; i <= Screen->NumNPCs(); i++) {
				npc enem = Screen->LoadNPC(i);
				if ( enem->ID == 38 && enem->HP <= 0 && enem->HP != -100 ) {
					killCount ++;
					enem->HP = -100;
				}
			}
			
			if ( waitUntilLoad > 0 )
				waitUntilLoad --;
			if ( waitUntilLoad == 0 )
				wizzrobe = Screen->LoadNPC(1);
			Waitframe();
		}
	}
}

ffc script Challenge4{
	void run(){
		Link->HP = 48;
		Screen->Message(69);
		item challengeKey = CreateItemAt(164, 168, 120);
		SetItemPickup(challengeKey, IP_HOLDUP, true);
		while(true){
			if ( !challengeKey->isValid() ) {
				Screen->Message(64);
				WaitNoAction();
				Link->HP = Link->MaxHP;
				if ( GlobalVars[Challenge2] == 2 )
					GlobalVars[Challenge2] = 0;
				if ( GlobalVars[Challenge1] == 2 )
					GlobalVars[Challenge1] = 0;
				if ( GlobalVars[Challenge3] == 2 )
					GlobalVars[Challenge3] = 0;
				GlobalVars[Challenge4] = 2;
				this->Data = 889;
				WaitNoAction();
			}
			
			if ( Screen->Wavy < 7 && (Link->InputUp || Link->InputRight || Link->InputDown || Link->InputLeft) ) {
				Waitframe();
				Screen->Message(63);
				WaitNoAction();
				this->Data = 888;
				WaitNoAction();
			}
			Waitframe();
		}
	}
}

ffc script ChallengeFireCutscene{
	void run(){
		if ( GlobalVars[Challenge1] == 1 )
			Screen->ComboD[105] = 1164;
		if ( GlobalVars[Challenge2] == 1 )
			Screen->ComboD[102] = 1165;
		if ( GlobalVars[Challenge3] == 1 )
			Screen->ComboD[73] = 1166;
		if ( GlobalVars[Challenge4] == 1 )
			Screen->ComboD[70] = 1167;
		int flameCombo;
		int flameX;
		int flameY;
		int destX;
		int destY;
		int angle;
		if ( GlobalVars[Challenge1] == 2 ) {
			flameCombo = 1160;
			flameX = 168;
			flameY = -16;
			destX = 144;
			destY = 96;
			angle = Angle(flameX, flameY, destX, destY);
		}
		if ( GlobalVars[Challenge2] == 2 ) {
			flameCombo = 1161;
			flameX = -16;
			flameY = 98;
			destX = 96;
			destY = 96;
			angle = Angle(flameX, flameY, destX, destY);
		}
		if ( GlobalVars[Challenge3] == 2 ) {
			flameCombo = 1162;
			flameX = 176;
			flameY = -16;
			destX = 144;
			destY = 64;
			angle = Angle(flameX, flameY, destX, destY);
		}
		if ( GlobalVars[Challenge4] == 2 ) {
			flameCombo = 1163;
			flameX = 64;
			flameY = -16;
			destX = 96;
			destY = 64;
			angle = Angle(flameX, flameY, destX, destY);
		}
		Waitframes(60);
		int warpType;
		int waitUntilWarp = -1;
		int waitUntilWhiteRect = -1;
		bool screenShake;
		int whiteRectX;
		int gateOpening;
		int openingSound[256];
		Game->GetDMapMusicFilename(23, openingSound);
		while(true){	
			if ( flameCombo != 1 ) {
				flameX += VectorX(2.25, angle);
				flameY += VectorY(2.25, angle);
				Screen->FastCombo(1, flameX, flameY, flameCombo, 2, OP_OPAQUE);
			}
			
			if ( waitUntilWarp > 0 )
				waitUntilWarp --;
			if ( waitUntilWarp == 0 )
				this->Data = warpType;
			
			if ( Distance(flameX, flameY, destX, destY) <= 2.25 && flameCombo != 1 ) {
				Game->PlaySound(13);
				if ( GlobalVars[Challenge1] == 2 ) {
					GlobalVars[Challenge1] = 1;
					Screen->ComboD[105] = 1164;
					Game->SetScreenState(2, 0x45, ST_SECRET, true);
					warpType = 888;
				}
				if ( GlobalVars[Challenge2] == 2 ) {
					GlobalVars[Challenge2] = 1;
					Screen->ComboD[102] = 1165;
					Game->SetScreenState(2, 0x71, ST_SECRET, true);
					warpType = 889;
				}
				if ( GlobalVars[Challenge3] == 2 ) {
					GlobalVars[Challenge3] = 1;
					Screen->ComboD[73] = 1166;
					Game->SetScreenState(2, 0x17, ST_SECRET, true);
					warpType = 890;
				}
				if ( GlobalVars[Challenge4] == 2 ) {
					GlobalVars[Challenge4] = 1;
					Screen->ComboD[70] = 1167;
					Game->SetScreenState(2, 0x22, ST_SECRET, true);
					warpType = 891;
				}
				flameCombo = 1;
				if ( GlobalVars[Challenge1] == 1 && GlobalVars[Challenge2] == 1 && GlobalVars[Challenge3] == 1 && GlobalVars[Challenge4] == 1 )
					waitUntilWhiteRect = 180;
				else
					waitUntilWarp = 150;
			}
			
			if ( waitUntilWhiteRect > 0 )
				waitUntilWhiteRect --;
			if ( waitUntilWhiteRect == 30 )
				Game->PlayEnhancedMusic(openingSound, Game->GetDMapMusicTrack(23));
			if ( waitUntilWhiteRect == 90 )
				screenShake = true;
			
			if ( screenShake )
				Screen->Quake = 4;
			
			if ( whiteRectX != 0 ) {
				whiteRectX -= 2;
			}
			
			if ( waitUntilWhiteRect == 1 )
				whiteRectX = -2;
			
			if ( gateOpening != 0 && !Screen->State[ST_SECRET] ) {
				int currentX = gateOpening;
				Floor(currentX);
				Screen->FastCombo(2, 96-currentX, 64, 516, 11, OP_OPAQUE);
				Screen->FastCombo(2, 112-currentX, 64, 516, 11, OP_OPAQUE);
				Screen->FastCombo(2, 96-currentX, 80, 516, 11, OP_OPAQUE);
				Screen->FastCombo(2, 112-currentX, 80, 516, 11, OP_OPAQUE);
				Screen->FastCombo(2, 96-currentX, 96, 516, 11, OP_OPAQUE);
				Screen->FastCombo(2, 112-currentX, 96, 516, 11, OP_OPAQUE);
				Screen->FastCombo(2, 128+currentX, 64, 516, 11, OP_OPAQUE);
				Screen->FastCombo(2, 144+currentX, 64, 516, 11, OP_OPAQUE);
				Screen->FastCombo(2, 128+currentX, 80, 516, 11, OP_OPAQUE);
				Screen->FastCombo(2, 144+currentX, 80, 516, 11, OP_OPAQUE);
				Screen->FastCombo(2, 128+currentX, 96, 516, 11, OP_OPAQUE);
				Screen->FastCombo(2, 144+currentX, 96, 516, 11, OP_OPAQUE);
			}
			
			if ( whiteRectX != 0 ) {
				if ( whiteRectX > -64 )
					Screen->Rectangle(6, 128+whiteRectX, 88+whiteRectX*2, 128+whiteRectX*-1, 88+whiteRectX*2*-1, 0x01, 1, 0, 0, 0, true, OP_OPAQUE);
				else
					Screen->Rectangle(6, 128+whiteRectX, 88+whiteRectX*2, 128+whiteRectX*-1, 88+whiteRectX*2*-1, 0x01, 1, 0, 0, 0, true, OP_TRANS);
			}
			
			if ( gateOpening > 0 )
				gateOpening += 0.05;
			
			if ( whiteRectX == -72 ) {
				gateOpening = 1;
				Screen->ComboD[71] = 1168;
				Screen->ComboD[72] = 1169;
				Screen->ComboD[87] = 1170;
				Screen->ComboD[88] = 1171;
				Screen->ComboD[103] = 1172;
				Screen->ComboD[104] = 1173;
			}
			
			if ( whiteRectX == -80 )
				whiteRectX = 0;
			
			if ( gateOpening >= 16 && !Screen->State[ST_SECRET] ) {
				Game->PlaySound(27);
				Screen->TriggerSecrets();
				Screen->State[ST_SECRET] = true;
				screenShake = false;
				waitUntilWarp = 150;
			}
			Waitframe();
		}
	}
}

ffc script ChallengeFireScreen{
	void run(){
		if ( GlobalVars[Challenge1] != 1 || GlobalVars[Challenge2] != 1 || GlobalVars[Challenge3] != 1 || GlobalVars[Challenge4] != 1 ) {
			if ( GlobalVars[Challenge1] == 1 )
				Screen->ComboD[105] = 1164;
			if ( GlobalVars[Challenge2] == 1 )
				Screen->ComboD[102] = 1165;
			if ( GlobalVars[Challenge3] == 1 )
				Screen->ComboD[73] = 1166;
			if ( GlobalVars[Challenge4] == 1 )
				Screen->ComboD[70] = 1167;
		}
		else {
			Waitframe();
			if ( GlobalVars[GauntletIntro] == 0 ) {
				Screen->ComboD[71] += 8;
				Screen->ComboD[72] += 8;
				Screen->ComboD[87] += 8;
				Screen->ComboD[88] += 8;
				Screen->ComboD[103] += 8;
				Screen->ComboD[104] += 8;
			}
		}
	}
}

ffc script GauntletIntro{
	void run(){
		Screen->Message(71);
		WaitNoAction();
		GlobalVars[GauntletIntro] = 1;
		this->Data = 888;
		NoAction();
	}
}

ffc script GauntletBossRematch{
	void run(int type){
		if ( type == 1 ) {
			CreateNPCAt(97, 32, 80);
			CreateNPCAt(186, 112, 48);
		}
		Waitframes(4);
		bool RoomClear;
		while(true){
			int enemies = Screen->NumNPCs();
			for (int i = 1; i <= Screen->NumNPCs(); i++) {
				npc enem = Screen->LoadNPC(i);
				if ( enem->Type == NPCT_FAIRY || enem->Type == NPCT_TRAP || enem->Type == NPCT_GUY )
					enemies --;
			}
			if ( !RoomClear && enemies == 0 ) {
				RoomClear = true;
				Game->PlaySound(27);
				Screen->TriggerSecrets();
				CreateItemAt(34, 120, 80);
			}
			Waitframe();
		}
	}
}

ffc script TitleScreen{
	void run(){
		if ( Screen->State[ST_SECRET] == true )
			Quit();
		int ZScriptX = 48;
		int ZScriptY = -48;
		int HavocX = 64;
		int HavocY = 176;
		int TitleTimer = 120;
		int HorizontalSpeed = 2;
		int VerticalSpeed = 3;
		while(true){
			if ( ZScriptX >= 256 ) {
				Screen->State[ST_SECRET] = true;
				Quit();
			}
			else {
				NoAction();
				Link->InputStart = false;
				Link->InputMap = false;
			}
			if ( ZScriptY < 48 ) {
				ZScriptY += VerticalSpeed;
				HavocY -= VerticalSpeed;
				VerticalSpeed -= 0.04;
			}
			else if ( TitleTimer != 0 )
				TitleTimer --;
			if ( TitleTimer == 0 ) {
				ZScriptX += HorizontalSpeed;
				HavocX -= HorizontalSpeed;
				HorizontalSpeed += 0.05;
			}
			Screen->DrawTile(6, ZScriptX, ZScriptY, 38743, 10, 3, 6, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
			Screen->DrawTile(6, HavocX, HavocY, 38804, 8, 2, 6, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
			Waitframe();
		}
	}
}

ffc script CountdownNumbers{
	void run(){
		int NumberY = -180;
		int YSpeed = 4.4;
		int State = 0;
		int Number;
		if ( Game->GetCurScreen() == 0x50 )
			Number = 9;
		if ( Game->GetCurScreen() == 0x40 )
			Number = 8;
		if ( Game->GetCurScreen() == 0x30 )
			Number = 7;
		if ( Game->GetCurScreen() == 0x20 )
			Number = 6;
		if ( Game->GetCurScreen() == 0x10 )
			Number = 5;
		if ( Game->GetCurScreen() == 0x62 )
			Number = 4;
		if ( Game->GetCurScreen() == 0x52 )
			Number = 3;
		if ( Game->GetCurScreen() == 0x42 )
			Number = 2;
		if ( Game->GetCurScreen() == 0x32 )
			Number = 1;
		while(true){
			NumberY += YSpeed;
			if ( State == 0 )
				YSpeed -= 0.05;
			if ( State == -1 )
				YSpeed += 0.05;
			if ( YSpeed == 0.5 && State == 0 )
				State = 1;
			if ( State > 0 )
				State ++;
			if ( State == 45 )
				State = -1;
			if ( NumberY > 356 )
				Quit();
			if ( Number == 0 ) {
				Screen->DrawInteger(6, 12+4, NumberY+4, FONT_Z1, 0x07, -1, 240, 240, 1, 0, OP_OPAQUE);
				Screen->DrawInteger(6, 124+4, NumberY+4, FONT_Z1, 0x07, -1, 240, 240, 0, 0, OP_OPAQUE);
				Screen->DrawInteger(6, 12, NumberY, FONT_Z1, 0x01, -1, 240, 240, 1, 0, OP_OPAQUE);
				Screen->DrawInteger(6, 124, NumberY, FONT_Z1, 0x01, -1, 240, 240, 0, 0, OP_OPAQUE);
			}
			else {
				Screen->DrawInteger(6, 72+4, NumberY+4, FONT_Z1, 0x07, -1, 240, 240, Number, 0, OP_OPAQUE);
				Screen->DrawInteger(6, 72, NumberY, FONT_Z1, 0x01, -1, 240, 240, Number, 0, OP_OPAQUE);
			}
			Waitframe();
		}
	}
}

ffc script AscendedTraps{
	void run(int type){
		int TrapX[20];
		int TrapY[20];
		if ( type == 0 ) {
			TrapX[0] = 32;
			TrapY[0] = 32;
			TrapX[1] = 32;
			TrapY[1] = 64;
			TrapX[2] = 32;
			TrapY[2] = 96;
		}
		if ( type == 1 ) {
			TrapX[0] = 48;
			TrapY[0] = 32;
			TrapX[1] = 4800;
			TrapY[1] = 6400;
			TrapX[2] = 48;
			TrapY[2] = 80;
			TrapX[3] = 80;
			TrapY[3] = 80;
			TrapX[4] = 8000;
			TrapY[4] = 9600;
			TrapX[5] = 80;
			TrapY[5] = 128;
			TrapX[6] = 192;
			TrapY[6] = 32;
			TrapX[7] = 19200;
			TrapY[7] = 6400;
			TrapX[8] = 192;
			TrapY[8] = 80;
			TrapX[9] = 160;
			TrapY[9] = 80;
			TrapX[10] = 16000;
			TrapY[10] = 9600;
			TrapX[11] = 160;
			TrapY[11] = 128;
		}
		
		int State;
		int FramesTimer;
		
		int Wind[20];
		while(true){
			if ( type == 0 ) {
				if ( TrapY[0] == 32 && TrapX[0] < 208 ) {
					TrapX[0] += 2.75;
					TrapX[1] += 2.75;
					TrapX[2] += 2.75;
					if ( TrapX[0] > 208 ) {
						TrapX[0] = 208;
						TrapX[1] = 208;
						TrapX[2] = 208;
					}
				}
				if ( TrapX[0] == 208 && TrapY[0] < 48 ) {
					TrapY[0] += 2.75;
					TrapY[1] += 2.75;
					TrapY[2] += 2.75;
					if ( TrapY[0] > 48 ) {
						TrapY[0] = 48;
						TrapY[1] = 48+32;
						TrapY[2] = 48+64;
					}
				}
				if ( TrapY[0] == 48 && TrapX[0] > 32 ) {
					TrapX[0] -= 2.75;
					TrapX[1] -= 2.75;
					TrapX[2] -= 2.75;
					if ( TrapX[0] < 32 ) {
						TrapX[0] = 32;
						TrapX[1] = 32;
						TrapX[2] = 32;
					}
				}
				if ( TrapX[0] == 32 && TrapY[0] > 32 ) {
					TrapY[0] -= 2.75;
					TrapY[1] -= 2.75;
					TrapY[2] -= 2.75;
					if ( TrapY[0] < 32 ) {
						TrapY[0] = 32;
						TrapY[1] = 32+32;
						TrapY[2] = 32+64;
					}
				}
			}
			
			if ( type == 1 ) {
				if ( TrapX[0] < 80 && TrapY[0] == 32 ) {
					TrapX[0] ++;
					TrapX[1] ++;
					TrapX[2] ++;
					TrapX[3] --;
					TrapX[4] --;
					TrapX[5] --;
					TrapX[6] --;
					TrapX[7] --;
					TrapX[8] --;
					TrapX[9] ++;
					TrapX[10] ++;
					TrapX[11] ++;
				}
				if ( TrapX[0] == 80 && TrapY[0] < 80 ) {
					TrapY[0] ++;
					TrapY[1] ++;
					TrapY[2] ++;
					TrapY[3] --;
					TrapY[4] --;
					TrapY[5] --;
					TrapY[6] ++;
					TrapY[7] ++;
					TrapY[8] ++;
					TrapY[9] --;
					TrapY[10] --;
					TrapY[11] --;
				}
				if ( TrapX[0] > 48 && TrapY[0] == 80 ) {
					TrapX[0] --;
					TrapX[1] --;
					TrapX[2] --;
					TrapX[3] ++;
					TrapX[4] ++;
					TrapX[5] ++;
					TrapX[6] ++;
					TrapX[7] ++;
					TrapX[8] ++;
					TrapX[9] --;
					TrapX[10] --;
					TrapX[11] --;
				}
				if ( TrapX[0] == 48 && TrapY[0] > 32 ) {
					TrapY[0] --;
					TrapY[1] --;
					TrapY[2] --;
					TrapY[3] ++;
					TrapY[4] ++;
					TrapY[5] ++;
					TrapY[6] --;
					TrapY[7] --;
					TrapY[8] --;
					TrapY[9] ++;
					TrapY[10] ++;
					TrapY[11] ++;
				}
			}
			
			if ( type == 2 ) {
				if ( State == 0 && ComboAt(Link->X+8, Link->Y+12) == 42 ) {
					State = 1;
					Screen->ComboD[42] ++;
					Screen->ComboD[133] --;
				}
				if ( State == 1 && ComboAt(Link->X+8, Link->Y+12) == 133 ) {
					State = 2;
					Screen->ComboD[133] ++;
					Game->PlaySound(27);
					Screen->TriggerSecrets();
				}
				for (int i = 0; i < 20; i++) {
					if ( (State == 0 || State == 2) && TrapY[i] > 0 )
						TrapX[i] += 2;
					if ( State == 1 && TrapY[i] > 0 )
						TrapX[i] -= 2;
					if ( ((State == 0 || State == 2) && TrapX[i] > 256)
					|| (State == 1 && TrapX[i] < -16) ) {
						TrapX[i] = 0;
						TrapY[i] = 0;
					}
				}
				if ( (State == 0 && FramesTimer >= 50) || (State == 1 && FramesTimer >= 45) || (State == 2 && FramesTimer >= 45) ) {
					FramesTimer = 0;
					int XToPut = -16;
					if ( State == 1 )
						XToPut = 256;
					for (int i = 0; i < 20; i++) {
						if ( TrapX[i] == 0 && TrapY[i] == 0 ) {
							TrapX[i] = XToPut;
							TrapY[i] = Choose(64, 80, 96);
							if ( State == 2 )
								Wind[i] = 1;
							for (int j = 0; j < 20; j++) {
								if ( TrapX[j] == 0 && TrapY[j] == 0 ) {
									TrapX[j] = XToPut;
									if ( TrapY[i] == 64 )
										TrapY[j] = Choose(80, 96);
									if ( TrapY[i] == 80 )
										TrapY[j] = Choose(64, 96);
									if ( TrapY[i] == 96 )
										TrapY[j] = Choose(64, 80);
									if ( State == 2 )
										Wind[j] = 1;
									j = 20;
								}
							}
							i = 20;
						}
					}
				}
				FramesTimer ++;
			}
			
			for (int i = 0; i < 20; i++) {
				if ( TrapX[i] != 0 || TrapY[i] != 0) {
					if ( Wind[i] == 0 )
						Screen->FastCombo(2, TrapX[i], TrapY[i], 1184, 7, OP_OPAQUE);
					else
						Screen->FastCombo(2, TrapX[i], TrapY[i], 1185, 7, OP_OPAQUE);
					if ( RectCollision(TrapX[i]+5, TrapY[i]+5, TrapX[i]+10, TrapY[i]+10, Link->X, Link->Y+2, Link->X+15, Link->Y+15) ) {
						if ( Wind[i] == 0 ) {
							eweapon e = FireEWeapon(EW_SCRIPT10, Link->X+InFrontX(Link->Dir, 12), Link->Y+InFrontY(Link->Dir, 12), 0, 0, 12, -1, -1, EWF_UNBLOCKABLE);
							e->Dir = Link->Dir;
							e->DrawYOffset = -1000;
							SetEWeaponLifespan(e, EWL_TIMER, 1);
							SetEWeaponDeathEffect(e, EWD_VANISH, 0);
						}
						else
							this->Data = 889;
					}
				}
			}
			Waitframe();
		}
	}
}

const int BlueSmall = 27653;
const int BlueMedium = 27654;
const int RedSmall = 27673;
const int RedMedium = 27674;

ffc script SimonSays{ //its a mess
	void run(int type){
		int CenterX = 120;
		int CenterY = 80;
		int OneX;
		int OneY;
		int TwoX;
		int TwoY;
		int ThreeX;
		int ThreeY;
		int FourX;
		int FourY;
		
		int CenterTile = BlueMedium;
		int OneTile = RedSmall;
		int TwoTile = RedSmall;
		int ThreeTile = RedSmall;
		int FourTile = RedSmall;
		
		int Radius = 47;
		int Degree;
		
		int Wins;
		int State; //0 = step on center to start, 1 = sequence, 2 = solve puzzle, 3 = won
		int Order[6];
		int SequenceTimer;
		
		int AnimationPos;
		int AnimationRadius;
		
		int StandingOn;
		int LinkOrder[6];
		
		int WaitToStateTwo;
		while(true){
			if ( type == 1 && State != 3 )
				Degree += 0.5;
			if(Degree < -360)Degree+=360;
			else if(Degree > 360)Degree-=360;
			OneX = CenterX + Radius*Cos(Degree+45);
			OneY = CenterY + Radius*Sin(Degree+45);
			TwoX = CenterX + Radius*Cos(Degree+135);
			TwoY = CenterY + Radius*Sin(Degree+135);
			ThreeX = CenterX + Radius*Cos(Degree+225);
			ThreeY = CenterY + Radius*Sin(Degree+225);
			FourX = CenterX + Radius*Cos(Degree+315);
			FourY = CenterY + Radius*Sin(Degree+315);
			Screen->FastTile(1, CenterX, CenterY, CenterTile, 2, OP_OPAQUE);
			Screen->FastTile(1, OneX, OneY, OneTile, 2, OP_OPAQUE);
			Screen->FastTile(1, TwoX, TwoY, TwoTile, 2, OP_OPAQUE);
			Screen->FastTile(1, ThreeX, ThreeY, ThreeTile, 2, OP_OPAQUE);
			Screen->FastTile(1, FourX, FourY, FourTile, 2, OP_OPAQUE);
			
			if ( SequenceTimer > 0 ) {
				SequenceTimer --;
				if ( SequenceTimer == 0 ) {
					if ( Order[0] == 0 ) {
						Order[0] = Rand(1, 4);
						AnimationPos = Order[0];
					}
					else if ( Order[1] == 0 ) {
						bool ok;
						while(!ok){
							Order[1] = Rand(1, 4);
							if ( Order[1] != Order[0] )
								ok = true;
						}
						AnimationPos = Order[1];
					}
					else if ( Order[2] == 0 ) {
						bool ok;
						while(!ok){
							Order[2] = Rand(1, 4);
							if ( Order[2] != Order[1] )
								ok = true;
						}
						AnimationPos = Order[2];
					}
					else if ( Order[3] == 0 ) {
						bool ok;
						while(!ok){
							Order[3] = Rand(1, 4);
							if ( Order[3] != Order[2] )
								ok = true;
						}
						AnimationPos = Order[3];
					}
					else if ( Order[4] == 0 ) {
						bool ok;
						while(!ok){
							Order[4] = Rand(1, 4);
							if ( Order[4] != Order[3] )
								ok = true;
						}
						AnimationPos = Order[4];
						
					}
					else if ( Order[5] == 0 ) {
						bool ok;
						while(!ok){
							Order[5] = Rand(1, 4);
							if ( Order[5] != Order[4] )
								ok = true;
						}
						AnimationPos = Order[5];
					}
					Game->PlaySound(60);
					AnimationRadius = 4;
					if ( (Order[3] == 0 && Wins == 0) || (Order[5] == 0 && Wins == 1) )
						SequenceTimer = 45;
					else
						WaitToStateTwo = 16;
				}
			}
			
			if ( Distance(Link->X+8, Link->Y+12, CenterX+8, CenterY+8) < 8 && State == 0 ) {
				State = 1;
				CenterTile = BlueSmall;
				OneTile = RedMedium;
				TwoTile = RedMedium;
				ThreeTile = RedMedium;
				FourTile = RedMedium;
				for (int i = 0; i <= 5; i++) {
					Order[i] = 0;
					LinkOrder[i] = 0;
				}
				SequenceTimer = 45;
			}
			
			if ( State == 2 ) {
				if ( Distance(Link->X+8, Link->Y+12, OneX+8, OneY+8) < 8 && StandingOn != 1 ) {
					StandingOn = 1;
					if ( LinkOrder[0] == 0 )
						LinkOrder[0] = 1;
					else if ( LinkOrder[1] == 0 )
						LinkOrder[1] = 1;
					else if ( LinkOrder[2] == 0 )
						LinkOrder[2] = 1;
					else if ( LinkOrder[3] == 0 )
						LinkOrder[3] = 1;
					else if ( LinkOrder[4] == 0 )
						LinkOrder[4] = 1;
					else if ( LinkOrder[5] == 0 )
						LinkOrder[5] = 1;
					Game->PlaySound(60);
					AnimationPos = 1;
					AnimationRadius = 4;
				}
				if ( Distance(Link->X+8, Link->Y+12, TwoX+8, TwoY+8) < 8 && StandingOn != 2 ) {
					StandingOn = 2;
					if ( LinkOrder[0] == 0 )
						LinkOrder[0] = 2;
					else if ( LinkOrder[1] == 0 )
						LinkOrder[1] = 2;
					else if ( LinkOrder[2] == 0 )
						LinkOrder[2] = 2;
					else if ( LinkOrder[3] == 0 )
						LinkOrder[3] = 2;
					else if ( LinkOrder[4] == 0 )
						LinkOrder[4] = 2;
					else if ( LinkOrder[5] == 0 )
						LinkOrder[5] = 2;
					Game->PlaySound(60);
					AnimationPos = 2;
					AnimationRadius = 4;
				}
				if ( Distance(Link->X+8, Link->Y+12, ThreeX+8, ThreeY+8) < 8 && StandingOn != 3 ) {
					StandingOn = 3;
					if ( LinkOrder[0] == 0 )
						LinkOrder[0] = 3;
					else if ( LinkOrder[1] == 0 )
						LinkOrder[1] = 3;
					else if ( LinkOrder[2] == 0 )
						LinkOrder[2] = 3;
					else if ( LinkOrder[3] == 0 )
						LinkOrder[3] = 3;
					else if ( LinkOrder[4] == 0 )
						LinkOrder[4] = 3;
					else if ( LinkOrder[5] == 0 )
						LinkOrder[5] = 3;
					Game->PlaySound(60);
					AnimationPos = 3;
					AnimationRadius = 4;
				}
				if ( Distance(Link->X+8, Link->Y+12, FourX+8, FourY+8) < 8 && StandingOn != 4 ) {
					StandingOn = 4;
					if ( LinkOrder[0] == 0 )
						LinkOrder[0] = 4;
					else if ( LinkOrder[1] == 0 )
						LinkOrder[1] = 4;
					else if ( LinkOrder[2] == 0 )
						LinkOrder[2] = 4;
					else if ( LinkOrder[3] == 0 )
						LinkOrder[3] = 4;
					else if ( LinkOrder[4] == 0 )
						LinkOrder[4] = 4;
					else if ( LinkOrder[5] == 0 )
						LinkOrder[5] = 4;
					Game->PlaySound(60);
					AnimationPos = 4;
					AnimationRadius = 4;
				}
				if ( (LinkOrder[0] != 0 && LinkOrder[0] != Order[0])
				|| (LinkOrder[1] != 0 && LinkOrder[1] != Order[1])
				|| (LinkOrder[2] != 0 && LinkOrder[2] != Order[2])
				|| (LinkOrder[3] != 0 && LinkOrder[3] != Order[3])
				|| (LinkOrder[4] != 0 && LinkOrder[4] != Order[4])
				|| (LinkOrder[5] != 0 && LinkOrder[5] != Order[5]) ) {
					AnimationPos = 0;
					AnimationRadius = 0;
					State = 0;
					CenterTile = BlueMedium;
					OneTile = RedSmall;
					TwoTile = RedSmall;
					ThreeTile = RedSmall;
					FourTile = RedSmall;
					Game->PlaySound(61);
				}
				else if ( (Wins == 0 && LinkOrder[3] != 0) || (Wins == 1 && LinkOrder[5] != 0) ) {
					Wins ++;
					if ( Wins == 1 ) {
						State = 0;
						CenterTile = BlueMedium;
						OneTile = RedSmall;
						TwoTile = RedSmall;
						ThreeTile = RedSmall;
						FourTile = RedSmall;
					}
					else {
						State = 3;
						CenterTile = 20;
						OneTile = 20;
						TwoTile = 20;
						ThreeTile = 20;
						FourTile = 20;
						Game->PlaySound(27);
						Screen->TriggerSecrets();
					}
				}
				if ( Distance(Link->X+8, Link->Y+12, OneX+8, OneY+8) >= 10 && StandingOn == 1 )
					StandingOn = 0;
				if ( Distance(Link->X+8, Link->Y+12, TwoX+8, TwoY+8) >= 10 && StandingOn == 2 )
					StandingOn = 0;
				if ( Distance(Link->X+8, Link->Y+12, ThreeX+8, ThreeY+8) >= 10 && StandingOn == 3 )
					StandingOn = 0;
				if ( Distance(Link->X+8, Link->Y+12, FourX+8, FourY+8) >= 10 && StandingOn == 4 )
					StandingOn = 0;
			}
			
			if ( AnimationPos != 0 ) {
				if ( AnimationPos == 1 )
					Screen->Circle(6, OneX+8, OneY+8, AnimationRadius, 0x01, 1, 0, 0, 0, false, OP_OPAQUE);
				if ( AnimationPos == 2 )
					Screen->Circle(6, TwoX+8, TwoY+8, AnimationRadius, 0x01, 1, 0, 0, 0, false, OP_OPAQUE);
				if ( AnimationPos == 3 )
					Screen->Circle(6, ThreeX+8, ThreeY+8, AnimationRadius, 0x01, 1, 0, 0, 0, false, OP_OPAQUE);
				if ( AnimationPos == 4 )
					Screen->Circle(6, FourX+8, FourY+8, AnimationRadius, 0x01, 1, 0, 0, 0, false, OP_OPAQUE);
				AnimationRadius ++;
				if ( AnimationRadius > 20 ) {
					AnimationRadius = 0;
					AnimationPos = 0;
				}
			}
			
			if ( State == 1 )
				NoAction();
			if ( WaitToStateTwo > 0 ) {
				WaitToStateTwo --;
				if ( WaitToStateTwo == 0 )
					State = 2;
			}
			Waitframe();
		}
	}
}

ffc script Xerath{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
		Ghost_SetFlag(GHF_FLYING_ENEMY);
		Ghost_Transform(this, ghost, -1, -1, 2, 3);
		int counter = -1;
		int floating;
		int attackTimer = 120;
		int attackCounter;
		int attack;
		int attack1Radius;
		int laserAngle;
		int laserA = -1;
		int laserB = -1;
		int wRectRadius;
		int wCircleFlash;
		int wCircleX;
		int wCircleY;
		int eX = -1;
		int eY = -1;
		int attack3Animation;
		int eAngle;
		int XerathStunnedLink;
		int eFollowUp;
		int rAngle;
		int rAngle2;
		int rAngle05;
		int rAngle15;
		int rRadius;
		int rFrames;
		while(true){
			if ( attack == 0 )
				counter = Ghost_ConstantWalk8(counter, 75, ghost->Rate, ghost->Homing, ghost->Hunger);
			if ( attack == 1 && attack1Radius < 12 )
				counter = Ghost_ConstantWalk8(counter, 25, ghost->Rate, ghost->Homing, ghost->Hunger);
			
			if ( attackTimer > 0 )
				attackTimer --;
			if ( attackTimer == 1 ) {
				attack = Choose(1, 1, 2, 2, 3);
				if ( eFollowUp == 0 )
					attackCounter ++;
				else
					attack = eFollowUp;
				eFollowUp = 0;
				if ( attackCounter == 6 ) {
					attackCounter = 0;
					attack = 4;
				}
				if ( attack == 1 ) {
					attack1Radius = 4;
					Ghost_Data = 1190;
				}
				if ( attack == 2 ) {
					Ghost_Data = 1190;
					wRectRadius = 6;
					wCircleX = Link->X+8;
					wCircleY = Link->Y+8;
				}
				if ( attack == 3 ) {
					attack3Animation = 20;
					Ghost_Data = 1190;
					eX = Ghost_X+8;
					eY = Ghost_Y+4;
					eAngle = Angle(Ghost_X+8, Ghost_Y+4, CenterLinkX(), CenterLinkY());
				}
				if ( attack == 4 ) {
					Ghost_Data = 1191;
					rRadius = 4;
					rFrames = 0;
					Game->PlaySound(75);
					Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
				}
			}
			
			if ( attack == 1 ) {
				if ( attack1Radius < 12 )
					Screen->Circle(6, Ghost_X+16, Ghost_Y, attack1Radius, 0x01, 1, 0, 0, 0, true, OP_OPAQUE);
				attack1Radius += 0.1;
				if ( attack1Radius == 12 ) {
					Ghost_Data = 1189;
					laserAngle = Angle(Ghost_X+16, Ghost_Y+2, CenterLinkX(), CenterLinkY());
					laserA = 0;
				}
				if ( laserA >= 0 ) {
					if(laserA%4<2){
						DrawLaser(4, Ghost_X+16, Ghost_Y+2, 10, laserAngle, C_EZB_LASER3);
					}
					laserA ++;
					if ( laserA == 25 ) {
						laserA = -1;
						laserB = 0;
						Game->PlaySound(SFX_EZB_LASER);
					}
				}
				if ( laserB >= 0 ) {
					Laser3Color(4, Ghost_X+16, Ghost_Y+2, 10, laserAngle, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
					laserB ++;
					if ( laserB == 20 ) {
						laserB = -1;
						attack = 0;
						attackTimer = Rand(90, 150);
					}
				}
			}
			
			if ( attack == 2 ) {
				if ( wRectRadius > 0 )
					Screen->Rectangle(6, wCircleX-wRectRadius, 0, wCircleX+wRectRadius, wCircleY, 0x8C, 1, 0, 0, 0, true, OP_OPAQUE);
				wRectRadius -= 0.075 + wRectRadius / 32;
				if ( wCircleFlash <= 2 )
					Screen->Circle(1, wCircleX, wCircleY, 24, 0x8C, 1, 0, 0, 0, true, OP_OPAQUE);
				wCircleFlash ++;
				if ( wCircleFlash > 4 )
					wCircleFlash = 0;
				if ( wRectRadius <= 1.5 )
					Ghost_Data = 1189;
				if ( wRectRadius <= 0 ) {
					eweapon boom = CreateEWeaponAt(EW_SBOMBBLAST, wCircleX-8, wCircleY-8);
					boom->Damage = ghost->WeaponDamage;
					attack = 0;
					attackTimer = Rand(90, 150);
				}
			}
			
			if ( attack == 3 ) {
				if ( attack3Animation == 0 ) {
					attack = 0;
					Ghost_Data = 1189;
					attackTimer = 40+Rand(90, 150);
				}
				attack3Animation --;
			}
			
			if ( attack == 4 ) {
				rFrames ++;
				eweapon wpn;
				if ( rFrames == 40 || rFrames == 60 || rFrames == 80 ) {
					int angle = Angle(CenterX(ghost), CenterY(ghost)+4, CenterLinkX(), CenterLinkY());
					wpn = FireEWeapon(EW_SCRIPT10, CenterX(ghost), CenterY(ghost)+4, DegtoRad(angle), Distance(Link->X+8, Link->Y+8, CenterX(ghost), CenterY(ghost)+4)*3, ghost->WeaponDamage, 110, 0, EWF_SHADOW);
					SetEWeaponMovement(wpn, EWM_THROW, -1, EWMF_DIE);
					SetEWeaponDeathEffect(wpn, EWD_EXPLODE, ghost->WeaponDamage);
				}
				if ( rFrames == 120 || rFrames == 160 ) {
					int initialLX = Link->X;
					int initialLY = Link->Y;
					if ( Link->InputUp )
						Link->Y -= 32;
					if ( Link->InputRight )
						Link->X += 32;
					if ( Link->InputDown )
						Link->Y += 32;
					if ( Link->InputLeft )
						Link->X -= 32;
					int angle = Angle(CenterX(ghost), CenterY(ghost)+4, CenterLinkX(), CenterLinkY());
					wpn = FireEWeapon(EW_SCRIPT10, CenterX(ghost), CenterY(ghost)+4, DegtoRad(angle), Distance(Link->X+8, Link->Y+8, CenterX(ghost), CenterY(ghost)+4)*3, ghost->WeaponDamage, 110, 0, EWF_SHADOW);
					SetEWeaponMovement(wpn, EWM_THROW, -1, EWMF_DIE);
					SetEWeaponDeathEffect(wpn, EWD_EXPLODE, ghost->WeaponDamage);
					Link->X = initialLX;
					Link->Y = initialLY;
				}
				if ( rRadius < 14 )
					rRadius ++;
				Screen->Circle(2, CenterX(ghost), CenterY(ghost)+4, rRadius, 0x8C, 1, 0, 0, 0, true, OP_OPAQUE);
				rAngle += 4;
				if(rAngle < -360)rAngle+=360;
				else if(rAngle > 360)rAngle-=360;
				rAngle2 += 4*2;
				if(rAngle2 < -360)rAngle2+=360;
				else if(rAngle2 > 360)rAngle2-=360;
				rAngle05 += 4*0.5;
				if(rAngle05 < -360)rAngle05+=360;
				else if(rAngle05 > 360)rAngle05-=360;
				rAngle15 += 4*1.5;
				if(rAngle15 < -360)rAngle15+=360;
				else if(rAngle15 > 360)rAngle15-=360;
				int tile1X = CenterX(ghost)-8 + 8*Cos(rAngle);
				int tile1Y = CenterY(ghost)+4-8 + 8*Sin(rAngle);
				int tile2X = CenterX(ghost)-8 + 14*Cos(rAngle+40);
				int tile2Y = CenterY(ghost)+4-8 + 14*Sin(rAngle+40);
				int tile3X = CenterX(ghost)-8 + 10*Cos(rAngle2+80);
				int tile3Y = CenterY(ghost)+4-8 + 10*Sin(rAngle2+80);
				int tile4X = CenterX(ghost)-8 + 9*Cos(rAngle+120);
				int tile4Y = CenterY(ghost)+4-8 + 9*Sin(rAngle+120);
				int tile5X = CenterX(ghost)-8 + 8*Cos(rAngle05+20);
				int tile5Y = CenterY(ghost)+4-8 + 8*Sin(rAngle05+20);
				int tile6X = CenterX(ghost)-8 + 11*Cos(rAngle15+90);
				int tile6Y = CenterY(ghost)+4-8 + 11*Sin(rAngle15+90);
				int tile7X = CenterX(ghost)-8 + 8*Cos(rAngle15+180);
				int tile7Y = CenterY(ghost)+4-8 + 8*Sin(rAngle15+180);
				Screen->DrawTile(2, tile1X, tile1Y, 39008, 1, 1, 8, -1, -1, tile1X, tile1Y, rAngle*2, 0, true, OP_OPAQUE);
				Screen->DrawTile(2, tile2X, tile2Y, 39009, 1, 1, 8, -1, -1, tile2X, tile2Y, rAngle*2, 0, true, OP_OPAQUE);
				Screen->DrawTile(2, tile3X, tile3Y, 39010, 1, 1, 8, -1, -1, tile3X, tile3Y, rAngle*2, 0, true, OP_OPAQUE);
				Screen->DrawTile(2, tile4X, tile4Y, 39011, 1, 1, 8, -1, -1, tile4X, tile4Y, rAngle*2, 0, true, OP_OPAQUE);
				Screen->DrawTile(2, tile7X, tile7Y, 39012, 1, 1, 8, -1, -1, tile7X, tile7Y, rAngle*2, 0, true, OP_OPAQUE);
				Screen->DrawTile(2, tile6X, tile6Y, 39013, 1, 1, 8, -1, -1, tile6X, tile6Y, rAngle*2, 0, true, OP_OPAQUE);
				Screen->DrawTile(2, tile5X, tile5Y, 39014, 1, 1, 8, -1, -1, tile5X, tile5Y, rAngle*2, 0, true, OP_OPAQUE);
				if ( rFrames >= 240 ) {
					attack = 0;
					Ghost_Data = 1189;
					attackTimer = Rand(90, 150);
					Ghost_SetAllDefenses(ghost, NPCDT_NONE);
				}
			}
			
			if ( eX != -1 && eY != -1 ) {
				eX += VectorX(3, eAngle);
				eY += VectorY(3, eAngle);
				if ( eX < 0 || eY < 0 || eX > 240 || eY > 160 ) {
					eX = -1;
					eY = -1;
				}
				if ( RectCollision(eX+4, eY+4, eX+11, eY+11, Link->X, Link->Y, Link->X+15, Link->Y+15) ) {
					Game->PlaySound(19);
					Link->HP -= 8;
					eX = -1;
					eY = -1;
					XerathStunnedLink = 60;
					eFollowUp = Choose(1, 2);
					attack = 0;
					Ghost_Data = 1189;
					attackTimer = 2;
				}
				if ( eX != -1 && eY != -1 )
					Screen->FastTile(3, eX, eY, 27366, 7, OP_OPAQUE);
			}
			
			if ( XerathStunnedLink > 0 ) {
				NoAction();
				XerathStunnedLink --;
			}
			
			if ( floating >= 0 && floating <= 10 )
				ghost->DrawYOffset = 0;
			if ( floating >= 11 && floating <= 20 )
				ghost->DrawYOffset = -1;
			if ( floating >= 21 && floating <= 40 )
				ghost->DrawYOffset = -2;
			if ( floating >= 41 && floating <= 50 )
				ghost->DrawYOffset = -1;
			if ( floating >= 51 && floating <= 60 )
				ghost->DrawYOffset = 0;
			if ( floating >= 61 && floating <= 70 )
				ghost->DrawYOffset = 1;
			if ( floating >= 71 && floating <= 90 )
				ghost->DrawYOffset = 2;
			if ( floating >= 91 && floating <= 100 )
				ghost->DrawYOffset = 1;
			floating += 1.5;
			if ( floating >= 100 )
				floating = 0;
			
			Ghost_Waitframe(this, ghost, 1, true);
		}
	}
}

ffc script XerathIntro{
	void run(){
		if ( Screen->State[ST_SECRET] == true )
			Quit();
		WaitNoAction(120);
		int radius = 0;
		while(true){
			Screen->Circle(6, 128, 52, radius, 0x8C, 1, 0, 0, 0, true, OP_OPAQUE);
			if ( radius < 32 )
				radius += 0.25;
			else {
				int timer;
				while(true){
					if ( timer == 45 )
						this->Data = 888;
					Screen->Circle(6, 128, 52, radius, 0x01, 1, 0, 0, 0, true, OP_OPAQUE);
					timer ++;
					NoAction();
					Waitframe();
				}
			}
			Screen->Quake = 4;
			NoAction();
			Waitframe();
		}
	}
}

const int Vars_AppearAnimation = 0;
const int Vars_DisappearAnimation = 1;
const int Vars_SizeMultiplierX = 2;
const int Vars_SizeMultiplierY = 3;
const int Vars_BitmapStop = 4;

ffc script Avos{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
		Ghost_SetFlag(GHF_FLYING_ENEMY);
		Ghost_Transform(this, ghost, -1, -1, 2, 3);
		int Vars[200]; //can be used in the custom waitframe
		Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
		ghost->DrawXOffset = -1000;
		ghost->HitXOffset = -1000;
		
		Ghost_X = 112;
		Ghost_Y = 32;
		Game->PlayMIDI(0);
		if ( GlobalVars[AvosIntro] == 0 ) {
			Screen->Message(74);
			GlobalVars[NoActionFix] = 1;
			Avos_Waitframe(this, ghost, Vars);
		}
		Vars[Vars_AppearAnimation] = 1;
		while(ghost->DrawXOffset != 0){
			GlobalVars[NoActionFix] = 1;
			Avos_Waitframe(this, ghost, Vars);
		}
		for(int i = 1; i <= 60; i++) {
			GlobalVars[NoActionFix] = 1;
			Avos_Waitframe(this, ghost, Vars);
		}
		if ( GlobalVars[AvosIntro] == 0 )
			Screen->Message(75);
		GlobalVars[NoActionFix] = 1;
		Avos_Waitframe(this, ghost, Vars);
		GlobalVars[AvosIntro] = 1;
		int bossmusic[256];
		Game->GetDMapMusicFilename(11, bossmusic);
		Game->PlayEnhancedMusic(bossmusic, Game->GetDMapMusicTrack(11));
		
		int ScriptedHP = 10;
		bool SpecialAttack;
		
		int SpecialAttack1String[] = "import !ScreenTearing.z!";
		SpecialAttack1String[strchr(SpecialAttack1String, '!')] = '"';
		SpecialAttack1String[strchr(SpecialAttack1String, '!')] = '"';
		int SpecialAttack2String[] = "import !AXE.z!";
		SpecialAttack2String[strchr(SpecialAttack2String, '!')] = '"';
		SpecialAttack2String[strchr(SpecialAttack2String, '!')] = '"';
		int SpecialAttack3String[] = "import !UnusedMiniboss.z!";
		SpecialAttack3String[strchr(SpecialAttack3String, '!')] = '"';
		SpecialAttack3String[strchr(SpecialAttack3String, '!')] = '"';
		int SpecialAttack4String[] = "import !LaserShow.z!";
		SpecialAttack4String[strchr(SpecialAttack4String, '!')] = '"';
		SpecialAttack4String[strchr(SpecialAttack4String, '!')] = '"';
		int SpecialAttack5String[] = "import !IcePhysics.z!";
		SpecialAttack5String[strchr(SpecialAttack5String, '!')] = '"';
		SpecialAttack5String[strchr(SpecialAttack5String, '!')] = '"';
		
		int NextScreenTearingType = -1;
		
		while(true){
			if ( !SpecialAttack )
				Avos_Teleport(this, ghost, Vars);
			else {
				SpecialAttack = false;
				bool ok;
				while(!ok){
					Ghost_X = Rand(32, 192);
					Ghost_Y = Rand(32, 96);
					if ( Distance(Ghost_X+16, Ghost_Y+24, Link->X+8, Link->Y+8) > 56 )
						ok = true;
				}
				Vars[Vars_AppearAnimation] = 1;
				while(ghost->DrawXOffset != 0){
					Avos_Waitframe(this, ghost, Vars);
				}
			}
			
			if ( ScriptedHP == 5 && Screen->D[0] == 0 ) { //phase 2
				Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
				Avos_Waitframes(this, ghost, Vars, 60);
				Ghost_Data ++;
				Avos_Waitframes(this, ghost, Vars, 15);
				Ghost_Data ++;
				Avos_Waitframes(this, ghost, Vars, 15);
				Ghost_Data ++;
				Screen->D[0] = 1;
				Avos_Waitframes(this, ghost, Vars, 200);
				Avos_Teleport(this, ghost, Vars);
			}
			
			int RandomAttack = Rand(1, 3);
			
			if ( RandomAttack == 1 ) {
				int angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
				for(int i = -75; i <= 75; i+=15) {
					FireEWeapon(EW_FIREBALL, VectorX(16, angle-180)+CenterX(ghost)-8+32*Cos(angle+i), VectorY(16, angle-180)+CenterY(ghost)-8+32*Sin(angle+i), DegtoRad(angle), 150, ghost->WeaponDamage, -1, -1, 0);
				}
				if ( Screen->D[0] == 1 ) {
					Avos_Waitframes(this, ghost, Vars, 75);
					angle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					for(int i = -75; i <= 75; i+=15) {
						FireEWeapon(EW_FIREBALL, VectorX(16, angle-180)+CenterX(ghost)-8+32*Cos(angle+i), VectorY(16, angle-180)+CenterY(ghost)-8+32*Sin(angle+i), DegtoRad(angle), 150, ghost->WeaponDamage, -1, -1, 0);
					}
				}
				Avos_Waitframes(this, ghost, Vars, 180);
			}
			
			if ( RandomAttack == 2 ) {
				int angle = Rand(360);
				int extra;
				for(int i = 0; i <= 180; i+=20) {
					FireEWeapon(EW_FIREBALL, CenterX(ghost)-8, CenterY(ghost)-8, DegtoRad(angle+i), 200, ghost->WeaponDamage, -1, -1, 0);
					FireEWeapon(EW_FIREBALL, CenterX(ghost)-8, CenterY(ghost)-8, DegtoRad(angle+i+180), 200, ghost->WeaponDamage, -1, -1, 0);
					Avos_Waitframes(this, ghost, Vars, 2);
				}
				if ( Screen->D[0] == 1 ) {
					Avos_Waitframes(this, ghost, Vars, 6);
					for(int i = 1; i <= 3; i++) {
						FireAimedEWeapon(EW_FIREBALL, CenterX(ghost)-8, CenterY(ghost)-8, 0, 200, ghost->WeaponDamage, -1, -1, 0);
						Avos_Waitframes(this, ghost, Vars, 8);
					}
				}
				Avos_Waitframes(this, ghost, Vars, 160);
			}
			
			if ( RandomAttack == 3 ) {
				int initAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
				initAngle += Choose(-90, 90);
				int whatwaschosen;
				whatwaschosen = initAngle - Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
				for(int i = -30; i <= 30; i+=10) {
					int angle = Angle(VectorX(i, initAngle)+CenterX(ghost), VectorY(i, initAngle)+CenterY(ghost), CenterLinkX(), CenterLinkY());
					FireEWeapon(EW_FIREBALL, VectorX(i, initAngle)+CenterX(ghost)-8, VectorY(i, initAngle)+CenterY(ghost)-8, DegtoRad(angle), 250, ghost->WeaponDamage, -1, -1, 0);
					Avos_Waitframes(this, ghost, Vars, 4);
				}
				if ( Screen->D[0] == 1 ) {
					Avos_Waitframes(this, ghost, Vars, 30);
					initAngle = Angle(CenterX(ghost), CenterY(ghost), CenterLinkX(), CenterLinkY());
					initAngle += whatwaschosen;
					for(int i = 30; i >= -30; i-=10) {
						int angle = Angle(VectorX(i, initAngle)+CenterX(ghost), VectorY(i, initAngle)+CenterY(ghost), CenterLinkX(), CenterLinkY());
						FireEWeapon(EW_FIREBALL, VectorX(i, initAngle)+CenterX(ghost)-8, VectorY(i, initAngle)+CenterY(ghost)-8, DegtoRad(angle), 250, ghost->WeaponDamage, -1, -1, 0);
						Avos_Waitframes(this, ghost, Vars, 4);
					}
				}
				Avos_Waitframes(this, ghost, Vars, 160);
			}
			
			if ( Ghost_HP <= 370 ) {
				ScriptedHP --;
				if ( ScriptedHP >= 0 )
					SpecialAttack = true;
				if ( SpecialAttack && (ScriptedHP == 9 || ScriptedHP == 4) )
					Avos_String(this, ghost, Vars, SpecialAttack1String, 82);
				if ( SpecialAttack && (ScriptedHP == 8 || ScriptedHP == 3) )
					Avos_String(this, ghost, Vars, SpecialAttack2String, 101);
				if ( SpecialAttack && (ScriptedHP == 7 || ScriptedHP == 2) )
					Avos_String(this, ghost, Vars, SpecialAttack3String, 80);
				if ( SpecialAttack && (ScriptedHP == 6 || ScriptedHP == 1) )
					Avos_String(this, ghost, Vars, SpecialAttack4String, 88);
				if ( SpecialAttack && (ScriptedHP == 5 || ScriptedHP == 0) )
					Avos_String(this, ghost, Vars, SpecialAttack5String, 88);
				
				if ( ScriptedHP == -1 ) { //dead
					Game->PlayMIDI(0);
					Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
					for(int i = 1; i <= 40; i++) {
						GlobalVars[NoActionFix] = 1;
						Avos_Waitframe(this, ghost, Vars);
					}
					Screen->Message(79);
					GlobalVars[NoActionFix] = 1;
					Avos_Waitframe(this, ghost, Vars);
					Ghost_Data = 1192;
					Avos_Waitframe(this, ghost, Vars);
					Ghost_Explode(this, ghost);
					this->Data = 888;
					Quit();
				}
				
				Ghost_HP = 400;
			}
			
			if ( SpecialAttack && (ScriptedHP == 9 || ScriptedHP == 4) ) { //ScreenTearing
				Link->DrawXOffset = -1000;
				Vars[Vars_BitmapStop] = 1;
				int type = Choose(1, 2);
				if ( NextScreenTearingType != -1 )
					type = NextScreenTearingType;
				if ( type == 1 )
					NextScreenTearingType = 2;
				else
					NextScreenTearingType = 1;
				int corner1X;
				int corner1Y;
				int corner2X;
				int corner2Y;
				int corner3X;
				int corner3Y;
				int corner4X;
				int corner4Y;
				if ( type == 1 ) {
					corner1X = 64;
					corner1Y = 0;
					corner2X = 96;
					corner2Y = 0;
					corner3X = 64;
					corner3Y = 175;
					corner4X = 96;
					corner4Y = 175;
				}
				else {
					corner1X = 192;
					corner1Y = 175;
					corner2X = 160;
					corner2Y = 175;
					corner3X = 192;
					corner3Y = 0;
					corner4X = 160;
					corner4Y = 0;
				}
				int angle = Angle(corner2X, corner2Y, corner3X, corner3Y);
				int distance;
				int shots;
				int shotdelay = 25;
				int endwait;
				GlobalVars[HurtCSetFrames] = 0;
				while(endwait < 180){
					if ( Link->Action == LA_GOTHURTLAND && GlobalVars[HurtCSetFrames] == 0 )
						GlobalVars[HurtCSetFrames] = 45;
					if ( GlobalVars[HurtCSetFrames] > 0 ) {
						GlobalVars[HurtCSetFrames] --;
						if ( GlobalVars[HurtCSetTimer] > 5 )
							GlobalVars[HurtCSet] = 6;
						else if ( GlobalVars[HurtCSetTimer] > 3 )
							GlobalVars[HurtCSet] = 7;
						else if ( GlobalVars[HurtCSetTimer] > 1 )
							GlobalVars[HurtCSet] = 8;
						else
							GlobalVars[HurtCSet] = 9;
						GlobalVars[HurtCSetTimer] ++;
						if ( GlobalVars[HurtCSetTimer] > 7 )
							GlobalVars[HurtCSetTimer] = 0;
					}
					else
						GlobalVars[HurtCSet] = 6;
					
					Screen->SetRenderTarget(1);
					Screen->DrawScreen(0, 11, 0x33, 0, 0, 0);
					Screen->DrawBitmap(0, 6, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
					Screen->DrawTile(0, Link->X, Link->Y, Link->Tile, 1, 1, GlobalVars[HurtCSet], -1, -1, 0, 0, 0, Link->Flip, true, OP_OPAQUE);
					for (int i = 1; i <= Screen->NumEWeapons(); i++) {
						eweapon wpn = Screen->LoadEWeapon(i);
						if ( type == 1 )
							Screen->DrawTile(0, wpn->X, wpn->Y, wpn->Tile-2, 1, 1, 8, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
						else
							Screen->DrawTile(0, wpn->X, wpn->Y, wpn->Tile-2, 1, 1, 8, -1, -1, 0, 0, 0, 1, true, OP_OPAQUE);
					}
					Screen->SetRenderTarget(0);
					Screen->DrawBitmap(0, 1, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
					Screen->Triangle(0, corner1X, corner1Y, corner2X, corner2Y, corner3X, corner3Y, 1, 1, 0, 0, 39060, PT_TEXTURE);
					if ( type == 1 )
						Screen->Rectangle(0, 0, 0, corner3X, corner3Y, 0x07, 1, 0, 0, 0, true, OP_OPAQUE);
					else
						Screen->Rectangle(0, corner3X, corner3Y, 255, 175, 0x07, 1, 0, 0, 0, true, OP_OPAQUE);
					Screen->SetRenderTarget(1);
					Screen->Triangle(0, corner4X, corner4Y, corner2X, corner2Y, corner3X, corner3Y, 1, 1, 0, 0, 39061, PT_TEXTURE);
					if ( type == 1 )
						Screen->Rectangle(0, corner2X, corner2Y, 255, 175, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
					else
						Screen->Rectangle(0, 0, 0, corner2X, corner2Y, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
					Screen->SetRenderTarget(-1);
					Screen->DrawBitmap(0, 0, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
					Screen->DrawBitmap(0, 1, 0, 0, 256, 176, VectorX(distance, angle), VectorY(distance, angle), 256, 176, 0, true);
					
					if ( endwait == 0 && distance < 16 )
						distance ++;
					if ( endwait >= 120 && distance > 0 )
						distance --;
					
					if ( (shots < 12 && Screen->D[0] == 0) || (shots < 15 && Screen->D[0] == 1) ) {
						if ( shotdelay == 0 ) {
							shotdelay = 25;
							for(int i = 1; i <= 3; i++) {
								if ( type == 1 )
									FireNonAngularEWeapon(EW_SCRIPT10, 0, 32+16*Rand(0, 6), DIR_RIGHT, 200, ghost->WeaponDamage, 111, 0, 0);
								else
									FireNonAngularEWeapon(EW_SCRIPT10, 240, 32+16*Rand(0, 6), DIR_LEFT, 200, ghost->WeaponDamage, 111, 0, 0);
							}
							shots ++;
						}
						else
							shotdelay --;
					}
					else
						endwait ++;
					Avos_Waitframe(this, ghost, Vars);
				}
				Link->DrawXOffset = 0;
				Vars[Vars_BitmapStop] = 0;
			}
			
			if ( SpecialAttack && (ScriptedHP == 8 || ScriptedHP == 3) ) { //AXE
				int cornerX[4];
				int cornerY[4];
				cornerX[1] = 224;
				cornerY[2] = 144;
				cornerX[3] = 224;
				cornerY[3] = 144;
				int randcorner = Rand(0, 3);
				for(int i = 0; i <= 3; i++) {
					int currentcorner = i + randcorner;
					if ( currentcorner > 3 )
						currentcorner -= 4;
					if ( i < 3 )
						FireBigAimedEWeapon(EW_SCRIPT10, cornerX[currentcorner], cornerY[currentcorner], 0, 180, ghost->WeaponDamage+2, 112, -1, 0, 2, 2);
					else {
						eweapon wpn = FireBigAimedEWeapon(EW_SCRIPT10, cornerX[currentcorner], cornerY[currentcorner], 0, 125, ghost->WeaponDamage+2, 112, -1, 0, 2, 2);
						SetEWeaponMovement(wpn, EWM_HOMING, DegtoRad(1), 150);
					}
					Avos_Waitframes(this, ghost, Vars, 45);
				}
				Avos_Waitframes(this, ghost, Vars, 140);
				if ( Screen->D[0] == 1 ) {
					int direction = 32;
					int fallingX;
					if ( Link->X <= 120 ) {
						direction = -32;
						fallingX = 224;
					}
					for(int i = 1; i <= 8; i++) {
						FireBigEWeapon(EW_SCRIPT10, fallingX, 0, DegtoRad(90), 230, ghost->WeaponDamage+2, 112, -1, 0, 2, 2);
						fallingX += direction;
						Avos_Waitframes(this, ghost, Vars, 35);
					}
					Avos_Waitframes(this, ghost, Vars, 45);
				}
				int X1;
				int X2;
				int angle1;
				int angle2;
				if ( Link->X > 120 ) {
					X2 = 224;
					angle2 = 180;
				}
				else {
					X1 = 224;
					angle1 = 180;
				}
				for(int i = -36; i <= 36; i+=24) {
					FireBigEWeapon(EW_SCRIPT10, X1, 72, DegtoRad(i+angle1), 150, ghost->WeaponDamage+2, 112, -1, 0, 2, 2);
				}
				Avos_Waitframes(this, ghost, Vars, 150);
				for(int i = -36; i <= 36; i+=24) {
					FireBigEWeapon(EW_SCRIPT10, X2, 72, DegtoRad(i+angle2), 150, ghost->WeaponDamage+2, 112, -1, 0, 2, 2);
				}
				Avos_Waitframes(this, ghost, Vars, 180);
			}
			
			if ( SpecialAttack && (ScriptedHP == 7 || ScriptedHP == 2) ) { //UnusedMiniboss
				npc Ganon = CreateNPCAt(190, 0, 0);
				while(Ganon->isValid()){
					Avos_Waitframe(this, ghost, Vars);
				}
				for(int i = 1; i <= 90; i++) {
					Avos_Waitframe(this, ghost, Vars);
				}
			}
			
			if ( SpecialAttack && (ScriptedHP == 6 || ScriptedHP == 1) ) { //LaserShow
				Avos_LaserCross(this, ghost, Vars);
				Avos_LaserLines(this, ghost, Vars);
				if ( Screen->D[0] == 1 )
					Avos_LaserLines(this, ghost, Vars);
				Avos_LaserCross(this, ghost, Vars);
				Avos_LaserPrison(this, ghost, Vars);
				Avos_LaserCross(this, ghost, Vars);
				Avos_LaserLines(this, ghost, Vars);
				if ( Screen->D[0] == 1 )
					Avos_LaserLines(this, ghost, Vars);
				Avos_LaserCross(this, ghost, Vars);
				Avos_Waitframes(this, ghost, Vars, 100);
			}
			
			if ( SpecialAttack && (ScriptedHP == 5 || ScriptedHP == 0) ) { //IcePhysics
				Screen->D[1] = 1;
				int endwait = 150;
				int attacktime = 420;
				int TrapX[10];
				int TrapY[10];
				int TrapVx[10];
				int TrapVy[10];
				TrapX[0] = 120;
				TrapY[0] = 176;
				TrapVx[0] = -1;
				TrapVy[0] = -1;
				TrapX[1] = 120;
				TrapY[1] = 176;
				TrapVx[1] = 1;
				TrapVy[1] = -1;
				TrapX[2] = 120;
				TrapY[2] = -16;
				TrapVx[2] = -1;
				TrapVy[2] = 1;
				TrapX[3] = 120;
				TrapY[3] = -16;
				TrapVx[3] = 1;
				TrapVy[3] = 1;
				while(endwait > 0){
					if ( attacktime == 280 || attacktime == 150 ) {
						int next;
						if ( attacktime == 150 )
							next ++;
						int rand = Rand(1, 4);
						if ( rand == 1 ) {
							TrapX[4+next] = Link->X+VectorX(Link->Y*2, 315);
							TrapY[4+next] = Link->Y+VectorY(Link->Y*2, 315);
							TrapVx[4+next] = -1;
							TrapVy[4+next] = 1;
						}
						if ( rand == 2 ) {
							TrapX[4+next] = Link->X+VectorX((176-Link->Y)*2, 45);
							TrapY[4+next] = Link->Y+VectorY((176-Link->Y)*2, 45);
							TrapVx[4+next] = -1;
							TrapVy[4+next] = -1;
						}
						if ( rand == 3 ) {
							TrapX[4+next] = Link->X+VectorX((176-Link->Y)*2, 135);
							TrapY[4+next] = Link->Y+VectorY((176-Link->Y)*2, 135);
							TrapVx[4+next] = 1;
							TrapVy[4+next] = -1;
						}
						if ( rand == 4 ) {
							TrapX[4+next] = Link->X+VectorX(Link->Y*2, 225);
							TrapY[4+next] = Link->Y+VectorY(Link->Y*2, 225);
							TrapVx[4+next] = 1;
							TrapVy[4+next] = 1;
						}
					}
					for (int i = 0; i < 10; i++) {
						TrapX[i] += TrapVx[i];
						TrapY[i] += TrapVy[i];
						if ( attacktime > 0 ) {
							if ( (TrapVx[i] > 0 && TrapX[i] >= 208) || (TrapVx[i] < 0 && TrapX[i] <= 32) )
								TrapVx[i] *= -1;
							if ( (TrapVy[i] > 0 && TrapY[i] >= 128) || (TrapVy[i] < 0 && TrapY[i] <= 32) )
								TrapVy[i] *= -1;
						}
						if ( TrapVx[i] != 0 && TrapVy[i] != 0) {
							Screen->FastCombo(2, TrapX[i], TrapY[i], 1047, 7, OP_OPAQUE);
							if ( RectCollision(TrapX[i]+5, TrapY[i]+5, TrapX[i]+10, TrapY[i]+10, Link->X, Link->Y+2, Link->X+15, Link->Y+15) ) {
								eweapon e = FireEWeapon(EW_SCRIPT10, Link->X+InFrontX(Link->Dir, 12), Link->Y+InFrontY(Link->Dir, 12), 0, 0, 4, -1, -1, EWF_UNBLOCKABLE);
								e->Dir = Link->Dir;
								e->DrawYOffset = -1000;
								SetEWeaponLifespan(e, EWL_TIMER, 1);
								SetEWeaponDeathEffect(e, EWD_VANISH, 0);
							}
						}
					}
					if ( attacktime <= 0 )
						endwait --;
					if ( attacktime <= 45 && Screen->D[0] == 1 )
						attacktime -= 0.5;
					else
						attacktime --;
					Avos_Waitframe(this, ghost, Vars);
				}
				Screen->D[1] = 0;
			}			
		}
	}
}

void Avos_Waitframe(ffc this, npc ghost, int Vars){
	if ( Vars[Vars_AppearAnimation] == 1 ) {
		Game->PlaySound(62);
		Screen->SetRenderTarget(0);
		Screen->Rectangle(0, 0, 0, 255, 175, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
		Screen->DrawCombo(0, 0, 0, Ghost_Data, 2, 3, 8, -1, -1, 0, 0, 0, 1, 0, true, OP_OPAQUE);
		Screen->SetRenderTarget(-1);
		Vars[Vars_SizeMultiplierX] = 0;
		Vars[Vars_SizeMultiplierY] = 2;
		Vars[Vars_AppearAnimation] = 2;
	}
	if ( Vars[Vars_AppearAnimation] == 2 ) {
		Screen->DrawBitmap(6, 0, 0, 0, 32, 48, Ghost_X+16*(Vars[Vars_SizeMultiplierY]-1), Ghost_Y-32*(Vars[Vars_SizeMultiplierY]-1), 32*Vars[Vars_SizeMultiplierX], 48*Vars[Vars_SizeMultiplierY], 0, true);
		Vars[Vars_SizeMultiplierX] += 0.075;
		Vars[Vars_SizeMultiplierY] -= 0.075;
		if ( Vars[Vars_SizeMultiplierX] >= 1 ) {
			Vars[Vars_AppearAnimation] = 0;
			Ghost_SetAllDefenses(ghost, NPCDT_NONE);
			ghost->DrawXOffset = 0;
			ghost->HitXOffset = 0;
		}
	}
	if ( Vars[Vars_DisappearAnimation] == 1 ) {
		Game->PlaySound(62);
		Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
		ghost->DrawXOffset = -1000;
		ghost->HitXOffset = -1000;
		Screen->SetRenderTarget(0);
		Screen->Rectangle(0, 0, 0, 255, 175, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
		Screen->DrawCombo(0, 0, 0, Ghost_Data, 2, 3, 8, -1, -1, 0, 0, 0, 1, 0, true, OP_OPAQUE);
		Screen->SetRenderTarget(-1);
		Vars[Vars_SizeMultiplierX] = 1;
		Vars[Vars_SizeMultiplierY] = 1;
		Vars[Vars_DisappearAnimation] = 2;
	}
	if ( Vars[Vars_DisappearAnimation] == 2 ) {
		Screen->DrawBitmap(6, 0, 0, 0, 32, 48, Ghost_X+16*(Vars[Vars_SizeMultiplierY]-1), Ghost_Y-32*(Vars[Vars_SizeMultiplierY]-1), 32*Vars[Vars_SizeMultiplierX], 48*Vars[Vars_SizeMultiplierY], 0, true);
		Vars[Vars_SizeMultiplierX] -= 0.075;
		Vars[Vars_SizeMultiplierY] += 0.075;
		if ( Vars[Vars_SizeMultiplierX] <= 0 )
			Vars[Vars_DisappearAnimation] = 0;
	}
	if ( Vars[Vars_BitmapStop] == 0 )
		Screen->DrawBitmap(0, 6, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
	Ghost_Waitframe(this, ghost);
}

void Avos_Waitframes(ffc this, npc ghost, int Vars, int num){
	for(int i = 1; i <= num; i++) {
		Avos_Waitframe(this, ghost, Vars);
	}
}

void Avos_Teleport(ffc this, npc ghost, int Vars){
	Vars[Vars_DisappearAnimation] = 1;
	while(Vars[Vars_DisappearAnimation]!= 0 || ghost->DrawXOffset == 0){
		Avos_Waitframe(this, ghost, Vars);
	}
	bool ok;
	while(!ok){
		Ghost_X = Rand(32, 192);
		Ghost_Y = Rand(32, 96);
		if ( Distance(Ghost_X+16, Ghost_Y+24, Link->X+8, Link->Y+8) > 56 )
			ok = true;
	}
	Vars[Vars_AppearAnimation] = 1;
	while(ghost->DrawXOffset != 0){
		Avos_Waitframe(this, ghost, Vars);
	}
}

void Avos_String(ffc this, npc ghost, int Vars, int SpecialAttackString, int x){
	int WritingString[200];
	for(int i = 0; i < strlen(SpecialAttackString); i++) {
		if ( i > 0 )
			WritingString[i-1] = SpecialAttackString[i-1];
		WritingString[i] = 'l';
		for(int j = 1; j <= 3; j++) {
			Screen->DrawString(6, x, 84, FONT_P, 0x01, 0x01, TF_NORMAL, SpecialAttackString, OP_OPAQUE);
			Screen->DrawString(6, x, 84, FONT_P, 0x07, 0x01, TF_NORMAL, WritingString, OP_OPAQUE);
			Avos_Waitframe(this, ghost, Vars);
		}
	}
	WritingString[strlen(SpecialAttackString)-1] = SpecialAttackString[strlen(SpecialAttackString)-1];
	Vars[Vars_DisappearAnimation] = 1;
	for(int i = 1; i <= 90; i++) {
		Screen->DrawString(6, x, 84, FONT_P, 0x01, 0x01, TF_NORMAL, SpecialAttackString, OP_OPAQUE);
		Screen->DrawString(6, x, 84, FONT_P, 0x07, 0x01, TF_NORMAL, WritingString, OP_OPAQUE);
		Avos_Waitframe(this, ghost, Vars);
	}
}

void Avos_LaserLines(ffc this, npc ghost, int Vars){
	int laserX[100];
	int laserY[100];
	int angle = Rand(360);
	int pointX = 128;
	int pointY = 88;
	pointX += VectorX(156, angle+180);
	pointY += VectorY(156, angle+180);
	for(int i=-8; i<=8; i++){
		laserX[i+8] = pointX + VectorX(i*48, angle+90);
		laserY[i+8] = pointY + VectorY(i*48, angle+90);
	}
	for(int i=0; i<40; i++){
		if(i%4<2){
			for(int j=0; j<=16; j++){
				DrawLaser(4, laserX[j], laserY[j], 10, angle, C_EZB_LASER3);
			}
		}
		Avos_Waitframe(this, ghost, Vars);
	}
	Game->PlaySound(SFX_EZB_LASER);
	for(int i=0; i<30; i++){
		for(int j=0; j<=16; j++){
			Laser3Color(4, laserX[j], laserY[j], 10, angle, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
		}
		Avos_Waitframe(this, ghost, Vars);
	}
}

void Avos_LaserCross(ffc this, npc ghost, int Vars){
	int laserX[100];
	int laserY[100];
	int angle = Rand(360);
	laserX[0] = Link->X+8 + VectorX(256, angle+180);
	laserY[0] = Link->Y+8 + VectorY(256, angle+180);
	laserX[1] = Link->X+8 + VectorX(256, angle+270);
	laserY[1] = Link->Y+8 + VectorY(256, angle+270);
	for(int i=0; i<50; i++){
		if(i%4<2){
			for(int j=0; j<=1; j++){
				DrawLaser(4, laserX[j], laserY[j], 8, angle+j*90, C_EZB_LASER3);
			}
		}
		Avos_Waitframe(this, ghost, Vars);
	}
	Game->PlaySound(SFX_EZB_LASER);
	for(int i=0; i<30; i++){
		for(int j=0; j<=1; j++){
			Laser3Color(4, laserX[j], laserY[j], 8, angle+j*90, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
		}
		Avos_Waitframe(this, ghost, Vars);
	}
}

void Avos_LaserPrison(ffc this, npc ghost, int Vars){
	int laserX[100];
	int laserY[100];
	int angle = Rand(360);
	laserX[0] = Link->X+8 + VectorX(256, angle+180) + VectorX(32, angle+180+90);
	laserY[0] = Link->Y+8 + VectorY(256, angle+180) + VectorY(32, angle+180+90);
	laserX[1] = Link->X+8 + VectorX(256, angle+180) - VectorX(32, angle+180+90);
	laserY[1] = Link->Y+8 + VectorY(256, angle+180) - VectorY(32, angle+180+90);
	laserX[2] = Link->X+8 + VectorX(256, angle+270) + VectorX(32, angle+270+90);
	laserY[2] = Link->Y+8 + VectorY(256, angle+270) + VectorY(32, angle+270+90);
	laserX[3] = Link->X+8 + VectorX(256, angle+270) - VectorX(32, angle+270+90);
	laserY[3] = Link->Y+8 + VectorY(256, angle+270) - VectorY(32, angle+270+90);
	for(int i=0; i<40; i++){
		if(i%4<2){
			for(int j=0; j<=3; j++){
				int extra;
				if ( j > 1 )
					extra = 90;
				DrawLaser(4, laserX[j], laserY[j], 10, angle+extra, C_EZB_LASER3);
			}
		}
		Avos_Waitframe(this, ghost, Vars);
	}
	Game->PlaySound(SFX_EZB_LASER);
	for(int i=0; i<30; i++){
		for(int j=0; j<=3; j++){
			int extra;
			if ( j > 1 )
				extra = 90;
			Laser3Color(4, laserX[j], laserY[j], 10, angle+extra, ghost->WeaponDamage, C_EZB_LASER1, C_EZB_LASER2, C_EZB_LASER3);
		}
		Avos_Waitframe(this, ghost, Vars);
	}
}

ffc script Ganon{
    void run(int enemyid){
        npc ghost = Ghost_InitAutoGhost(this, enemyid);
        Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
        Ghost_Transform(this, ghost, -1, -1, 2, 2);
		int PositionsX[14];
		int PositionsY[14];
		PositionsX[0] = 112;
		PositionsY[0] = 48;
		PositionsX[1] = 144;
		PositionsY[1] = 64;
		PositionsX[2] = 80;
		PositionsY[2] = 80;
		PositionsX[3] = 112;
		PositionsY[3] = 96;
		PositionsX[4] = 32;
		PositionsY[4] = 32;
		PositionsX[5] = 80;
		PositionsY[5] = 32;
		PositionsX[6] = 144;
		PositionsY[6] = 32;
		PositionsX[7] = 192;
		PositionsY[7] = 32;
		PositionsX[8] = 48;
		PositionsY[8] = 64;
		PositionsX[9] = 176;
		PositionsY[9] = 80;
		PositionsX[10] = 32;
		PositionsY[10] = 112;
		PositionsX[11] = 80;
		PositionsY[11] = 112;
		PositionsX[12] = 144;
		PositionsY[12] = 112;
		PositionsX[13] = 192;
		PositionsY[13] = 112;
		Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
		ghost->DrawXOffset = -1000;
		ghost->HitXOffset = -1000;
        while(true){
			for(int i = 1; i <= 90; i++) {
				for(int j = 0; j <= 13; j++) {
					Screen->DrawCombo(0, PositionsX[j], PositionsY[j], Ghost_Data+3, 2, 2, 0, -1, -1, 0, 0, 0, 1, 0, true, OP_OPAQUE);
				}
				Ghost_Waitframe(this, ghost);
			}
			int Flames[14];
			int GanonsPos = Rand(4, 13);
			for(int i = 0; i <= 13; i++) {
				if ( i == GanonsPos )
					i++;
				if ( i <= 13 ) {
					FireNonAngularEWeapon(EW_FIRE, PositionsX[i], PositionsY[i], 0, 0, ghost->WeaponDamage, -1, -1, 0);
					FireNonAngularEWeapon(EW_FIRE, PositionsX[i]+16, PositionsY[i], 0, 0, ghost->WeaponDamage, -1, -1, 0);
					FireNonAngularEWeapon(EW_FIRE, PositionsX[i], PositionsY[i]+16, 0, 0, ghost->WeaponDamage, -1, -1, 0);
					FireNonAngularEWeapon(EW_FIRE, PositionsX[i]+16, PositionsY[i]+16, 0, 0, ghost->WeaponDamage, -1, -1, 0);
					Flames[i] = 1;
					for(int j = 0; j <= 13; j++) {
						if ( Flames[j] == 0 )
							Screen->DrawCombo(0, PositionsX[j], PositionsY[j], Ghost_Data+3, 2, 2, 0, -1, -1, 0, 0, 0, 1, 0, true, OP_OPAQUE);
					}
					Ghost_Waitframe(this, ghost);
				}
			}
			for(int i = 1; i <= 120; i++) {
				for(int j = 0; j <= 13; j++) {
					if ( Flames[j] == 0 )
						Screen->DrawCombo(0, PositionsX[j], PositionsY[j], Ghost_Data+3, 2, 2, 0, -1, -1, 0, 0, 0, 1, 0, true, OP_OPAQUE);
				}
				Ghost_Waitframe(this, ghost);
			}
			Ghost_SetAllDefenses(ghost, NPCDT_NONE);
			ghost->DrawXOffset = 0;
			ghost->HitXOffset = 0;
			Ghost_X = PositionsX[GanonsPos];
			Ghost_Y = PositionsY[GanonsPos];
			int attacktimer = 1;
			while(Ghost_HP > 390){
				if ( attacktimer <= 0 ) {
					eweapon wpn = FireAimedEWeapon(EW_FIREBALL, CenterX(ghost)-8, CenterY(ghost)-8, 0, 180, ghost->WeaponDamage, -1, -1, 0);
					SetEWeaponMovement(wpn, EWM_SINE_WAVE, 10, 6);
					if ( Screen->D[0] == 1 ) {
						eweapon wpn2 = FireAimedEWeapon(EW_FIREBALL, CenterX(ghost)-8, CenterY(ghost)-8, DegtoRad(-35), 180, ghost->WeaponDamage, -1, -1, 0);
						SetEWeaponMovement(wpn2, EWM_SINE_WAVE, 10, 6);
						eweapon wpn3 = FireAimedEWeapon(EW_FIREBALL, CenterX(ghost)-8, CenterY(ghost)-8, DegtoRad(35), 180, ghost->WeaponDamage, -1, -1, 0);
						SetEWeaponMovement(wpn3, EWM_SINE_WAVE, 10, 6);
					}
					attacktimer = Rand(90, 180);
				}
				else
					attacktimer --;
				Ghost_Waitframe(this, ghost);
			}
			if ( Ghost_Data < 1202 ) {
				Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
				ghost->DrawXOffset = -1000;
				ghost->HitXOffset = -1000;
				Ghost_Data ++;
				Ghost_HP = 400;
			}
			else {
				Ghost_HP = 0;
				Ghost_Waitframe(this, ghost);
			}
        }
    }
}

//Thanks Moosh
void The_Spergiest_Thing_I_Will_Ever_Write_Probably(int Layer, int rt, int OldMap, int OldScreen, int NewMap, int NewScreen){
    int PointX[40];
    int PointY[40];
    int i;
    for(i=0; i<40; i++){
        PointX[i] = -48+48*(i%8)+(Floor(i/8)%2)*0.5*48;
        PointY[i] = -16+Floor(i/8)*48;
        PointX[i] += Rand(-8, 8);
        PointY[i] += Rand(-8, 8);
    }
    int TA[56];
    int TB[56];
    int TC[56];
    for(i=0; i<7; i++){
        TA[i] = i;
        TB[i] = i+1;
        TC[i] = i+8;
    }
    for(i=0; i<7; i++){
        TA[7+i] = i+1;
        TB[7+i] = 8+i;
        TC[7+i] = 8+i+1;
    }
    for(i=0; i<7; i++){
        TA[14+i] = 8+i;
        TB[14+i] = 8+i+1;
        TC[14+i] = 8+i+9;
    }
    for(i=0; i<7; i++){
        TA[21+i] = 8+i;
        TB[21+i] = 16+i;
        TC[21+i] = 16+i+1;
    }
    for(i=0; i<7; i++){
        TA[28+i] = 16+i;
        TB[28+i] = 16+i+1;
        TC[28+i] = 16+i+8;
    }
    for(i=0; i<7; i++){
        TA[35+i] = 16+i+1;
        TB[35+i] = 24+i;
        TC[35+i] = 24+i+1;
    }
    for(i=0; i<7; i++){
        TA[42+i] = 24+i;
        TB[42+i] = 24+i+1;
        TC[42+i] = 24+i+9;
    }
    for(i=0; i<7; i++){
        TA[49+i] = 24+i;
        TB[49+i] = 32+i;
        TC[49+i] = 32+i+1;
    }
    int CPX[56];
    int CPY[56];
    int CPZ[56];
    int AngA[56];
    int AngB[56];
    int AngC[56];
    int DA[56];
    int DB[56];
    int DC[56];
    int BaseAngA[56];
    int BaseAngB[56];
    int RotA[56];
    int RotB[56];
    int VX[56];
    int VY[56];
    Screen->SetRenderTarget(rt);
    Screen->Rectangle(0, -8, -8, 264, 184, 0x5A, 1, 0, 0, 0, true, 128);
    Screen->DrawScreen(0, NewMap, NewScreen, 0, 0, 0);
    Screen->SetRenderTarget(RT_SCREEN);
    for(i=0; i<56; i++){
        CPX[i] = (PointX[TA[i]]+PointX[TB[i]]+PointX[TC[i]])/3;
        CPY[i] = (PointY[TA[i]]+PointY[TB[i]]+PointY[TC[i]])/3;
        AngA[i] = Angle(CPX[i], CPY[i], PointX[TA[i]], PointY[TA[i]]);
        AngB[i] = Angle(CPX[i], CPY[i], PointX[TB[i]], PointY[TB[i]]);
        AngC[i] = Angle(CPX[i], CPY[i], PointX[TC[i]], PointY[TC[i]]);
        DA[i] = Distance(CPX[i], CPY[i], PointX[TA[i]], PointY[TA[i]]);
        DB[i] = Distance(CPX[i], CPY[i], PointX[TB[i]], PointY[TB[i]]);
        DC[i] = Distance(CPX[i], CPY[i], PointX[TC[i]], PointY[TC[i]]);
        //BaseAngA[i] = 90;
        RotA[i] = Choose(-1, 1)*Rand(5, 50)/10;
        RotB[i] = Choose(-1, 1)*Rand(5, 50)/10;
        VX[i] = VectorX(Distance(128, 88, CPX[i], CPY[i])/120, Angle(128, 88, CPX[i], CPY[i]));
        VY[i] = VectorY(Distance(128, 88, CPX[i], CPY[i])/80, Angle(128, 88, CPX[i], CPY[i]));
    }
    int NumShards = 56;
    while(NumShards>0){
        Screen->Rectangle(Layer, -8, -8, 264, 184, 0x5A, 1, 0, 0, 0, true, 128);
        Screen->DrawScreen(Layer, OldMap, OldScreen, 0, 0, 0);
        Screen->DrawBitmap(Layer, rt, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
        Screen->SetRenderTarget(rt);
        Screen->Rectangle(0, -8, -8, 264, 184, 0x5A, 1, 0, 0, 0, true, 128);
        Screen->DrawScreen(0, NewMap, NewScreen, 0, 0, 0);
        for(i=0; i<56; i++){
            if(CPY[i]<224){
                CPX[i] += VX[i];
                CPY[i] += VY[i];
                VY[i] = Min(VY[i]+0.06, 3.2);
                if(CPY[i]>=224)
                    NumShards--;
            }
            BaseAngA[i] += RotA[i];
            BaseAngB[i] += RotB[i];
       
            int freshprinceofdickbutt = 90;
            //you tread upon the hall of the forbidden Mathemancy. Nobody knows how it works. Well someone might. But it isn't Moosh.
            int X[3];
            int Y[3];
            int Z[3];
            int x0; int y0; int z0; int xtmp;
            x0 = DA[i]*Sin(freshprinceofdickbutt)*Cos(AngA[i]);
            y0 = DA[i]*Sin(freshprinceofdickbutt)*Sin(AngA[i]);
            z0 = DA[i]*Cos(freshprinceofdickbutt);
            X[0] = x0;
            Y[0] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
            Z[0] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
            xtmp = X[0];
            X[0] = X[0]*Cos(BaseAngB[i])+Z[0]*Sin(BaseAngB[i]);
            Z[0] = -xtmp*Sin(BaseAngB[i])+Z[0]*Cos(BaseAngB[i]);
           
            x0 = DB[i]*Sin(freshprinceofdickbutt)*Cos(AngB[i]);
            y0 = DB[i]*Sin(freshprinceofdickbutt)*Sin(AngB[i]);
            z0 = DB[i]*Cos(freshprinceofdickbutt);
            X[1] = x0;
            Y[1] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
            Z[1] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
            xtmp = X[1];
            X[1] = X[1]*Cos(BaseAngB[i])+Z[1]*Sin(BaseAngB[i]);
            Z[1] = -xtmp*Sin(BaseAngB[i])+Z[1]*Cos(BaseAngB[i]);
           
            x0 = DC[i]*Sin(freshprinceofdickbutt)*Cos(AngC[i]);
            y0 = DC[i]*Sin(freshprinceofdickbutt)*Sin(AngC[i]);
            z0 = DC[i]*Cos(freshprinceofdickbutt);
            X[2] = x0;
            Y[2] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
            Z[2] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
            xtmp = X[2];
            X[2] = X[2]*Cos(BaseAngB[i])+Z[2]*Sin(BaseAngB[i]);
            Z[2] = -xtmp*Sin(BaseAngB[i])+Z[2]*Cos(BaseAngB[i]);
           
            Screen->Triangle(0, CPX[i]+X[0], CPY[i]+Y[0]+1, CPX[i]+X[1], CPY[i]+Y[1]+1, CPX[i]+X[2], CPY[i]+Y[2]+1, 2, 2, 0x5A, 0, -1, PT_FLAT);
            Screen->Triangle(0, CPX[i]+X[0], CPY[i]+Y[0], CPX[i]+X[1], CPY[i]+Y[1], CPX[i]+X[2], CPY[i]+Y[2], 1, 1, 0x00, 0, -1, PT_FLAT);
        }
        Screen->SetRenderTarget(RT_SCREEN);
        Waitframe();
    }
}
 
ffc script Spergo{
    void run(){
		for (int i = 0; i <= 6; i++) {
			Screen->SetRenderTarget(i);
			for (int j = 0; j <= 7; j++) {
				Screen->Rectangle(j, 0, 0, 512, 512, 0x00, 1, 0, 0, 0, true, OP_OPAQUE);
			}
		}
		Screen->SetRenderTarget(-1);
        Screen->D[0] = 0;
		while(Screen->D[0] == 0){
			Waitframe();
		}
		Screen->SetRenderTarget(5);
		int tilenum = 39260;
		for(int i=0; i<32; i++){
			for(int j=0; j<32; j++){
				Screen->FastTile(0, j*16, i*16, tilenum, 5, OP_OPAQUE);
				tilenum ++;
			}
		}
		Screen->SetRenderTarget(-1);
        Game->PlaySound(76);
        The_Spergiest_Thing_I_Will_Ever_Write_Probably(0, 4, 11, 0x33, 11, 0x00);
		int radius = 40;
		int speed = 1;
		int angle = -1;
		int radius2 = 24;
		int angle2 = 45;
		if(radius2 == 0) radius2 = radius; //Circle
		if(angle < 0) angle = Rand(360); //Random Start
		int cx = this->X;
		int cy = this->Y;
		float tangle = Randf(360);
		int spinstop = 121;
		int boundary = 80;
		int spindir = Choose(Rand(-0.75, -0.25), Rand(0.25, 0.75));
		int openingradius;
        while(true){
			Screen->SetRenderTarget(6);
			Screen->DrawScreen(0, 11, 0x00, 0, 0, 0);
			
			spinstop ++;
			if ( spinstop > 120 ) {
				angle += speed;
				if(angle < -360)angle+=360; //Wrap if below -360.
				else if(angle > 360)angle-=360; //Wrap if above 360.
				if(angle2==0)
				{
					this->X = cx + radius*Cos(angle);
					this->Y = cy + radius2*Sin(angle);
				}
				else //Rotate at center.
				{
					this->X = cx + radius*Cos(angle)*Cos(angle2) - radius2*Sin(angle)*Sin(angle2);
					this->Y = cy + radius2*Sin(angle)*Cos(angle2) + radius*Cos(angle)*Sin(angle2);
				}
			}
			if ( spinstop > 240 ) {
				spinstop = 0;
				spindir = Choose(Randf(-0.7, -0.3), Randf(0.3, 0.7));
			}
			Screen->DrawBitmap(0, 5, 0, 0, 512, 512, this->X-128, this->Y-168, 512, 512, tangle, false);
			if ( spinstop <= 120 ) {
				tangle += spindir;
				if(tangle<-360) tangle+=360;
				else if(tangle>=360) tangle-=360;
			}
			
			if ( openingradius < 192 ) {
				Screen->Rectangle(0, -1, -1, 257, 87-openingradius, 0x5A, 1, 0, 0, 0, true, OP_OPAQUE);
				Screen->Rectangle(0, -1, 88+openingradius, 257, 177, 0x5A, 1, 0, 0, 0, true, OP_OPAQUE);
				Screen->Rectangle(0, -1, -1, 96-openingradius, 177, 0x5A, 1, 0, 0, 0, true, OP_OPAQUE);
				Screen->Rectangle(0, 159+openingradius, -1, 257, 177, 0x5A, 1, 0, 0, 0, true, OP_OPAQUE);
				openingradius ++;
			}
			
			Screen->Rectangle(0, 31+VectorX(boundary, 40), 31+VectorY(boundary, 40), 224-VectorX(boundary, 40), 144-VectorX(boundary, 40), 0x01, 1, 0, 0, 0, false, OP_OPAQUE);
			
			Screen->SetRenderTarget(-1);
			if ( boundary > 0 )
				boundary -= 3;
			if ( boundary < 0 )
				boundary = 0;
            Waitframe();
        }
    }
}

const int ICE_MAX = 5;//Max speed on ice in pixels per frame, in addition to Link's base walking speed.
const int ICE_DEF_ACCEL = 0.25;//Default acceleration if none defined, in portion of current speed.
const int ICE_DEF_DECEL = 0.10;//Default deceleration if none defined, in portion of current speed. Never >1. 1 = dead stop.
const int icebase = 4;//base factor for accel/decel when movement is too slow/nonexistent
ffc script icePhysics{
	bool isOnIce(){
		if ( Screen->D[1] == 1 )
			return true;
		else
			return false;
	}

	void run(int accel, int decel){
		Screen->D[1] = 0;
		if(accel==0)accel=ICE_DEF_ACCEL;
		if(decel==0)decel=ICE_DEF_DECEL;
		int xaccel=0;
		int yaccel=0;
		int xdecel=0;
		int ydecel=0;
		int Vx = 0;
		int Vy = 0;
		bool onIce = false;
		bool noTract = true;
		int scrn = 0;
		while(true){
			if(!onIce){
				Vx=0;
				Vy=0;
			}
			if(Abs(Vy)<0.1){Vy=0;}
			if(Abs(Vx)<0.1){Vx=0;}
			if(!onIce && isOnIce()){//Link has just stepped onto ice
				if(Link->InputDown)Vy+=1;
				if(Link->InputUp)Vy-=1;
				if(Link->InputRight)Vx+=1;
				if(Link->InputLeft)Vx-=1;
			} else if(onIce){
				if(Abs(Vx)>=0.1){
					xaccel = accel * Abs(Vx);
					xdecel = decel * Abs(Vx);
				} else {xaccel = accel * icebase; xdecel=decel * icebase;}
				if(Abs(Vy)>=0.1){
					yaccel = accel * Abs(Vy);
					ydecel = decel * Abs(Vy);
				} else {yaccel = accel * icebase; ydecel=decel * icebase;}
				if(Abs(Vy)<ICE_MAX){
					if(Link->InputDown){Vy+=yaccel;}
					if(Link->InputUp){Vy-=yaccel;}
				}
				if(Abs(Vx)<ICE_MAX){
					if(Link->InputRight){Vx+=xaccel;}
					if(Link->InputLeft){Vx-=xaccel;}
				}
				if(Vx>0){
					if(CanWalk(Link->X,Link->Y,DIR_RIGHT,1,false)){
						Link->X+=Vx;
						if(!Link->InputRight)Vx-=xdecel;
					} else {
						Vx=0;
					}
				} else if(Vx<0){
					if(CanWalk(Link->X,Link->Y,DIR_LEFT,1,false)){
						Link->X+=Vx;
						if(!Link->InputLeft)Vx+=xdecel;
					} else {
						Vx=0;
					}
				}
				if(Vy>0){
					if(CanWalk(Link->X,Link->Y,DIR_DOWN,1,false)){
						Link->Y+=Vy;
						if(!Link->InputDown)Vy-=ydecel;
					} else {
						Vy=0;
					}
				} else if(Vy<0){
					if(CanWalk(Link->X,Link->Y,DIR_UP,1,false)){
						Link->Y+=Vy;
						if(!Link->InputUp)Vy+=ydecel;
					} else {
						Vy=0;
					}
				}
			}
			onIce = isOnIce();
			Waitframe();
		}
	}
}

ffc script Ending{
	void run(){
		Link->HP = Link->MaxHP;
		WaitNoAction(60);
		Screen->Message(82);
		WaitNoAction(60);
		int ZScriptX = 48;
		int ZScriptY = -48;
		int HavocX = 64;
		int HavocY = 176;
		int TitleTimer = 120;
		int HorizontalSpeed = 2;
		int VerticalSpeed = 3;
		while(true){
			if ( ZScriptX >= 256 ) {
				Screen->Message(83);
				WaitNoAction(60);
				Screen->Message(89);
				WaitNoAction(60);
				this->Data = 888;
			}
			else {
				NoAction();
				Link->InputStart = false;
				Link->InputMap = false;
			}
			if ( ZScriptY < 48 ) {
				ZScriptY += VerticalSpeed;
				HavocY -= VerticalSpeed;
				VerticalSpeed -= 0.04;
			}
			else if ( TitleTimer != 0 )
				TitleTimer --;
			if ( TitleTimer == 0 ) {
				ZScriptX += HorizontalSpeed;
				HavocX -= HorizontalSpeed;
				HorizontalSpeed += 0.05;
			}
			Screen->DrawTile(6, ZScriptX, ZScriptY, 38743, 10, 3, 6, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
			Screen->DrawTile(6, HavocX, HavocY, 38804, 8, 2, 6, -1, -1, 0, 0, 0, 0, true, OP_OPAQUE);
			Waitframe();
		}
	}
}

yah

ffc script IdiotProof{
	void run(){
		while(true){
			if ( (Screen->ComboD[38] == 632 && Screen->ComboD[70] == 632 && Screen->ComboD[86] == 632 && ComboAt(Link->X+8, Link->Y+12) == 54)
			|| (Screen->ComboD[134] == 632 && Screen->ComboD[102] == 632 && Screen->ComboD[86] == 632 && ComboAt(Link->X+8, Link->Y+12) == 118) ) {
				Waitframes(180);
				Link->X -= 32;
			}
			Waitframe();
		}
	}
}